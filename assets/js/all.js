"use strict";

var navMainToggle = document.querySelector(".navMainToggle");
var navMain = document.querySelector(".navMain");
var navMainToggleTitle = navMainToggle.getAttribute("title");
var searchToggle = document.querySelector(".searchToggle"); //點漢堡icon時

navMainToggle.onclick = function () {
  //增加一個active的class
  navMain.classList.toggle("active"); // //修改title的值為收合選單

  if (navMainToggleTitle === "選單") {
    navMainToggle.setAttribute("title", "收合選單");
    navMainToggleTitle = navMainToggle.getAttribute("title");
  } // //修改title的值為選單
  else if (navMainToggleTitle === "收合選單") {
      navMainToggle.setAttribute("title", "選單");
      navMainToggleTitle = navMainToggle.getAttribute("title");
    }
}; //錢包 複選


$('.wallet-check input').on('change', function () {
  $(this).next('label').toggleClass('active');
}); // swiper

var swiperArtist = new Swiper('.swiperArtist', {
  effect: "coverflow",
  grabCursor: true,
  centeredSlides: true,
  loop: true,
  initialSlide: 1,
  spaceBetween: 0,
  slidesPerView: "auto",
  paginationClickable: true,
  //表示分頁能否點選
  coverflowEffect: {
    rotate: 0,
    depth: 200,
    scale: 0.7
  },
  pagination: {
    el: ".swiper-pagination"
  }
});
/* imagesLoaded*/
//指定瀑布流區塊div

var $container = $('.masonry'); //當圖片讀取完畢才執行

$container.imagesLoaded(function () {
  //選擇瀑布流內的區塊名稱
  $container.masonry({
    itemSelector: '.card-Artwork'
  });
});
"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/*!
 * imagesLoaded PACKAGED v5.0.0
 * JavaScript is all like "You images are done yet or what?"
 * MIT License
 */
!function (t, e) {
  "object" == (typeof module === "undefined" ? "undefined" : _typeof(module)) && module.exports ? module.exports = e() : t.EvEmitter = e();
}("undefined" != typeof window ? window : void 0, function () {
  function t() {}

  var e = t.prototype;
  return e.on = function (t, e) {
    if (!t || !e) return this;
    var i = this._events = this._events || {},
        s = i[t] = i[t] || [];
    return s.includes(e) || s.push(e), this;
  }, e.once = function (t, e) {
    if (!t || !e) return this;
    this.on(t, e);
    var i = this._onceEvents = this._onceEvents || {};
    return (i[t] = i[t] || {})[e] = !0, this;
  }, e.off = function (t, e) {
    var i = this._events && this._events[t];
    if (!i || !i.length) return this;
    var s = i.indexOf(e);
    return -1 != s && i.splice(s, 1), this;
  }, e.emitEvent = function (t, e) {
    var i = this._events && this._events[t];
    if (!i || !i.length) return this;
    i = i.slice(0), e = e || [];
    var s = this._onceEvents && this._onceEvents[t];

    var _iterator = _createForOfIteratorHelper(i),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var n = _step.value;
        s && s[n] && (this.off(t, n), delete s[n]), n.apply(this, e);
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    return this;
  }, e.allOff = function () {
    return delete this._events, delete this._onceEvents, this;
  }, t;
}),
/*!
 * imagesLoaded v5.0.0
 * JavaScript is all like "You images are done yet or what?"
 * MIT License
 */
function (t, e) {
  "object" == (typeof module === "undefined" ? "undefined" : _typeof(module)) && module.exports ? module.exports = e(t, require("ev-emitter")) : t.imagesLoaded = e(t, t.EvEmitter);
}("undefined" != typeof window ? window : void 0, function (t, e) {
  var i = t.jQuery,
      s = t.console;

  function n(t, e, o) {
    if (!(this instanceof n)) return new n(t, e, o);
    var r = t;
    var h;
    ("string" == typeof t && (r = document.querySelectorAll(t)), r) ? (this.elements = (h = r, Array.isArray(h) ? h : "object" == _typeof(h) && "number" == typeof h.length ? _toConsumableArray(h) : [h]), this.options = {}, "function" == typeof e ? o = e : Object.assign(this.options, e), o && this.on("always", o), this.getImages(), i && (this.jqDeferred = new i.Deferred()), setTimeout(this.check.bind(this))) : s.error("Bad element for imagesLoaded ".concat(r || t));
  }

  n.prototype = Object.create(e.prototype), n.prototype.getImages = function () {
    this.images = [], this.elements.forEach(this.addElementImages, this);
  };
  var o = [1, 9, 11];

  n.prototype.addElementImages = function (t) {
    "IMG" === t.nodeName && this.addImage(t), !0 === this.options.background && this.addElementBackgroundImages(t);
    var e = t.nodeType;
    if (!e || !o.includes(e)) return;
    var i = t.querySelectorAll("img");

    var _iterator2 = _createForOfIteratorHelper(i),
        _step2;

    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var _t2 = _step2.value;
        this.addImage(_t2);
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }

    if ("string" == typeof this.options.background) {
      var _e = t.querySelectorAll(this.options.background);

      var _iterator3 = _createForOfIteratorHelper(_e),
          _step3;

      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var _t = _step3.value;
          this.addElementBackgroundImages(_t);
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
    }
  };

  var r = /url\((['"])?(.*?)\1\)/gi;

  function h(t) {
    this.img = t;
  }

  function d(t, e) {
    this.url = t, this.element = e, this.img = new Image();
  }

  return n.prototype.addElementBackgroundImages = function (t) {
    var e = getComputedStyle(t);
    if (!e) return;
    var i = r.exec(e.backgroundImage);

    for (; null !== i;) {
      var _s = i && i[2];

      _s && this.addBackground(_s, t), i = r.exec(e.backgroundImage);
    }
  }, n.prototype.addImage = function (t) {
    var e = new h(t);
    this.images.push(e);
  }, n.prototype.addBackground = function (t, e) {
    var i = new d(t, e);
    this.images.push(i);
  }, n.prototype.check = function () {
    var _this = this;

    if (this.progressedCount = 0, this.hasAnyBroken = !1, !this.images.length) return void this.complete();

    var t = function t(_t3, e, i) {
      setTimeout(function () {
        _this.progress(_t3, e, i);
      });
    };

    this.images.forEach(function (e) {
      e.once("progress", t), e.check();
    });
  }, n.prototype.progress = function (t, e, i) {
    this.progressedCount++, this.hasAnyBroken = this.hasAnyBroken || !t.isLoaded, this.emitEvent("progress", [this, t, e]), this.jqDeferred && this.jqDeferred.notify && this.jqDeferred.notify(this, t), this.progressedCount === this.images.length && this.complete(), this.options.debug && s && s.log("progress: ".concat(i), t, e);
  }, n.prototype.complete = function () {
    var t = this.hasAnyBroken ? "fail" : "done";

    if (this.isComplete = !0, this.emitEvent(t, [this]), this.emitEvent("always", [this]), this.jqDeferred) {
      var _t4 = this.hasAnyBroken ? "reject" : "resolve";

      this.jqDeferred[_t4](this);
    }
  }, h.prototype = Object.create(e.prototype), h.prototype.check = function () {
    this.getIsImageComplete() ? this.confirm(0 !== this.img.naturalWidth, "naturalWidth") : (this.proxyImage = new Image(), this.img.crossOrigin && (this.proxyImage.crossOrigin = this.img.crossOrigin), this.proxyImage.addEventListener("load", this), this.proxyImage.addEventListener("error", this), this.img.addEventListener("load", this), this.img.addEventListener("error", this), this.proxyImage.src = this.img.currentSrc || this.img.src);
  }, h.prototype.getIsImageComplete = function () {
    return this.img.complete && this.img.naturalWidth;
  }, h.prototype.confirm = function (t, e) {
    this.isLoaded = t;
    var i = this.img.parentNode,
        s = "PICTURE" === i.nodeName ? i : this.img;
    this.emitEvent("progress", [this, s, e]);
  }, h.prototype.handleEvent = function (t) {
    var e = "on" + t.type;
    this[e] && this[e](t);
  }, h.prototype.onload = function () {
    this.confirm(!0, "onload"), this.unbindEvents();
  }, h.prototype.onerror = function () {
    this.confirm(!1, "onerror"), this.unbindEvents();
  }, h.prototype.unbindEvents = function () {
    this.proxyImage.removeEventListener("load", this), this.proxyImage.removeEventListener("error", this), this.img.removeEventListener("load", this), this.img.removeEventListener("error", this);
  }, d.prototype = Object.create(h.prototype), d.prototype.check = function () {
    this.img.addEventListener("load", this), this.img.addEventListener("error", this), this.img.src = this.url, this.getIsImageComplete() && (this.confirm(0 !== this.img.naturalWidth, "naturalWidth"), this.unbindEvents());
  }, d.prototype.unbindEvents = function () {
    this.img.removeEventListener("load", this), this.img.removeEventListener("error", this);
  }, d.prototype.confirm = function (t, e) {
    this.isLoaded = t, this.emitEvent("progress", [this, this.element, e]);
  }, n.makeJQueryPlugin = function (e) {
    (e = e || t.jQuery) && (i = e, i.fn.imagesLoaded = function (t, e) {
      return new n(this, t, e).jqDeferred.promise(i(this));
    });
  }, n.makeJQueryPlugin(), n;
});
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/*!
 * Masonry PACKAGED v4.2.2
 * Cascading grid layout library
 * https://masonry.desandro.com
 * MIT License
 * by David DeSandro
 */
!function (t, e) {
  "function" == typeof define && define.amd ? define("jquery-bridget/jquery-bridget", ["jquery"], function (i) {
    return e(t, i);
  }) : "object" == (typeof module === "undefined" ? "undefined" : _typeof(module)) && module.exports ? module.exports = e(t, require("jquery")) : t.jQueryBridget = e(t, t.jQuery);
}(window, function (t, e) {
  "use strict";

  function i(i, r, a) {
    function h(t, e, n) {
      var o,
          r = "$()." + i + '("' + e + '")';
      return t.each(function (t, h) {
        var u = a.data(h, i);
        if (!u) return void s(i + " not initialized. Cannot call methods, i.e. " + r);
        var d = u[e];
        if (!d || "_" == e.charAt(0)) return void s(r + " is not a valid method");
        var l = d.apply(u, n);
        o = void 0 === o ? l : o;
      }), void 0 !== o ? o : t;
    }

    function u(t, e) {
      t.each(function (t, n) {
        var o = a.data(n, i);
        o ? (o.option(e), o._init()) : (o = new r(n, e), a.data(n, i, o));
      });
    }

    a = a || e || t.jQuery, a && (r.prototype.option || (r.prototype.option = function (t) {
      a.isPlainObject(t) && (this.options = a.extend(!0, this.options, t));
    }), a.fn[i] = function (t) {
      if ("string" == typeof t) {
        var e = o.call(arguments, 1);
        return h(this, t, e);
      }

      return u(this, t), this;
    }, n(a));
  }

  function n(t) {
    !t || t && t.bridget || (t.bridget = i);
  }

  var o = Array.prototype.slice,
      r = t.console,
      s = "undefined" == typeof r ? function () {} : function (t) {
    r.error(t);
  };
  return n(e || t.jQuery), i;
}), function (t, e) {
  "function" == typeof define && define.amd ? define("ev-emitter/ev-emitter", e) : "object" == (typeof module === "undefined" ? "undefined" : _typeof(module)) && module.exports ? module.exports = e() : t.EvEmitter = e();
}("undefined" != typeof window ? window : void 0, function () {
  function t() {}

  var e = t.prototype;
  return e.on = function (t, e) {
    if (t && e) {
      var i = this._events = this._events || {},
          n = i[t] = i[t] || [];
      return -1 == n.indexOf(e) && n.push(e), this;
    }
  }, e.once = function (t, e) {
    if (t && e) {
      this.on(t, e);
      var i = this._onceEvents = this._onceEvents || {},
          n = i[t] = i[t] || {};
      return n[e] = !0, this;
    }
  }, e.off = function (t, e) {
    var i = this._events && this._events[t];

    if (i && i.length) {
      var n = i.indexOf(e);
      return -1 != n && i.splice(n, 1), this;
    }
  }, e.emitEvent = function (t, e) {
    var i = this._events && this._events[t];

    if (i && i.length) {
      i = i.slice(0), e = e || [];

      for (var n = this._onceEvents && this._onceEvents[t], o = 0; o < i.length; o++) {
        var r = i[o],
            s = n && n[r];
        s && (this.off(t, r), delete n[r]), r.apply(this, e);
      }

      return this;
    }
  }, e.allOff = function () {
    delete this._events, delete this._onceEvents;
  }, t;
}), function (t, e) {
  "function" == typeof define && define.amd ? define("get-size/get-size", e) : "object" == (typeof module === "undefined" ? "undefined" : _typeof(module)) && module.exports ? module.exports = e() : t.getSize = e();
}(window, function () {
  "use strict";

  function t(t) {
    var e = parseFloat(t),
        i = -1 == t.indexOf("%") && !isNaN(e);
    return i && e;
  }

  function e() {}

  function i() {
    for (var t = {
      width: 0,
      height: 0,
      innerWidth: 0,
      innerHeight: 0,
      outerWidth: 0,
      outerHeight: 0
    }, e = 0; u > e; e++) {
      var i = h[e];
      t[i] = 0;
    }

    return t;
  }

  function n(t) {
    var e = getComputedStyle(t);
    return e || a("Style returned " + e + ". Are you running this code in a hidden iframe on Firefox? See https://bit.ly/getsizebug1"), e;
  }

  function o() {
    if (!d) {
      d = !0;
      var e = document.createElement("div");
      e.style.width = "200px", e.style.padding = "1px 2px 3px 4px", e.style.borderStyle = "solid", e.style.borderWidth = "1px 2px 3px 4px", e.style.boxSizing = "border-box";
      var i = document.body || document.documentElement;
      i.appendChild(e);
      var o = n(e);
      s = 200 == Math.round(t(o.width)), r.isBoxSizeOuter = s, i.removeChild(e);
    }
  }

  function r(e) {
    if (o(), "string" == typeof e && (e = document.querySelector(e)), e && "object" == _typeof(e) && e.nodeType) {
      var r = n(e);
      if ("none" == r.display) return i();
      var a = {};
      a.width = e.offsetWidth, a.height = e.offsetHeight;

      for (var d = a.isBorderBox = "border-box" == r.boxSizing, l = 0; u > l; l++) {
        var c = h[l],
            f = r[c],
            m = parseFloat(f);
        a[c] = isNaN(m) ? 0 : m;
      }

      var p = a.paddingLeft + a.paddingRight,
          g = a.paddingTop + a.paddingBottom,
          y = a.marginLeft + a.marginRight,
          v = a.marginTop + a.marginBottom,
          _ = a.borderLeftWidth + a.borderRightWidth,
          z = a.borderTopWidth + a.borderBottomWidth,
          E = d && s,
          b = t(r.width);

      b !== !1 && (a.width = b + (E ? 0 : p + _));
      var x = t(r.height);
      return x !== !1 && (a.height = x + (E ? 0 : g + z)), a.innerWidth = a.width - (p + _), a.innerHeight = a.height - (g + z), a.outerWidth = a.width + y, a.outerHeight = a.height + v, a;
    }
  }

  var s,
      a = "undefined" == typeof console ? e : function (t) {
    console.error(t);
  },
      h = ["paddingLeft", "paddingRight", "paddingTop", "paddingBottom", "marginLeft", "marginRight", "marginTop", "marginBottom", "borderLeftWidth", "borderRightWidth", "borderTopWidth", "borderBottomWidth"],
      u = h.length,
      d = !1;
  return r;
}), function (t, e) {
  "use strict";

  "function" == typeof define && define.amd ? define("desandro-matches-selector/matches-selector", e) : "object" == (typeof module === "undefined" ? "undefined" : _typeof(module)) && module.exports ? module.exports = e() : t.matchesSelector = e();
}(window, function () {
  "use strict";

  var t = function () {
    var t = window.Element.prototype;
    if (t.matches) return "matches";
    if (t.matchesSelector) return "matchesSelector";

    for (var e = ["webkit", "moz", "ms", "o"], i = 0; i < e.length; i++) {
      var n = e[i],
          o = n + "MatchesSelector";
      if (t[o]) return o;
    }
  }();

  return function (e, i) {
    return e[t](i);
  };
}), function (t, e) {
  "function" == typeof define && define.amd ? define("fizzy-ui-utils/utils", ["desandro-matches-selector/matches-selector"], function (i) {
    return e(t, i);
  }) : "object" == (typeof module === "undefined" ? "undefined" : _typeof(module)) && module.exports ? module.exports = e(t, require("desandro-matches-selector")) : t.fizzyUIUtils = e(t, t.matchesSelector);
}(window, function (t, e) {
  var i = {};
  i.extend = function (t, e) {
    for (var i in e) {
      t[i] = e[i];
    }

    return t;
  }, i.modulo = function (t, e) {
    return (t % e + e) % e;
  };
  var n = Array.prototype.slice;
  i.makeArray = function (t) {
    if (Array.isArray(t)) return t;
    if (null === t || void 0 === t) return [];
    var e = "object" == _typeof(t) && "number" == typeof t.length;
    return e ? n.call(t) : [t];
  }, i.removeFrom = function (t, e) {
    var i = t.indexOf(e);
    -1 != i && t.splice(i, 1);
  }, i.getParent = function (t, i) {
    for (; t.parentNode && t != document.body;) {
      if (t = t.parentNode, e(t, i)) return t;
    }
  }, i.getQueryElement = function (t) {
    return "string" == typeof t ? document.querySelector(t) : t;
  }, i.handleEvent = function (t) {
    var e = "on" + t.type;
    this[e] && this[e](t);
  }, i.filterFindElements = function (t, n) {
    t = i.makeArray(t);
    var o = [];
    return t.forEach(function (t) {
      if (t instanceof HTMLElement) {
        if (!n) return void o.push(t);
        e(t, n) && o.push(t);

        for (var i = t.querySelectorAll(n), r = 0; r < i.length; r++) {
          o.push(i[r]);
        }
      }
    }), o;
  }, i.debounceMethod = function (t, e, i) {
    i = i || 100;
    var n = t.prototype[e],
        o = e + "Timeout";

    t.prototype[e] = function () {
      var t = this[o];
      clearTimeout(t);
      var e = arguments,
          r = this;
      this[o] = setTimeout(function () {
        n.apply(r, e), delete r[o];
      }, i);
    };
  }, i.docReady = function (t) {
    var e = document.readyState;
    "complete" == e || "interactive" == e ? setTimeout(t) : document.addEventListener("DOMContentLoaded", t);
  }, i.toDashed = function (t) {
    return t.replace(/(.)([A-Z])/g, function (t, e, i) {
      return e + "-" + i;
    }).toLowerCase();
  };
  var o = t.console;
  return i.htmlInit = function (e, n) {
    i.docReady(function () {
      var r = i.toDashed(n),
          s = "data-" + r,
          a = document.querySelectorAll("[" + s + "]"),
          h = document.querySelectorAll(".js-" + r),
          u = i.makeArray(a).concat(i.makeArray(h)),
          d = s + "-options",
          l = t.jQuery;
      u.forEach(function (t) {
        var i,
            r = t.getAttribute(s) || t.getAttribute(d);

        try {
          i = r && JSON.parse(r);
        } catch (a) {
          return void (o && o.error("Error parsing " + s + " on " + t.className + ": " + a));
        }

        var h = new e(t, i);
        l && l.data(t, n, h);
      });
    });
  }, i;
}), function (t, e) {
  "function" == typeof define && define.amd ? define("outlayer/item", ["ev-emitter/ev-emitter", "get-size/get-size"], e) : "object" == (typeof module === "undefined" ? "undefined" : _typeof(module)) && module.exports ? module.exports = e(require("ev-emitter"), require("get-size")) : (t.Outlayer = {}, t.Outlayer.Item = e(t.EvEmitter, t.getSize));
}(window, function (t, e) {
  "use strict";

  function i(t) {
    for (var e in t) {
      return !1;
    }

    return e = null, !0;
  }

  function n(t, e) {
    t && (this.element = t, this.layout = e, this.position = {
      x: 0,
      y: 0
    }, this._create());
  }

  function o(t) {
    return t.replace(/([A-Z])/g, function (t) {
      return "-" + t.toLowerCase();
    });
  }

  var r = document.documentElement.style,
      s = "string" == typeof r.transition ? "transition" : "WebkitTransition",
      a = "string" == typeof r.transform ? "transform" : "WebkitTransform",
      h = {
    WebkitTransition: "webkitTransitionEnd",
    transition: "transitionend"
  }[s],
      u = {
    transform: a,
    transition: s,
    transitionDuration: s + "Duration",
    transitionProperty: s + "Property",
    transitionDelay: s + "Delay"
  },
      d = n.prototype = Object.create(t.prototype);
  d.constructor = n, d._create = function () {
    this._transn = {
      ingProperties: {},
      clean: {},
      onEnd: {}
    }, this.css({
      position: "absolute"
    });
  }, d.handleEvent = function (t) {
    var e = "on" + t.type;
    this[e] && this[e](t);
  }, d.getSize = function () {
    this.size = e(this.element);
  }, d.css = function (t) {
    var e = this.element.style;

    for (var i in t) {
      var n = u[i] || i;
      e[n] = t[i];
    }
  }, d.getPosition = function () {
    var t = getComputedStyle(this.element),
        e = this.layout._getOption("originLeft"),
        i = this.layout._getOption("originTop"),
        n = t[e ? "left" : "right"],
        o = t[i ? "top" : "bottom"],
        r = parseFloat(n),
        s = parseFloat(o),
        a = this.layout.size;

    -1 != n.indexOf("%") && (r = r / 100 * a.width), -1 != o.indexOf("%") && (s = s / 100 * a.height), r = isNaN(r) ? 0 : r, s = isNaN(s) ? 0 : s, r -= e ? a.paddingLeft : a.paddingRight, s -= i ? a.paddingTop : a.paddingBottom, this.position.x = r, this.position.y = s;
  }, d.layoutPosition = function () {
    var t = this.layout.size,
        e = {},
        i = this.layout._getOption("originLeft"),
        n = this.layout._getOption("originTop"),
        o = i ? "paddingLeft" : "paddingRight",
        r = i ? "left" : "right",
        s = i ? "right" : "left",
        a = this.position.x + t[o];

    e[r] = this.getXValue(a), e[s] = "";
    var h = n ? "paddingTop" : "paddingBottom",
        u = n ? "top" : "bottom",
        d = n ? "bottom" : "top",
        l = this.position.y + t[h];
    e[u] = this.getYValue(l), e[d] = "", this.css(e), this.emitEvent("layout", [this]);
  }, d.getXValue = function (t) {
    var e = this.layout._getOption("horizontal");

    return this.layout.options.percentPosition && !e ? t / this.layout.size.width * 100 + "%" : t + "px";
  }, d.getYValue = function (t) {
    var e = this.layout._getOption("horizontal");

    return this.layout.options.percentPosition && e ? t / this.layout.size.height * 100 + "%" : t + "px";
  }, d._transitionTo = function (t, e) {
    this.getPosition();
    var i = this.position.x,
        n = this.position.y,
        o = t == this.position.x && e == this.position.y;
    if (this.setPosition(t, e), o && !this.isTransitioning) return void this.layoutPosition();
    var r = t - i,
        s = e - n,
        a = {};
    a.transform = this.getTranslate(r, s), this.transition({
      to: a,
      onTransitionEnd: {
        transform: this.layoutPosition
      },
      isCleaning: !0
    });
  }, d.getTranslate = function (t, e) {
    var i = this.layout._getOption("originLeft"),
        n = this.layout._getOption("originTop");

    return t = i ? t : -t, e = n ? e : -e, "translate3d(" + t + "px, " + e + "px, 0)";
  }, d.goTo = function (t, e) {
    this.setPosition(t, e), this.layoutPosition();
  }, d.moveTo = d._transitionTo, d.setPosition = function (t, e) {
    this.position.x = parseFloat(t), this.position.y = parseFloat(e);
  }, d._nonTransition = function (t) {
    this.css(t.to), t.isCleaning && this._removeStyles(t.to);

    for (var e in t.onTransitionEnd) {
      t.onTransitionEnd[e].call(this);
    }
  }, d.transition = function (t) {
    if (!parseFloat(this.layout.options.transitionDuration)) return void this._nonTransition(t);
    var e = this._transn;

    for (var i in t.onTransitionEnd) {
      e.onEnd[i] = t.onTransitionEnd[i];
    }

    for (i in t.to) {
      e.ingProperties[i] = !0, t.isCleaning && (e.clean[i] = !0);
    }

    if (t.from) {
      this.css(t.from);
      var n = this.element.offsetHeight;
      n = null;
    }

    this.enableTransition(t.to), this.css(t.to), this.isTransitioning = !0;
  };
  var l = "opacity," + o(a);
  d.enableTransition = function () {
    if (!this.isTransitioning) {
      var t = this.layout.options.transitionDuration;
      t = "number" == typeof t ? t + "ms" : t, this.css({
        transitionProperty: l,
        transitionDuration: t,
        transitionDelay: this.staggerDelay || 0
      }), this.element.addEventListener(h, this, !1);
    }
  }, d.onwebkitTransitionEnd = function (t) {
    this.ontransitionend(t);
  }, d.onotransitionend = function (t) {
    this.ontransitionend(t);
  };
  var c = {
    "-webkit-transform": "transform"
  };
  d.ontransitionend = function (t) {
    if (t.target === this.element) {
      var e = this._transn,
          n = c[t.propertyName] || t.propertyName;

      if (delete e.ingProperties[n], i(e.ingProperties) && this.disableTransition(), n in e.clean && (this.element.style[t.propertyName] = "", delete e.clean[n]), n in e.onEnd) {
        var o = e.onEnd[n];
        o.call(this), delete e.onEnd[n];
      }

      this.emitEvent("transitionEnd", [this]);
    }
  }, d.disableTransition = function () {
    this.removeTransitionStyles(), this.element.removeEventListener(h, this, !1), this.isTransitioning = !1;
  }, d._removeStyles = function (t) {
    var e = {};

    for (var i in t) {
      e[i] = "";
    }

    this.css(e);
  };
  var f = {
    transitionProperty: "",
    transitionDuration: "",
    transitionDelay: ""
  };
  return d.removeTransitionStyles = function () {
    this.css(f);
  }, d.stagger = function (t) {
    t = isNaN(t) ? 0 : t, this.staggerDelay = t + "ms";
  }, d.removeElem = function () {
    this.element.parentNode.removeChild(this.element), this.css({
      display: ""
    }), this.emitEvent("remove", [this]);
  }, d.remove = function () {
    return s && parseFloat(this.layout.options.transitionDuration) ? (this.once("transitionEnd", function () {
      this.removeElem();
    }), void this.hide()) : void this.removeElem();
  }, d.reveal = function () {
    delete this.isHidden, this.css({
      display: ""
    });
    var t = this.layout.options,
        e = {},
        i = this.getHideRevealTransitionEndProperty("visibleStyle");
    e[i] = this.onRevealTransitionEnd, this.transition({
      from: t.hiddenStyle,
      to: t.visibleStyle,
      isCleaning: !0,
      onTransitionEnd: e
    });
  }, d.onRevealTransitionEnd = function () {
    this.isHidden || this.emitEvent("reveal");
  }, d.getHideRevealTransitionEndProperty = function (t) {
    var e = this.layout.options[t];
    if (e.opacity) return "opacity";

    for (var i in e) {
      return i;
    }
  }, d.hide = function () {
    this.isHidden = !0, this.css({
      display: ""
    });
    var t = this.layout.options,
        e = {},
        i = this.getHideRevealTransitionEndProperty("hiddenStyle");
    e[i] = this.onHideTransitionEnd, this.transition({
      from: t.visibleStyle,
      to: t.hiddenStyle,
      isCleaning: !0,
      onTransitionEnd: e
    });
  }, d.onHideTransitionEnd = function () {
    this.isHidden && (this.css({
      display: "none"
    }), this.emitEvent("hide"));
  }, d.destroy = function () {
    this.css({
      position: "",
      left: "",
      right: "",
      top: "",
      bottom: "",
      transition: "",
      transform: ""
    });
  }, n;
}), function (t, e) {
  "use strict";

  "function" == typeof define && define.amd ? define("outlayer/outlayer", ["ev-emitter/ev-emitter", "get-size/get-size", "fizzy-ui-utils/utils", "./item"], function (i, n, o, r) {
    return e(t, i, n, o, r);
  }) : "object" == (typeof module === "undefined" ? "undefined" : _typeof(module)) && module.exports ? module.exports = e(t, require("ev-emitter"), require("get-size"), require("fizzy-ui-utils"), require("./item")) : t.Outlayer = e(t, t.EvEmitter, t.getSize, t.fizzyUIUtils, t.Outlayer.Item);
}(window, function (t, e, i, n, o) {
  "use strict";

  function r(t, e) {
    var i = n.getQueryElement(t);
    if (!i) return void (h && h.error("Bad element for " + this.constructor.namespace + ": " + (i || t)));
    this.element = i, u && (this.$element = u(this.element)), this.options = n.extend({}, this.constructor.defaults), this.option(e);
    var o = ++l;
    this.element.outlayerGUID = o, c[o] = this, this._create();

    var r = this._getOption("initLayout");

    r && this.layout();
  }

  function s(t) {
    function e() {
      t.apply(this, arguments);
    }

    return e.prototype = Object.create(t.prototype), e.prototype.constructor = e, e;
  }

  function a(t) {
    if ("number" == typeof t) return t;
    var e = t.match(/(^\d*\.?\d*)(\w*)/),
        i = e && e[1],
        n = e && e[2];
    if (!i.length) return 0;
    i = parseFloat(i);
    var o = m[n] || 1;
    return i * o;
  }

  var h = t.console,
      u = t.jQuery,
      d = function d() {},
      l = 0,
      c = {};

  r.namespace = "outlayer", r.Item = o, r.defaults = {
    containerStyle: {
      position: "relative"
    },
    initLayout: !0,
    originLeft: !0,
    originTop: !0,
    resize: !0,
    resizeContainer: !0,
    transitionDuration: "0.4s",
    hiddenStyle: {
      opacity: 0,
      transform: "scale(0.001)"
    },
    visibleStyle: {
      opacity: 1,
      transform: "scale(1)"
    }
  };
  var f = r.prototype;
  n.extend(f, e.prototype), f.option = function (t) {
    n.extend(this.options, t);
  }, f._getOption = function (t) {
    var e = this.constructor.compatOptions[t];
    return e && void 0 !== this.options[e] ? this.options[e] : this.options[t];
  }, r.compatOptions = {
    initLayout: "isInitLayout",
    horizontal: "isHorizontal",
    layoutInstant: "isLayoutInstant",
    originLeft: "isOriginLeft",
    originTop: "isOriginTop",
    resize: "isResizeBound",
    resizeContainer: "isResizingContainer"
  }, f._create = function () {
    this.reloadItems(), this.stamps = [], this.stamp(this.options.stamp), n.extend(this.element.style, this.options.containerStyle);

    var t = this._getOption("resize");

    t && this.bindResize();
  }, f.reloadItems = function () {
    this.items = this._itemize(this.element.children);
  }, f._itemize = function (t) {
    for (var e = this._filterFindItemElements(t), i = this.constructor.Item, n = [], o = 0; o < e.length; o++) {
      var r = e[o],
          s = new i(r, this);
      n.push(s);
    }

    return n;
  }, f._filterFindItemElements = function (t) {
    return n.filterFindElements(t, this.options.itemSelector);
  }, f.getItemElements = function () {
    return this.items.map(function (t) {
      return t.element;
    });
  }, f.layout = function () {
    this._resetLayout(), this._manageStamps();

    var t = this._getOption("layoutInstant"),
        e = void 0 !== t ? t : !this._isLayoutInited;

    this.layoutItems(this.items, e), this._isLayoutInited = !0;
  }, f._init = f.layout, f._resetLayout = function () {
    this.getSize();
  }, f.getSize = function () {
    this.size = i(this.element);
  }, f._getMeasurement = function (t, e) {
    var n,
        o = this.options[t];
    o ? ("string" == typeof o ? n = this.element.querySelector(o) : o instanceof HTMLElement && (n = o), this[t] = n ? i(n)[e] : o) : this[t] = 0;
  }, f.layoutItems = function (t, e) {
    t = this._getItemsForLayout(t), this._layoutItems(t, e), this._postLayout();
  }, f._getItemsForLayout = function (t) {
    return t.filter(function (t) {
      return !t.isIgnored;
    });
  }, f._layoutItems = function (t, e) {
    if (this._emitCompleteOnItems("layout", t), t && t.length) {
      var i = [];
      t.forEach(function (t) {
        var n = this._getItemLayoutPosition(t);

        n.item = t, n.isInstant = e || t.isLayoutInstant, i.push(n);
      }, this), this._processLayoutQueue(i);
    }
  }, f._getItemLayoutPosition = function () {
    return {
      x: 0,
      y: 0
    };
  }, f._processLayoutQueue = function (t) {
    this.updateStagger(), t.forEach(function (t, e) {
      this._positionItem(t.item, t.x, t.y, t.isInstant, e);
    }, this);
  }, f.updateStagger = function () {
    var t = this.options.stagger;
    return null === t || void 0 === t ? void (this.stagger = 0) : (this.stagger = a(t), this.stagger);
  }, f._positionItem = function (t, e, i, n, o) {
    n ? t.goTo(e, i) : (t.stagger(o * this.stagger), t.moveTo(e, i));
  }, f._postLayout = function () {
    this.resizeContainer();
  }, f.resizeContainer = function () {
    var t = this._getOption("resizeContainer");

    if (t) {
      var e = this._getContainerSize();

      e && (this._setContainerMeasure(e.width, !0), this._setContainerMeasure(e.height, !1));
    }
  }, f._getContainerSize = d, f._setContainerMeasure = function (t, e) {
    if (void 0 !== t) {
      var i = this.size;
      i.isBorderBox && (t += e ? i.paddingLeft + i.paddingRight + i.borderLeftWidth + i.borderRightWidth : i.paddingBottom + i.paddingTop + i.borderTopWidth + i.borderBottomWidth), t = Math.max(t, 0), this.element.style[e ? "width" : "height"] = t + "px";
    }
  }, f._emitCompleteOnItems = function (t, e) {
    function i() {
      o.dispatchEvent(t + "Complete", null, [e]);
    }

    function n() {
      s++, s == r && i();
    }

    var o = this,
        r = e.length;
    if (!e || !r) return void i();
    var s = 0;
    e.forEach(function (e) {
      e.once(t, n);
    });
  }, f.dispatchEvent = function (t, e, i) {
    var n = e ? [e].concat(i) : i;
    if (this.emitEvent(t, n), u) if (this.$element = this.$element || u(this.element), e) {
      var o = u.Event(e);
      o.type = t, this.$element.trigger(o, i);
    } else this.$element.trigger(t, i);
  }, f.ignore = function (t) {
    var e = this.getItem(t);
    e && (e.isIgnored = !0);
  }, f.unignore = function (t) {
    var e = this.getItem(t);
    e && delete e.isIgnored;
  }, f.stamp = function (t) {
    t = this._find(t), t && (this.stamps = this.stamps.concat(t), t.forEach(this.ignore, this));
  }, f.unstamp = function (t) {
    t = this._find(t), t && t.forEach(function (t) {
      n.removeFrom(this.stamps, t), this.unignore(t);
    }, this);
  }, f._find = function (t) {
    return t ? ("string" == typeof t && (t = this.element.querySelectorAll(t)), t = n.makeArray(t)) : void 0;
  }, f._manageStamps = function () {
    this.stamps && this.stamps.length && (this._getBoundingRect(), this.stamps.forEach(this._manageStamp, this));
  }, f._getBoundingRect = function () {
    var t = this.element.getBoundingClientRect(),
        e = this.size;
    this._boundingRect = {
      left: t.left + e.paddingLeft + e.borderLeftWidth,
      top: t.top + e.paddingTop + e.borderTopWidth,
      right: t.right - (e.paddingRight + e.borderRightWidth),
      bottom: t.bottom - (e.paddingBottom + e.borderBottomWidth)
    };
  }, f._manageStamp = d, f._getElementOffset = function (t) {
    var e = t.getBoundingClientRect(),
        n = this._boundingRect,
        o = i(t),
        r = {
      left: e.left - n.left - o.marginLeft,
      top: e.top - n.top - o.marginTop,
      right: n.right - e.right - o.marginRight,
      bottom: n.bottom - e.bottom - o.marginBottom
    };
    return r;
  }, f.handleEvent = n.handleEvent, f.bindResize = function () {
    t.addEventListener("resize", this), this.isResizeBound = !0;
  }, f.unbindResize = function () {
    t.removeEventListener("resize", this), this.isResizeBound = !1;
  }, f.onresize = function () {
    this.resize();
  }, n.debounceMethod(r, "onresize", 100), f.resize = function () {
    this.isResizeBound && this.needsResizeLayout() && this.layout();
  }, f.needsResizeLayout = function () {
    var t = i(this.element),
        e = this.size && t;
    return e && t.innerWidth !== this.size.innerWidth;
  }, f.addItems = function (t) {
    var e = this._itemize(t);

    return e.length && (this.items = this.items.concat(e)), e;
  }, f.appended = function (t) {
    var e = this.addItems(t);
    e.length && (this.layoutItems(e, !0), this.reveal(e));
  }, f.prepended = function (t) {
    var e = this._itemize(t);

    if (e.length) {
      var i = this.items.slice(0);
      this.items = e.concat(i), this._resetLayout(), this._manageStamps(), this.layoutItems(e, !0), this.reveal(e), this.layoutItems(i);
    }
  }, f.reveal = function (t) {
    if (this._emitCompleteOnItems("reveal", t), t && t.length) {
      var e = this.updateStagger();
      t.forEach(function (t, i) {
        t.stagger(i * e), t.reveal();
      });
    }
  }, f.hide = function (t) {
    if (this._emitCompleteOnItems("hide", t), t && t.length) {
      var e = this.updateStagger();
      t.forEach(function (t, i) {
        t.stagger(i * e), t.hide();
      });
    }
  }, f.revealItemElements = function (t) {
    var e = this.getItems(t);
    this.reveal(e);
  }, f.hideItemElements = function (t) {
    var e = this.getItems(t);
    this.hide(e);
  }, f.getItem = function (t) {
    for (var e = 0; e < this.items.length; e++) {
      var i = this.items[e];
      if (i.element == t) return i;
    }
  }, f.getItems = function (t) {
    t = n.makeArray(t);
    var e = [];
    return t.forEach(function (t) {
      var i = this.getItem(t);
      i && e.push(i);
    }, this), e;
  }, f.remove = function (t) {
    var e = this.getItems(t);
    this._emitCompleteOnItems("remove", e), e && e.length && e.forEach(function (t) {
      t.remove(), n.removeFrom(this.items, t);
    }, this);
  }, f.destroy = function () {
    var t = this.element.style;
    t.height = "", t.position = "", t.width = "", this.items.forEach(function (t) {
      t.destroy();
    }), this.unbindResize();
    var e = this.element.outlayerGUID;
    delete c[e], delete this.element.outlayerGUID, u && u.removeData(this.element, this.constructor.namespace);
  }, r.data = function (t) {
    t = n.getQueryElement(t);
    var e = t && t.outlayerGUID;
    return e && c[e];
  }, r.create = function (t, e) {
    var i = s(r);
    return i.defaults = n.extend({}, r.defaults), n.extend(i.defaults, e), i.compatOptions = n.extend({}, r.compatOptions), i.namespace = t, i.data = r.data, i.Item = s(o), n.htmlInit(i, t), u && u.bridget && u.bridget(t, i), i;
  };
  var m = {
    ms: 1,
    s: 1e3
  };
  return r.Item = o, r;
}), function (t, e) {
  "function" == typeof define && define.amd ? define(["outlayer/outlayer", "get-size/get-size"], e) : "object" == (typeof module === "undefined" ? "undefined" : _typeof(module)) && module.exports ? module.exports = e(require("outlayer"), require("get-size")) : t.Masonry = e(t.Outlayer, t.getSize);
}(window, function (t, e) {
  var i = t.create("masonry");
  i.compatOptions.fitWidth = "isFitWidth";
  var n = i.prototype;
  return n._resetLayout = function () {
    this.getSize(), this._getMeasurement("columnWidth", "outerWidth"), this._getMeasurement("gutter", "outerWidth"), this.measureColumns(), this.colYs = [];

    for (var t = 0; t < this.cols; t++) {
      this.colYs.push(0);
    }

    this.maxY = 0, this.horizontalColIndex = 0;
  }, n.measureColumns = function () {
    if (this.getContainerWidth(), !this.columnWidth) {
      var t = this.items[0],
          i = t && t.element;
      this.columnWidth = i && e(i).outerWidth || this.containerWidth;
    }

    var n = this.columnWidth += this.gutter,
        o = this.containerWidth + this.gutter,
        r = o / n,
        s = n - o % n,
        a = s && 1 > s ? "round" : "floor";
    r = Math[a](r), this.cols = Math.max(r, 1);
  }, n.getContainerWidth = function () {
    var t = this._getOption("fitWidth"),
        i = t ? this.element.parentNode : this.element,
        n = e(i);

    this.containerWidth = n && n.innerWidth;
  }, n._getItemLayoutPosition = function (t) {
    t.getSize();
    var e = t.size.outerWidth % this.columnWidth,
        i = e && 1 > e ? "round" : "ceil",
        n = Math[i](t.size.outerWidth / this.columnWidth);
    n = Math.min(n, this.cols);

    for (var o = this.options.horizontalOrder ? "_getHorizontalColPosition" : "_getTopColPosition", r = this[o](n, t), s = {
      x: this.columnWidth * r.col,
      y: r.y
    }, a = r.y + t.size.outerHeight, h = n + r.col, u = r.col; h > u; u++) {
      this.colYs[u] = a;
    }

    return s;
  }, n._getTopColPosition = function (t) {
    var e = this._getTopColGroup(t),
        i = Math.min.apply(Math, e);

    return {
      col: e.indexOf(i),
      y: i
    };
  }, n._getTopColGroup = function (t) {
    if (2 > t) return this.colYs;

    for (var e = [], i = this.cols + 1 - t, n = 0; i > n; n++) {
      e[n] = this._getColGroupY(n, t);
    }

    return e;
  }, n._getColGroupY = function (t, e) {
    if (2 > e) return this.colYs[t];
    var i = this.colYs.slice(t, t + e);
    return Math.max.apply(Math, i);
  }, n._getHorizontalColPosition = function (t, e) {
    var i = this.horizontalColIndex % this.cols,
        n = t > 1 && i + t > this.cols;
    i = n ? 0 : i;
    var o = e.size.outerWidth && e.size.outerHeight;
    return this.horizontalColIndex = o ? i + t : this.horizontalColIndex, {
      col: i,
      y: this._getColGroupY(i, t)
    };
  }, n._manageStamp = function (t) {
    var i = e(t),
        n = this._getElementOffset(t),
        o = this._getOption("originLeft"),
        r = o ? n.left : n.right,
        s = r + i.outerWidth,
        a = Math.floor(r / this.columnWidth);

    a = Math.max(0, a);
    var h = Math.floor(s / this.columnWidth);
    h -= s % this.columnWidth ? 0 : 1, h = Math.min(this.cols - 1, h);

    for (var u = this._getOption("originTop"), d = (u ? n.top : n.bottom) + i.outerHeight, l = a; h >= l; l++) {
      this.colYs[l] = Math.max(d, this.colYs[l]);
    }
  }, n._getContainerSize = function () {
    this.maxY = Math.max.apply(Math, this.colYs);
    var t = {
      height: this.maxY
    };
    return this._getOption("fitWidth") && (t.width = this._getContainerFitWidth()), t;
  }, n._getContainerFitWidth = function () {
    for (var t = 0, e = this.cols; --e && 0 === this.colYs[e];) {
      t++;
    }

    return (this.cols - t) * this.columnWidth - this.gutter;
  }, n.needsResizeLayout = function () {
    var t = this.containerWidth;
    return this.getContainerWidth(), t != this.containerWidth;
  }, i;
});
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Alert", {
  enumerable: true,
  get: function get() {
    return _alert["default"];
  }
});
Object.defineProperty(exports, "Button", {
  enumerable: true,
  get: function get() {
    return _button["default"];
  }
});
Object.defineProperty(exports, "Carousel", {
  enumerable: true,
  get: function get() {
    return _carousel["default"];
  }
});
Object.defineProperty(exports, "Collapse", {
  enumerable: true,
  get: function get() {
    return _collapse["default"];
  }
});
Object.defineProperty(exports, "Dropdown", {
  enumerable: true,
  get: function get() {
    return _dropdown["default"];
  }
});
Object.defineProperty(exports, "Modal", {
  enumerable: true,
  get: function get() {
    return _modal["default"];
  }
});
Object.defineProperty(exports, "Offcanvas", {
  enumerable: true,
  get: function get() {
    return _offcanvas["default"];
  }
});
Object.defineProperty(exports, "Popover", {
  enumerable: true,
  get: function get() {
    return _popover["default"];
  }
});
Object.defineProperty(exports, "ScrollSpy", {
  enumerable: true,
  get: function get() {
    return _scrollspy["default"];
  }
});
Object.defineProperty(exports, "Tab", {
  enumerable: true,
  get: function get() {
    return _tab["default"];
  }
});
Object.defineProperty(exports, "Toast", {
  enumerable: true,
  get: function get() {
    return _toast["default"];
  }
});
Object.defineProperty(exports, "Tooltip", {
  enumerable: true,
  get: function get() {
    return _tooltip["default"];
  }
});

var _alert = _interopRequireDefault(require("./src/alert"));

var _button = _interopRequireDefault(require("./src/button"));

var _carousel = _interopRequireDefault(require("./src/carousel"));

var _collapse = _interopRequireDefault(require("./src/collapse"));

var _dropdown = _interopRequireDefault(require("./src/dropdown"));

var _modal = _interopRequireDefault(require("./src/modal"));

var _offcanvas = _interopRequireDefault(require("./src/offcanvas"));

var _popover = _interopRequireDefault(require("./src/popover"));

var _scrollspy = _interopRequireDefault(require("./src/scrollspy"));

var _tab = _interopRequireDefault(require("./src/tab"));

var _toast = _interopRequireDefault(require("./src/toast"));

var _tooltip = _interopRequireDefault(require("./src/tooltip"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _alert = _interopRequireDefault(require("./src/alert"));

var _button = _interopRequireDefault(require("./src/button"));

var _carousel = _interopRequireDefault(require("./src/carousel"));

var _collapse = _interopRequireDefault(require("./src/collapse"));

var _dropdown = _interopRequireDefault(require("./src/dropdown"));

var _modal = _interopRequireDefault(require("./src/modal"));

var _offcanvas = _interopRequireDefault(require("./src/offcanvas"));

var _popover = _interopRequireDefault(require("./src/popover"));

var _scrollspy = _interopRequireDefault(require("./src/scrollspy"));

var _tab = _interopRequireDefault(require("./src/tab"));

var _toast = _interopRequireDefault(require("./src/toast"));

var _tooltip = _interopRequireDefault(require("./src/tooltip"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/**
 * --------------------------------------------------------------------------
 * Bootstrap (v5.1.3): index.umd.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */
var _default = {
  Alert: _alert["default"],
  Button: _button["default"],
  Carousel: _carousel["default"],
  Collapse: _collapse["default"],
  Dropdown: _dropdown["default"],
  Modal: _modal["default"],
  Offcanvas: _offcanvas["default"],
  Popover: _popover["default"],
  ScrollSpy: _scrollspy["default"],
  Tab: _tab["default"],
  Toast: _toast["default"],
  Tooltip: _tooltip["default"]
};
exports["default"] = _default;
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/*!
  * Bootstrap alert.js v5.1.3 (https://getbootstrap.com/)
  * Copyright 2011-2021 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
  */
(function (global, factory) {
  (typeof exports === "undefined" ? "undefined" : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('./dom/event-handler.js'), require('./base-component.js')) : typeof define === 'function' && define.amd ? define(['./dom/event-handler', './base-component'], factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.Alert = factory(global.EventHandler, global.Base));
})(void 0, function (EventHandler, BaseComponent) {
  'use strict';

  var _interopDefaultLegacy = function _interopDefaultLegacy(e) {
    return e && _typeof(e) === 'object' && 'default' in e ? e : {
      "default": e
    };
  };

  var EventHandler__default = /*#__PURE__*/_interopDefaultLegacy(EventHandler);

  var BaseComponent__default = /*#__PURE__*/_interopDefaultLegacy(BaseComponent);
  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v5.1.3): util/index.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */


  var getSelector = function getSelector(element) {
    var selector = element.getAttribute('data-bs-target');

    if (!selector || selector === '#') {
      var hrefAttr = element.getAttribute('href'); // The only valid content that could double as a selector are IDs or classes,
      // so everything starting with `#` or `.`. If a "real" URL is used as the selector,
      // `document.querySelector` will rightfully complain it is invalid.
      // See https://github.com/twbs/bootstrap/issues/32273

      if (!hrefAttr || !hrefAttr.includes('#') && !hrefAttr.startsWith('.')) {
        return null;
      } // Just in case some CMS puts out a full URL with the anchor appended


      if (hrefAttr.includes('#') && !hrefAttr.startsWith('#')) {
        hrefAttr = "#".concat(hrefAttr.split('#')[1]);
      }

      selector = hrefAttr && hrefAttr !== '#' ? hrefAttr.trim() : null;
    }

    return selector;
  };

  var getElementFromSelector = function getElementFromSelector(element) {
    var selector = getSelector(element);
    return selector ? document.querySelector(selector) : null;
  };

  var isDisabled = function isDisabled(element) {
    if (!element || element.nodeType !== Node.ELEMENT_NODE) {
      return true;
    }

    if (element.classList.contains('disabled')) {
      return true;
    }

    if (typeof element.disabled !== 'undefined') {
      return element.disabled;
    }

    return element.hasAttribute('disabled') && element.getAttribute('disabled') !== 'false';
  };

  var getjQuery = function getjQuery() {
    var _window = window,
        jQuery = _window.jQuery;

    if (jQuery && !document.body.hasAttribute('data-bs-no-jquery')) {
      return jQuery;
    }

    return null;
  };

  var DOMContentLoadedCallbacks = [];

  var onDOMContentLoaded = function onDOMContentLoaded(callback) {
    if (document.readyState === 'loading') {
      // add listener on the first call when the document is in loading state
      if (!DOMContentLoadedCallbacks.length) {
        document.addEventListener('DOMContentLoaded', function () {
          DOMContentLoadedCallbacks.forEach(function (callback) {
            return callback();
          });
        });
      }

      DOMContentLoadedCallbacks.push(callback);
    } else {
      callback();
    }
  };

  var defineJQueryPlugin = function defineJQueryPlugin(plugin) {
    onDOMContentLoaded(function () {
      var $ = getjQuery();
      /* istanbul ignore if */

      if ($) {
        var name = plugin.NAME;
        var JQUERY_NO_CONFLICT = $.fn[name];
        $.fn[name] = plugin.jQueryInterface;
        $.fn[name].Constructor = plugin;

        $.fn[name].noConflict = function () {
          $.fn[name] = JQUERY_NO_CONFLICT;
          return plugin.jQueryInterface;
        };
      }
    });
  };
  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v5.1.3): util/component-functions.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */


  var enableDismissTrigger = function enableDismissTrigger(component) {
    var method = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'hide';
    var clickEvent = "click.dismiss".concat(component.EVENT_KEY);
    var name = component.NAME;
    EventHandler__default["default"].on(document, clickEvent, "[data-bs-dismiss=\"".concat(name, "\"]"), function (event) {
      if (['A', 'AREA'].includes(this.tagName)) {
        event.preventDefault();
      }

      if (isDisabled(this)) {
        return;
      }

      var target = getElementFromSelector(this) || this.closest(".".concat(name));
      var instance = component.getOrCreateInstance(target); // Method argument is left, for Alert and only, as it doesn't implement the 'hide' method

      instance[method]();
    });
  };
  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v5.1.3): alert.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */

  /**
   * ------------------------------------------------------------------------
   * Constants
   * ------------------------------------------------------------------------
   */


  var NAME = 'alert';
  var DATA_KEY = 'bs.alert';
  var EVENT_KEY = ".".concat(DATA_KEY);
  var EVENT_CLOSE = "close".concat(EVENT_KEY);
  var EVENT_CLOSED = "closed".concat(EVENT_KEY);
  var CLASS_NAME_FADE = 'fade';
  var CLASS_NAME_SHOW = 'show';
  /**
   * ------------------------------------------------------------------------
   * Class Definition
   * ------------------------------------------------------------------------
   */

  var Alert = /*#__PURE__*/function (_BaseComponent__defau) {
    _inherits(Alert, _BaseComponent__defau);

    var _super = _createSuper(Alert);

    function Alert() {
      _classCallCheck(this, Alert);

      return _super.apply(this, arguments);
    }

    _createClass(Alert, [{
      key: "close",
      value: // Public
      function close() {
        var _this = this;

        var closeEvent = EventHandler__default["default"].trigger(this._element, EVENT_CLOSE);

        if (closeEvent.defaultPrevented) {
          return;
        }

        this._element.classList.remove(CLASS_NAME_SHOW);

        var isAnimated = this._element.classList.contains(CLASS_NAME_FADE);

        this._queueCallback(function () {
          return _this._destroyElement();
        }, this._element, isAnimated);
      } // Private

    }, {
      key: "_destroyElement",
      value: function _destroyElement() {
        this._element.remove();

        EventHandler__default["default"].trigger(this._element, EVENT_CLOSED);
        this.dispose();
      } // Static

    }], [{
      key: "NAME",
      get: // Getters
      function get() {
        return NAME;
      }
    }, {
      key: "jQueryInterface",
      value: function jQueryInterface(config) {
        return this.each(function () {
          var data = Alert.getOrCreateInstance(this);

          if (typeof config !== 'string') {
            return;
          }

          if (data[config] === undefined || config.startsWith('_') || config === 'constructor') {
            throw new TypeError("No method named \"".concat(config, "\""));
          }

          data[config](this);
        });
      }
    }]);

    return Alert;
  }(BaseComponent__default["default"]);
  /**
   * ------------------------------------------------------------------------
   * Data Api implementation
   * ------------------------------------------------------------------------
   */


  enableDismissTrigger(Alert, 'close');
  /**
   * ------------------------------------------------------------------------
   * jQuery
   * ------------------------------------------------------------------------
   * add .Alert to jQuery only if jQuery is present
   */

  defineJQueryPlugin(Alert);
  return Alert;
});
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/*!
  * Bootstrap base-component.js v5.1.3 (https://getbootstrap.com/)
  * Copyright 2011-2021 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
  */
(function (global, factory) {
  (typeof exports === "undefined" ? "undefined" : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('./dom/data.js'), require('./dom/event-handler.js')) : typeof define === 'function' && define.amd ? define(['./dom/data', './dom/event-handler'], factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.Base = factory(global.Data, global.EventHandler));
})(void 0, function (Data, EventHandler) {
  'use strict';

  var _interopDefaultLegacy = function _interopDefaultLegacy(e) {
    return e && _typeof(e) === 'object' && 'default' in e ? e : {
      "default": e
    };
  };

  var Data__default = /*#__PURE__*/_interopDefaultLegacy(Data);

  var EventHandler__default = /*#__PURE__*/_interopDefaultLegacy(EventHandler);
  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v5.1.3): util/index.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */


  var MILLISECONDS_MULTIPLIER = 1000;
  var TRANSITION_END = 'transitionend'; // Shoutout AngusCroll (https://goo.gl/pxwQGp)

  var getTransitionDurationFromElement = function getTransitionDurationFromElement(element) {
    if (!element) {
      return 0;
    } // Get transition-duration of the element


    var _window$getComputedSt = window.getComputedStyle(element),
        transitionDuration = _window$getComputedSt.transitionDuration,
        transitionDelay = _window$getComputedSt.transitionDelay;

    var floatTransitionDuration = Number.parseFloat(transitionDuration);
    var floatTransitionDelay = Number.parseFloat(transitionDelay); // Return 0 if element or transition duration is not found

    if (!floatTransitionDuration && !floatTransitionDelay) {
      return 0;
    } // If multiple durations are defined, take the first


    transitionDuration = transitionDuration.split(',')[0];
    transitionDelay = transitionDelay.split(',')[0];
    return (Number.parseFloat(transitionDuration) + Number.parseFloat(transitionDelay)) * MILLISECONDS_MULTIPLIER;
  };

  var triggerTransitionEnd = function triggerTransitionEnd(element) {
    element.dispatchEvent(new Event(TRANSITION_END));
  };

  var isElement = function isElement(obj) {
    if (!obj || _typeof(obj) !== 'object') {
      return false;
    }

    if (typeof obj.jquery !== 'undefined') {
      obj = obj[0];
    }

    return typeof obj.nodeType !== 'undefined';
  };

  var getElement = function getElement(obj) {
    if (isElement(obj)) {
      // it's a jQuery object or a node element
      return obj.jquery ? obj[0] : obj;
    }

    if (typeof obj === 'string' && obj.length > 0) {
      return document.querySelector(obj);
    }

    return null;
  };

  var execute = function execute(callback) {
    if (typeof callback === 'function') {
      callback();
    }
  };

  var executeAfterTransition = function executeAfterTransition(callback, transitionElement) {
    var waitForTransition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

    if (!waitForTransition) {
      execute(callback);
      return;
    }

    var durationPadding = 5;
    var emulatedDuration = getTransitionDurationFromElement(transitionElement) + durationPadding;
    var called = false;

    var handler = function handler(_ref) {
      var target = _ref.target;

      if (target !== transitionElement) {
        return;
      }

      called = true;
      transitionElement.removeEventListener(TRANSITION_END, handler);
      execute(callback);
    };

    transitionElement.addEventListener(TRANSITION_END, handler);
    setTimeout(function () {
      if (!called) {
        triggerTransitionEnd(transitionElement);
      }
    }, emulatedDuration);
  };
  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v5.1.3): base-component.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */

  /**
   * ------------------------------------------------------------------------
   * Constants
   * ------------------------------------------------------------------------
   */


  var VERSION = '5.1.3';

  var BaseComponent = /*#__PURE__*/function () {
    function BaseComponent(element) {
      _classCallCheck(this, BaseComponent);

      element = getElement(element);

      if (!element) {
        return;
      }

      this._element = element;
      Data__default["default"].set(this._element, this.constructor.DATA_KEY, this);
    }

    _createClass(BaseComponent, [{
      key: "dispose",
      value: function dispose() {
        var _this = this;

        Data__default["default"].remove(this._element, this.constructor.DATA_KEY);
        EventHandler__default["default"].off(this._element, this.constructor.EVENT_KEY);
        Object.getOwnPropertyNames(this).forEach(function (propertyName) {
          _this[propertyName] = null;
        });
      }
    }, {
      key: "_queueCallback",
      value: function _queueCallback(callback, element) {
        var isAnimated = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
        executeAfterTransition(callback, element, isAnimated);
      }
      /** Static */

    }], [{
      key: "getInstance",
      value: function getInstance(element) {
        return Data__default["default"].get(getElement(element), this.DATA_KEY);
      }
    }, {
      key: "getOrCreateInstance",
      value: function getOrCreateInstance(element) {
        var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        return this.getInstance(element) || new this(element, _typeof(config) === 'object' ? config : null);
      }
    }, {
      key: "VERSION",
      get: function get() {
        return VERSION;
      }
    }, {
      key: "NAME",
      get: function get() {
        throw new Error('You have to implement the static method "NAME", for each component!');
      }
    }, {
      key: "DATA_KEY",
      get: function get() {
        return "bs.".concat(this.NAME);
      }
    }, {
      key: "EVENT_KEY",
      get: function get() {
        return ".".concat(this.DATA_KEY);
      }
    }]);

    return BaseComponent;
  }();

  return BaseComponent;
});
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/*!
  * Bootstrap button.js v5.1.3 (https://getbootstrap.com/)
  * Copyright 2011-2021 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
  */
(function (global, factory) {
  (typeof exports === "undefined" ? "undefined" : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('./dom/event-handler.js'), require('./base-component.js')) : typeof define === 'function' && define.amd ? define(['./dom/event-handler', './base-component'], factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.Button = factory(global.EventHandler, global.Base));
})(void 0, function (EventHandler, BaseComponent) {
  'use strict';

  var _interopDefaultLegacy = function _interopDefaultLegacy(e) {
    return e && _typeof(e) === 'object' && 'default' in e ? e : {
      "default": e
    };
  };

  var EventHandler__default = /*#__PURE__*/_interopDefaultLegacy(EventHandler);

  var BaseComponent__default = /*#__PURE__*/_interopDefaultLegacy(BaseComponent);
  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v5.1.3): util/index.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */


  var getjQuery = function getjQuery() {
    var _window = window,
        jQuery = _window.jQuery;

    if (jQuery && !document.body.hasAttribute('data-bs-no-jquery')) {
      return jQuery;
    }

    return null;
  };

  var DOMContentLoadedCallbacks = [];

  var onDOMContentLoaded = function onDOMContentLoaded(callback) {
    if (document.readyState === 'loading') {
      // add listener on the first call when the document is in loading state
      if (!DOMContentLoadedCallbacks.length) {
        document.addEventListener('DOMContentLoaded', function () {
          DOMContentLoadedCallbacks.forEach(function (callback) {
            return callback();
          });
        });
      }

      DOMContentLoadedCallbacks.push(callback);
    } else {
      callback();
    }
  };

  var defineJQueryPlugin = function defineJQueryPlugin(plugin) {
    onDOMContentLoaded(function () {
      var $ = getjQuery();
      /* istanbul ignore if */

      if ($) {
        var name = plugin.NAME;
        var JQUERY_NO_CONFLICT = $.fn[name];
        $.fn[name] = plugin.jQueryInterface;
        $.fn[name].Constructor = plugin;

        $.fn[name].noConflict = function () {
          $.fn[name] = JQUERY_NO_CONFLICT;
          return plugin.jQueryInterface;
        };
      }
    });
  };
  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v5.1.3): button.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */

  /**
   * ------------------------------------------------------------------------
   * Constants
   * ------------------------------------------------------------------------
   */


  var NAME = 'button';
  var DATA_KEY = 'bs.button';
  var EVENT_KEY = ".".concat(DATA_KEY);
  var DATA_API_KEY = '.data-api';
  var CLASS_NAME_ACTIVE = 'active';
  var SELECTOR_DATA_TOGGLE = '[data-bs-toggle="button"]';
  var EVENT_CLICK_DATA_API = "click".concat(EVENT_KEY).concat(DATA_API_KEY);
  /**
   * ------------------------------------------------------------------------
   * Class Definition
   * ------------------------------------------------------------------------
   */

  var Button = /*#__PURE__*/function (_BaseComponent__defau) {
    _inherits(Button, _BaseComponent__defau);

    var _super = _createSuper(Button);

    function Button() {
      _classCallCheck(this, Button);

      return _super.apply(this, arguments);
    }

    _createClass(Button, [{
      key: "toggle",
      value: // Public
      function toggle() {
        // Toggle class and sync the `aria-pressed` attribute with the return value of the `.toggle()` method
        this._element.setAttribute('aria-pressed', this._element.classList.toggle(CLASS_NAME_ACTIVE));
      } // Static

    }], [{
      key: "NAME",
      get: // Getters
      function get() {
        return NAME;
      }
    }, {
      key: "jQueryInterface",
      value: function jQueryInterface(config) {
        return this.each(function () {
          var data = Button.getOrCreateInstance(this);

          if (config === 'toggle') {
            data[config]();
          }
        });
      }
    }]);

    return Button;
  }(BaseComponent__default["default"]);
  /**
   * ------------------------------------------------------------------------
   * Data Api implementation
   * ------------------------------------------------------------------------
   */


  EventHandler__default["default"].on(document, EVENT_CLICK_DATA_API, SELECTOR_DATA_TOGGLE, function (event) {
    event.preventDefault();
    var button = event.target.closest(SELECTOR_DATA_TOGGLE);
    var data = Button.getOrCreateInstance(button);
    data.toggle();
  });
  /**
   * ------------------------------------------------------------------------
   * jQuery
   * ------------------------------------------------------------------------
   * add .Button to jQuery only if jQuery is present
   */

  defineJQueryPlugin(Button);
  return Button;
});
"use strict";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/*!
  * Bootstrap carousel.js v5.1.3 (https://getbootstrap.com/)
  * Copyright 2011-2021 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
  */
(function (global, factory) {
  (typeof exports === "undefined" ? "undefined" : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('./dom/event-handler.js'), require('./dom/manipulator.js'), require('./dom/selector-engine.js'), require('./base-component.js')) : typeof define === 'function' && define.amd ? define(['./dom/event-handler', './dom/manipulator', './dom/selector-engine', './base-component'], factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.Carousel = factory(global.EventHandler, global.Manipulator, global.SelectorEngine, global.Base));
})(void 0, function (EventHandler, Manipulator, SelectorEngine, BaseComponent) {
  'use strict';

  var _KEY_TO_DIRECTION;

  var _interopDefaultLegacy = function _interopDefaultLegacy(e) {
    return e && _typeof(e) === 'object' && 'default' in e ? e : {
      "default": e
    };
  };

  var EventHandler__default = /*#__PURE__*/_interopDefaultLegacy(EventHandler);

  var Manipulator__default = /*#__PURE__*/_interopDefaultLegacy(Manipulator);

  var SelectorEngine__default = /*#__PURE__*/_interopDefaultLegacy(SelectorEngine);

  var BaseComponent__default = /*#__PURE__*/_interopDefaultLegacy(BaseComponent);
  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v5.1.3): util/index.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */


  var TRANSITION_END = 'transitionend'; // Shoutout AngusCroll (https://goo.gl/pxwQGp)

  var toType = function toType(obj) {
    if (obj === null || obj === undefined) {
      return "".concat(obj);
    }

    return {}.toString.call(obj).match(/\s([a-z]+)/i)[1].toLowerCase();
  };

  var getSelector = function getSelector(element) {
    var selector = element.getAttribute('data-bs-target');

    if (!selector || selector === '#') {
      var hrefAttr = element.getAttribute('href'); // The only valid content that could double as a selector are IDs or classes,
      // so everything starting with `#` or `.`. If a "real" URL is used as the selector,
      // `document.querySelector` will rightfully complain it is invalid.
      // See https://github.com/twbs/bootstrap/issues/32273

      if (!hrefAttr || !hrefAttr.includes('#') && !hrefAttr.startsWith('.')) {
        return null;
      } // Just in case some CMS puts out a full URL with the anchor appended


      if (hrefAttr.includes('#') && !hrefAttr.startsWith('#')) {
        hrefAttr = "#".concat(hrefAttr.split('#')[1]);
      }

      selector = hrefAttr && hrefAttr !== '#' ? hrefAttr.trim() : null;
    }

    return selector;
  };

  var getElementFromSelector = function getElementFromSelector(element) {
    var selector = getSelector(element);
    return selector ? document.querySelector(selector) : null;
  };

  var triggerTransitionEnd = function triggerTransitionEnd(element) {
    element.dispatchEvent(new Event(TRANSITION_END));
  };

  var isElement = function isElement(obj) {
    if (!obj || _typeof(obj) !== 'object') {
      return false;
    }

    if (typeof obj.jquery !== 'undefined') {
      obj = obj[0];
    }

    return typeof obj.nodeType !== 'undefined';
  };

  var typeCheckConfig = function typeCheckConfig(componentName, config, configTypes) {
    Object.keys(configTypes).forEach(function (property) {
      var expectedTypes = configTypes[property];
      var value = config[property];
      var valueType = value && isElement(value) ? 'element' : toType(value);

      if (!new RegExp(expectedTypes).test(valueType)) {
        throw new TypeError("".concat(componentName.toUpperCase(), ": Option \"").concat(property, "\" provided type \"").concat(valueType, "\" but expected type \"").concat(expectedTypes, "\"."));
      }
    });
  };

  var isVisible = function isVisible(element) {
    if (!isElement(element) || element.getClientRects().length === 0) {
      return false;
    }

    return getComputedStyle(element).getPropertyValue('visibility') === 'visible';
  };
  /**
   * Trick to restart an element's animation
   *
   * @param {HTMLElement} element
   * @return void
   *
   * @see https://www.charistheo.io/blog/2021/02/restart-a-css-animation-with-javascript/#restarting-a-css-animation
   */


  var reflow = function reflow(element) {
    // eslint-disable-next-line no-unused-expressions
    element.offsetHeight;
  };

  var getjQuery = function getjQuery() {
    var _window = window,
        jQuery = _window.jQuery;

    if (jQuery && !document.body.hasAttribute('data-bs-no-jquery')) {
      return jQuery;
    }

    return null;
  };

  var DOMContentLoadedCallbacks = [];

  var onDOMContentLoaded = function onDOMContentLoaded(callback) {
    if (document.readyState === 'loading') {
      // add listener on the first call when the document is in loading state
      if (!DOMContentLoadedCallbacks.length) {
        document.addEventListener('DOMContentLoaded', function () {
          DOMContentLoadedCallbacks.forEach(function (callback) {
            return callback();
          });
        });
      }

      DOMContentLoadedCallbacks.push(callback);
    } else {
      callback();
    }
  };

  var isRTL = function isRTL() {
    return document.documentElement.dir === 'rtl';
  };

  var defineJQueryPlugin = function defineJQueryPlugin(plugin) {
    onDOMContentLoaded(function () {
      var $ = getjQuery();
      /* istanbul ignore if */

      if ($) {
        var name = plugin.NAME;
        var JQUERY_NO_CONFLICT = $.fn[name];
        $.fn[name] = plugin.jQueryInterface;
        $.fn[name].Constructor = plugin;

        $.fn[name].noConflict = function () {
          $.fn[name] = JQUERY_NO_CONFLICT;
          return plugin.jQueryInterface;
        };
      }
    });
  };
  /**
   * Return the previous/next element of a list.
   *
   * @param {array} list    The list of elements
   * @param activeElement   The active element
   * @param shouldGetNext   Choose to get next or previous element
   * @param isCycleAllowed
   * @return {Element|elem} The proper element
   */


  var getNextActiveElement = function getNextActiveElement(list, activeElement, shouldGetNext, isCycleAllowed) {
    var index = list.indexOf(activeElement); // if the element does not exist in the list return an element depending on the direction and if cycle is allowed

    if (index === -1) {
      return list[!shouldGetNext && isCycleAllowed ? list.length - 1 : 0];
    }

    var listLength = list.length;
    index += shouldGetNext ? 1 : -1;

    if (isCycleAllowed) {
      index = (index + listLength) % listLength;
    }

    return list[Math.max(0, Math.min(index, listLength - 1))];
  };
  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v5.1.3): carousel.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */

  /**
   * ------------------------------------------------------------------------
   * Constants
   * ------------------------------------------------------------------------
   */


  var NAME = 'carousel';
  var DATA_KEY = 'bs.carousel';
  var EVENT_KEY = ".".concat(DATA_KEY);
  var DATA_API_KEY = '.data-api';
  var ARROW_LEFT_KEY = 'ArrowLeft';
  var ARROW_RIGHT_KEY = 'ArrowRight';
  var TOUCHEVENT_COMPAT_WAIT = 500; // Time for mouse compat events to fire after touch

  var SWIPE_THRESHOLD = 40;
  var Default = {
    interval: 5000,
    keyboard: true,
    slide: false,
    pause: 'hover',
    wrap: true,
    touch: true
  };
  var DefaultType = {
    interval: '(number|boolean)',
    keyboard: 'boolean',
    slide: '(boolean|string)',
    pause: '(string|boolean)',
    wrap: 'boolean',
    touch: 'boolean'
  };
  var ORDER_NEXT = 'next';
  var ORDER_PREV = 'prev';
  var DIRECTION_LEFT = 'left';
  var DIRECTION_RIGHT = 'right';
  var KEY_TO_DIRECTION = (_KEY_TO_DIRECTION = {}, _defineProperty(_KEY_TO_DIRECTION, ARROW_LEFT_KEY, DIRECTION_RIGHT), _defineProperty(_KEY_TO_DIRECTION, ARROW_RIGHT_KEY, DIRECTION_LEFT), _KEY_TO_DIRECTION);
  var EVENT_SLIDE = "slide".concat(EVENT_KEY);
  var EVENT_SLID = "slid".concat(EVENT_KEY);
  var EVENT_KEYDOWN = "keydown".concat(EVENT_KEY);
  var EVENT_MOUSEENTER = "mouseenter".concat(EVENT_KEY);
  var EVENT_MOUSELEAVE = "mouseleave".concat(EVENT_KEY);
  var EVENT_TOUCHSTART = "touchstart".concat(EVENT_KEY);
  var EVENT_TOUCHMOVE = "touchmove".concat(EVENT_KEY);
  var EVENT_TOUCHEND = "touchend".concat(EVENT_KEY);
  var EVENT_POINTERDOWN = "pointerdown".concat(EVENT_KEY);
  var EVENT_POINTERUP = "pointerup".concat(EVENT_KEY);
  var EVENT_DRAG_START = "dragstart".concat(EVENT_KEY);
  var EVENT_LOAD_DATA_API = "load".concat(EVENT_KEY).concat(DATA_API_KEY);
  var EVENT_CLICK_DATA_API = "click".concat(EVENT_KEY).concat(DATA_API_KEY);
  var CLASS_NAME_CAROUSEL = 'carousel';
  var CLASS_NAME_ACTIVE = 'active';
  var CLASS_NAME_SLIDE = 'slide';
  var CLASS_NAME_END = 'carousel-item-end';
  var CLASS_NAME_START = 'carousel-item-start';
  var CLASS_NAME_NEXT = 'carousel-item-next';
  var CLASS_NAME_PREV = 'carousel-item-prev';
  var CLASS_NAME_POINTER_EVENT = 'pointer-event';
  var SELECTOR_ACTIVE = '.active';
  var SELECTOR_ACTIVE_ITEM = '.active.carousel-item';
  var SELECTOR_ITEM = '.carousel-item';
  var SELECTOR_ITEM_IMG = '.carousel-item img';
  var SELECTOR_NEXT_PREV = '.carousel-item-next, .carousel-item-prev';
  var SELECTOR_INDICATORS = '.carousel-indicators';
  var SELECTOR_INDICATOR = '[data-bs-target]';
  var SELECTOR_DATA_SLIDE = '[data-bs-slide], [data-bs-slide-to]';
  var SELECTOR_DATA_RIDE = '[data-bs-ride="carousel"]';
  var POINTER_TYPE_TOUCH = 'touch';
  var POINTER_TYPE_PEN = 'pen';
  /**
   * ------------------------------------------------------------------------
   * Class Definition
   * ------------------------------------------------------------------------
   */

  var Carousel = /*#__PURE__*/function (_BaseComponent__defau) {
    _inherits(Carousel, _BaseComponent__defau);

    var _super = _createSuper(Carousel);

    function Carousel(element, config) {
      var _this;

      _classCallCheck(this, Carousel);

      _this = _super.call(this, element);
      _this._items = null;
      _this._interval = null;
      _this._activeElement = null;
      _this._isPaused = false;
      _this._isSliding = false;
      _this.touchTimeout = null;
      _this.touchStartX = 0;
      _this.touchDeltaX = 0;
      _this._config = _this._getConfig(config);
      _this._indicatorsElement = SelectorEngine__default["default"].findOne(SELECTOR_INDICATORS, _this._element);
      _this._touchSupported = 'ontouchstart' in document.documentElement || navigator.maxTouchPoints > 0;
      _this._pointerEvent = Boolean(window.PointerEvent);

      _this._addEventListeners();

      return _this;
    } // Getters


    _createClass(Carousel, [{
      key: "next",
      value: // Public
      function next() {
        this._slide(ORDER_NEXT);
      }
    }, {
      key: "nextWhenVisible",
      value: function nextWhenVisible() {
        // Don't call next when the page isn't visible
        // or the carousel or its parent isn't visible
        if (!document.hidden && isVisible(this._element)) {
          this.next();
        }
      }
    }, {
      key: "prev",
      value: function prev() {
        this._slide(ORDER_PREV);
      }
    }, {
      key: "pause",
      value: function pause(event) {
        if (!event) {
          this._isPaused = true;
        }

        if (SelectorEngine__default["default"].findOne(SELECTOR_NEXT_PREV, this._element)) {
          triggerTransitionEnd(this._element);
          this.cycle(true);
        }

        clearInterval(this._interval);
        this._interval = null;
      }
    }, {
      key: "cycle",
      value: function cycle(event) {
        if (!event) {
          this._isPaused = false;
        }

        if (this._interval) {
          clearInterval(this._interval);
          this._interval = null;
        }

        if (this._config && this._config.interval && !this._isPaused) {
          this._updateInterval();

          this._interval = setInterval((document.visibilityState ? this.nextWhenVisible : this.next).bind(this), this._config.interval);
        }
      }
    }, {
      key: "to",
      value: function to(index) {
        var _this2 = this;

        this._activeElement = SelectorEngine__default["default"].findOne(SELECTOR_ACTIVE_ITEM, this._element);

        var activeIndex = this._getItemIndex(this._activeElement);

        if (index > this._items.length - 1 || index < 0) {
          return;
        }

        if (this._isSliding) {
          EventHandler__default["default"].one(this._element, EVENT_SLID, function () {
            return _this2.to(index);
          });
          return;
        }

        if (activeIndex === index) {
          this.pause();
          this.cycle();
          return;
        }

        var order = index > activeIndex ? ORDER_NEXT : ORDER_PREV;

        this._slide(order, this._items[index]);
      } // Private

    }, {
      key: "_getConfig",
      value: function _getConfig(config) {
        config = _objectSpread(_objectSpread(_objectSpread({}, Default), Manipulator__default["default"].getDataAttributes(this._element)), _typeof(config) === 'object' ? config : {});
        typeCheckConfig(NAME, config, DefaultType);
        return config;
      }
    }, {
      key: "_handleSwipe",
      value: function _handleSwipe() {
        var absDeltax = Math.abs(this.touchDeltaX);

        if (absDeltax <= SWIPE_THRESHOLD) {
          return;
        }

        var direction = absDeltax / this.touchDeltaX;
        this.touchDeltaX = 0;

        if (!direction) {
          return;
        }

        this._slide(direction > 0 ? DIRECTION_RIGHT : DIRECTION_LEFT);
      }
    }, {
      key: "_addEventListeners",
      value: function _addEventListeners() {
        var _this3 = this;

        if (this._config.keyboard) {
          EventHandler__default["default"].on(this._element, EVENT_KEYDOWN, function (event) {
            return _this3._keydown(event);
          });
        }

        if (this._config.pause === 'hover') {
          EventHandler__default["default"].on(this._element, EVENT_MOUSEENTER, function (event) {
            return _this3.pause(event);
          });
          EventHandler__default["default"].on(this._element, EVENT_MOUSELEAVE, function (event) {
            return _this3.cycle(event);
          });
        }

        if (this._config.touch && this._touchSupported) {
          this._addTouchEventListeners();
        }
      }
    }, {
      key: "_addTouchEventListeners",
      value: function _addTouchEventListeners() {
        var _this4 = this;

        var hasPointerPenTouch = function hasPointerPenTouch(event) {
          return _this4._pointerEvent && (event.pointerType === POINTER_TYPE_PEN || event.pointerType === POINTER_TYPE_TOUCH);
        };

        var start = function start(event) {
          if (hasPointerPenTouch(event)) {
            _this4.touchStartX = event.clientX;
          } else if (!_this4._pointerEvent) {
            _this4.touchStartX = event.touches[0].clientX;
          }
        };

        var move = function move(event) {
          // ensure swiping with one touch and not pinching
          _this4.touchDeltaX = event.touches && event.touches.length > 1 ? 0 : event.touches[0].clientX - _this4.touchStartX;
        };

        var end = function end(event) {
          if (hasPointerPenTouch(event)) {
            _this4.touchDeltaX = event.clientX - _this4.touchStartX;
          }

          _this4._handleSwipe();

          if (_this4._config.pause === 'hover') {
            // If it's a touch-enabled device, mouseenter/leave are fired as
            // part of the mouse compatibility events on first tap - the carousel
            // would stop cycling until user tapped out of it;
            // here, we listen for touchend, explicitly pause the carousel
            // (as if it's the second time we tap on it, mouseenter compat event
            // is NOT fired) and after a timeout (to allow for mouse compatibility
            // events to fire) we explicitly restart cycling
            _this4.pause();

            if (_this4.touchTimeout) {
              clearTimeout(_this4.touchTimeout);
            }

            _this4.touchTimeout = setTimeout(function (event) {
              return _this4.cycle(event);
            }, TOUCHEVENT_COMPAT_WAIT + _this4._config.interval);
          }
        };

        SelectorEngine__default["default"].find(SELECTOR_ITEM_IMG, this._element).forEach(function (itemImg) {
          EventHandler__default["default"].on(itemImg, EVENT_DRAG_START, function (event) {
            return event.preventDefault();
          });
        });

        if (this._pointerEvent) {
          EventHandler__default["default"].on(this._element, EVENT_POINTERDOWN, function (event) {
            return start(event);
          });
          EventHandler__default["default"].on(this._element, EVENT_POINTERUP, function (event) {
            return end(event);
          });

          this._element.classList.add(CLASS_NAME_POINTER_EVENT);
        } else {
          EventHandler__default["default"].on(this._element, EVENT_TOUCHSTART, function (event) {
            return start(event);
          });
          EventHandler__default["default"].on(this._element, EVENT_TOUCHMOVE, function (event) {
            return move(event);
          });
          EventHandler__default["default"].on(this._element, EVENT_TOUCHEND, function (event) {
            return end(event);
          });
        }
      }
    }, {
      key: "_keydown",
      value: function _keydown(event) {
        if (/input|textarea/i.test(event.target.tagName)) {
          return;
        }

        var direction = KEY_TO_DIRECTION[event.key];

        if (direction) {
          event.preventDefault();

          this._slide(direction);
        }
      }
    }, {
      key: "_getItemIndex",
      value: function _getItemIndex(element) {
        this._items = element && element.parentNode ? SelectorEngine__default["default"].find(SELECTOR_ITEM, element.parentNode) : [];
        return this._items.indexOf(element);
      }
    }, {
      key: "_getItemByOrder",
      value: function _getItemByOrder(order, activeElement) {
        var isNext = order === ORDER_NEXT;
        return getNextActiveElement(this._items, activeElement, isNext, this._config.wrap);
      }
    }, {
      key: "_triggerSlideEvent",
      value: function _triggerSlideEvent(relatedTarget, eventDirectionName) {
        var targetIndex = this._getItemIndex(relatedTarget);

        var fromIndex = this._getItemIndex(SelectorEngine__default["default"].findOne(SELECTOR_ACTIVE_ITEM, this._element));

        return EventHandler__default["default"].trigger(this._element, EVENT_SLIDE, {
          relatedTarget: relatedTarget,
          direction: eventDirectionName,
          from: fromIndex,
          to: targetIndex
        });
      }
    }, {
      key: "_setActiveIndicatorElement",
      value: function _setActiveIndicatorElement(element) {
        if (this._indicatorsElement) {
          var activeIndicator = SelectorEngine__default["default"].findOne(SELECTOR_ACTIVE, this._indicatorsElement);
          activeIndicator.classList.remove(CLASS_NAME_ACTIVE);
          activeIndicator.removeAttribute('aria-current');
          var indicators = SelectorEngine__default["default"].find(SELECTOR_INDICATOR, this._indicatorsElement);

          for (var i = 0; i < indicators.length; i++) {
            if (Number.parseInt(indicators[i].getAttribute('data-bs-slide-to'), 10) === this._getItemIndex(element)) {
              indicators[i].classList.add(CLASS_NAME_ACTIVE);
              indicators[i].setAttribute('aria-current', 'true');
              break;
            }
          }
        }
      }
    }, {
      key: "_updateInterval",
      value: function _updateInterval() {
        var element = this._activeElement || SelectorEngine__default["default"].findOne(SELECTOR_ACTIVE_ITEM, this._element);

        if (!element) {
          return;
        }

        var elementInterval = Number.parseInt(element.getAttribute('data-bs-interval'), 10);

        if (elementInterval) {
          this._config.defaultInterval = this._config.defaultInterval || this._config.interval;
          this._config.interval = elementInterval;
        } else {
          this._config.interval = this._config.defaultInterval || this._config.interval;
        }
      }
    }, {
      key: "_slide",
      value: function _slide(directionOrOrder, element) {
        var _this5 = this;

        var order = this._directionToOrder(directionOrOrder);

        var activeElement = SelectorEngine__default["default"].findOne(SELECTOR_ACTIVE_ITEM, this._element);

        var activeElementIndex = this._getItemIndex(activeElement);

        var nextElement = element || this._getItemByOrder(order, activeElement);

        var nextElementIndex = this._getItemIndex(nextElement);

        var isCycling = Boolean(this._interval);
        var isNext = order === ORDER_NEXT;
        var directionalClassName = isNext ? CLASS_NAME_START : CLASS_NAME_END;
        var orderClassName = isNext ? CLASS_NAME_NEXT : CLASS_NAME_PREV;

        var eventDirectionName = this._orderToDirection(order);

        if (nextElement && nextElement.classList.contains(CLASS_NAME_ACTIVE)) {
          this._isSliding = false;
          return;
        }

        if (this._isSliding) {
          return;
        }

        var slideEvent = this._triggerSlideEvent(nextElement, eventDirectionName);

        if (slideEvent.defaultPrevented) {
          return;
        }

        if (!activeElement || !nextElement) {
          // Some weirdness is happening, so we bail
          return;
        }

        this._isSliding = true;

        if (isCycling) {
          this.pause();
        }

        this._setActiveIndicatorElement(nextElement);

        this._activeElement = nextElement;

        var triggerSlidEvent = function triggerSlidEvent() {
          EventHandler__default["default"].trigger(_this5._element, EVENT_SLID, {
            relatedTarget: nextElement,
            direction: eventDirectionName,
            from: activeElementIndex,
            to: nextElementIndex
          });
        };

        if (this._element.classList.contains(CLASS_NAME_SLIDE)) {
          nextElement.classList.add(orderClassName);
          reflow(nextElement);
          activeElement.classList.add(directionalClassName);
          nextElement.classList.add(directionalClassName);

          var completeCallBack = function completeCallBack() {
            nextElement.classList.remove(directionalClassName, orderClassName);
            nextElement.classList.add(CLASS_NAME_ACTIVE);
            activeElement.classList.remove(CLASS_NAME_ACTIVE, orderClassName, directionalClassName);
            _this5._isSliding = false;
            setTimeout(triggerSlidEvent, 0);
          };

          this._queueCallback(completeCallBack, activeElement, true);
        } else {
          activeElement.classList.remove(CLASS_NAME_ACTIVE);
          nextElement.classList.add(CLASS_NAME_ACTIVE);
          this._isSliding = false;
          triggerSlidEvent();
        }

        if (isCycling) {
          this.cycle();
        }
      }
    }, {
      key: "_directionToOrder",
      value: function _directionToOrder(direction) {
        if (![DIRECTION_RIGHT, DIRECTION_LEFT].includes(direction)) {
          return direction;
        }

        if (isRTL()) {
          return direction === DIRECTION_LEFT ? ORDER_PREV : ORDER_NEXT;
        }

        return direction === DIRECTION_LEFT ? ORDER_NEXT : ORDER_PREV;
      }
    }, {
      key: "_orderToDirection",
      value: function _orderToDirection(order) {
        if (![ORDER_NEXT, ORDER_PREV].includes(order)) {
          return order;
        }

        if (isRTL()) {
          return order === ORDER_PREV ? DIRECTION_LEFT : DIRECTION_RIGHT;
        }

        return order === ORDER_PREV ? DIRECTION_RIGHT : DIRECTION_LEFT;
      } // Static

    }], [{
      key: "Default",
      get: function get() {
        return Default;
      }
    }, {
      key: "NAME",
      get: function get() {
        return NAME;
      }
    }, {
      key: "carouselInterface",
      value: function carouselInterface(element, config) {
        var data = Carousel.getOrCreateInstance(element, config);
        var _config = data._config;

        if (_typeof(config) === 'object') {
          _config = _objectSpread(_objectSpread({}, _config), config);
        }

        var action = typeof config === 'string' ? config : _config.slide;

        if (typeof config === 'number') {
          data.to(config);
        } else if (typeof action === 'string') {
          if (typeof data[action] === 'undefined') {
            throw new TypeError("No method named \"".concat(action, "\""));
          }

          data[action]();
        } else if (_config.interval && _config.ride) {
          data.pause();
          data.cycle();
        }
      }
    }, {
      key: "jQueryInterface",
      value: function jQueryInterface(config) {
        return this.each(function () {
          Carousel.carouselInterface(this, config);
        });
      }
    }, {
      key: "dataApiClickHandler",
      value: function dataApiClickHandler(event) {
        var target = getElementFromSelector(this);

        if (!target || !target.classList.contains(CLASS_NAME_CAROUSEL)) {
          return;
        }

        var config = _objectSpread(_objectSpread({}, Manipulator__default["default"].getDataAttributes(target)), Manipulator__default["default"].getDataAttributes(this));

        var slideIndex = this.getAttribute('data-bs-slide-to');

        if (slideIndex) {
          config.interval = false;
        }

        Carousel.carouselInterface(target, config);

        if (slideIndex) {
          Carousel.getInstance(target).to(slideIndex);
        }

        event.preventDefault();
      }
    }]);

    return Carousel;
  }(BaseComponent__default["default"]);
  /**
   * ------------------------------------------------------------------------
   * Data Api implementation
   * ------------------------------------------------------------------------
   */


  EventHandler__default["default"].on(document, EVENT_CLICK_DATA_API, SELECTOR_DATA_SLIDE, Carousel.dataApiClickHandler);
  EventHandler__default["default"].on(window, EVENT_LOAD_DATA_API, function () {
    var carousels = SelectorEngine__default["default"].find(SELECTOR_DATA_RIDE);

    for (var i = 0, len = carousels.length; i < len; i++) {
      Carousel.carouselInterface(carousels[i], Carousel.getInstance(carousels[i]));
    }
  });
  /**
   * ------------------------------------------------------------------------
   * jQuery
   * ------------------------------------------------------------------------
   * add .Carousel to jQuery only if jQuery is present
   */

  defineJQueryPlugin(Carousel);
  return Carousel;
});
"use strict";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/*!
  * Bootstrap collapse.js v5.1.3 (https://getbootstrap.com/)
  * Copyright 2011-2021 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
  */
(function (global, factory) {
  (typeof exports === "undefined" ? "undefined" : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('./dom/data.js'), require('./dom/event-handler.js'), require('./dom/manipulator.js'), require('./dom/selector-engine.js'), require('./base-component.js')) : typeof define === 'function' && define.amd ? define(['./dom/data', './dom/event-handler', './dom/manipulator', './dom/selector-engine', './base-component'], factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.Collapse = factory(global.Data, global.EventHandler, global.Manipulator, global.SelectorEngine, global.Base));
})(void 0, function (Data, EventHandler, Manipulator, SelectorEngine, BaseComponent) {
  'use strict';

  var _interopDefaultLegacy = function _interopDefaultLegacy(e) {
    return e && _typeof(e) === 'object' && 'default' in e ? e : {
      "default": e
    };
  };

  var Data__default = /*#__PURE__*/_interopDefaultLegacy(Data);

  var EventHandler__default = /*#__PURE__*/_interopDefaultLegacy(EventHandler);

  var Manipulator__default = /*#__PURE__*/_interopDefaultLegacy(Manipulator);

  var SelectorEngine__default = /*#__PURE__*/_interopDefaultLegacy(SelectorEngine);

  var BaseComponent__default = /*#__PURE__*/_interopDefaultLegacy(BaseComponent);
  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v5.1.3): util/index.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */


  var toType = function toType(obj) {
    if (obj === null || obj === undefined) {
      return "".concat(obj);
    }

    return {}.toString.call(obj).match(/\s([a-z]+)/i)[1].toLowerCase();
  };

  var getSelector = function getSelector(element) {
    var selector = element.getAttribute('data-bs-target');

    if (!selector || selector === '#') {
      var hrefAttr = element.getAttribute('href'); // The only valid content that could double as a selector are IDs or classes,
      // so everything starting with `#` or `.`. If a "real" URL is used as the selector,
      // `document.querySelector` will rightfully complain it is invalid.
      // See https://github.com/twbs/bootstrap/issues/32273

      if (!hrefAttr || !hrefAttr.includes('#') && !hrefAttr.startsWith('.')) {
        return null;
      } // Just in case some CMS puts out a full URL with the anchor appended


      if (hrefAttr.includes('#') && !hrefAttr.startsWith('#')) {
        hrefAttr = "#".concat(hrefAttr.split('#')[1]);
      }

      selector = hrefAttr && hrefAttr !== '#' ? hrefAttr.trim() : null;
    }

    return selector;
  };

  var getSelectorFromElement = function getSelectorFromElement(element) {
    var selector = getSelector(element);

    if (selector) {
      return document.querySelector(selector) ? selector : null;
    }

    return null;
  };

  var getElementFromSelector = function getElementFromSelector(element) {
    var selector = getSelector(element);
    return selector ? document.querySelector(selector) : null;
  };

  var isElement = function isElement(obj) {
    if (!obj || _typeof(obj) !== 'object') {
      return false;
    }

    if (typeof obj.jquery !== 'undefined') {
      obj = obj[0];
    }

    return typeof obj.nodeType !== 'undefined';
  };

  var getElement = function getElement(obj) {
    if (isElement(obj)) {
      // it's a jQuery object or a node element
      return obj.jquery ? obj[0] : obj;
    }

    if (typeof obj === 'string' && obj.length > 0) {
      return document.querySelector(obj);
    }

    return null;
  };

  var typeCheckConfig = function typeCheckConfig(componentName, config, configTypes) {
    Object.keys(configTypes).forEach(function (property) {
      var expectedTypes = configTypes[property];
      var value = config[property];
      var valueType = value && isElement(value) ? 'element' : toType(value);

      if (!new RegExp(expectedTypes).test(valueType)) {
        throw new TypeError("".concat(componentName.toUpperCase(), ": Option \"").concat(property, "\" provided type \"").concat(valueType, "\" but expected type \"").concat(expectedTypes, "\"."));
      }
    });
  };
  /**
   * Trick to restart an element's animation
   *
   * @param {HTMLElement} element
   * @return void
   *
   * @see https://www.charistheo.io/blog/2021/02/restart-a-css-animation-with-javascript/#restarting-a-css-animation
   */


  var reflow = function reflow(element) {
    // eslint-disable-next-line no-unused-expressions
    element.offsetHeight;
  };

  var getjQuery = function getjQuery() {
    var _window = window,
        jQuery = _window.jQuery;

    if (jQuery && !document.body.hasAttribute('data-bs-no-jquery')) {
      return jQuery;
    }

    return null;
  };

  var DOMContentLoadedCallbacks = [];

  var onDOMContentLoaded = function onDOMContentLoaded(callback) {
    if (document.readyState === 'loading') {
      // add listener on the first call when the document is in loading state
      if (!DOMContentLoadedCallbacks.length) {
        document.addEventListener('DOMContentLoaded', function () {
          DOMContentLoadedCallbacks.forEach(function (callback) {
            return callback();
          });
        });
      }

      DOMContentLoadedCallbacks.push(callback);
    } else {
      callback();
    }
  };

  var defineJQueryPlugin = function defineJQueryPlugin(plugin) {
    onDOMContentLoaded(function () {
      var $ = getjQuery();
      /* istanbul ignore if */

      if ($) {
        var name = plugin.NAME;
        var JQUERY_NO_CONFLICT = $.fn[name];
        $.fn[name] = plugin.jQueryInterface;
        $.fn[name].Constructor = plugin;

        $.fn[name].noConflict = function () {
          $.fn[name] = JQUERY_NO_CONFLICT;
          return plugin.jQueryInterface;
        };
      }
    });
  };
  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v5.1.3): collapse.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */

  /**
   * ------------------------------------------------------------------------
   * Constants
   * ------------------------------------------------------------------------
   */


  var NAME = 'collapse';
  var DATA_KEY = 'bs.collapse';
  var EVENT_KEY = ".".concat(DATA_KEY);
  var DATA_API_KEY = '.data-api';
  var Default = {
    toggle: true,
    parent: null
  };
  var DefaultType = {
    toggle: 'boolean',
    parent: '(null|element)'
  };
  var EVENT_SHOW = "show".concat(EVENT_KEY);
  var EVENT_SHOWN = "shown".concat(EVENT_KEY);
  var EVENT_HIDE = "hide".concat(EVENT_KEY);
  var EVENT_HIDDEN = "hidden".concat(EVENT_KEY);
  var EVENT_CLICK_DATA_API = "click".concat(EVENT_KEY).concat(DATA_API_KEY);
  var CLASS_NAME_SHOW = 'show';
  var CLASS_NAME_COLLAPSE = 'collapse';
  var CLASS_NAME_COLLAPSING = 'collapsing';
  var CLASS_NAME_COLLAPSED = 'collapsed';
  var CLASS_NAME_DEEPER_CHILDREN = ":scope .".concat(CLASS_NAME_COLLAPSE, " .").concat(CLASS_NAME_COLLAPSE);
  var CLASS_NAME_HORIZONTAL = 'collapse-horizontal';
  var WIDTH = 'width';
  var HEIGHT = 'height';
  var SELECTOR_ACTIVES = '.collapse.show, .collapse.collapsing';
  var SELECTOR_DATA_TOGGLE = '[data-bs-toggle="collapse"]';
  /**
   * ------------------------------------------------------------------------
   * Class Definition
   * ------------------------------------------------------------------------
   */

  var Collapse = /*#__PURE__*/function (_BaseComponent__defau) {
    _inherits(Collapse, _BaseComponent__defau);

    var _super = _createSuper(Collapse);

    function Collapse(element, config) {
      var _this;

      _classCallCheck(this, Collapse);

      _this = _super.call(this, element);
      _this._isTransitioning = false;
      _this._config = _this._getConfig(config);
      _this._triggerArray = [];
      var toggleList = SelectorEngine__default["default"].find(SELECTOR_DATA_TOGGLE);

      for (var i = 0, len = toggleList.length; i < len; i++) {
        var elem = toggleList[i];
        var selector = getSelectorFromElement(elem);
        var filterElement = SelectorEngine__default["default"].find(selector).filter(function (foundElem) {
          return foundElem === _this._element;
        });

        if (selector !== null && filterElement.length) {
          _this._selector = selector;

          _this._triggerArray.push(elem);
        }
      }

      _this._initializeChildren();

      if (!_this._config.parent) {
        _this._addAriaAndCollapsedClass(_this._triggerArray, _this._isShown());
      }

      if (_this._config.toggle) {
        _this.toggle();
      }

      return _this;
    } // Getters


    _createClass(Collapse, [{
      key: "toggle",
      value: // Public
      function toggle() {
        if (this._isShown()) {
          this.hide();
        } else {
          this.show();
        }
      }
    }, {
      key: "show",
      value: function show() {
        var _this2 = this;

        if (this._isTransitioning || this._isShown()) {
          return;
        }

        var actives = [];
        var activesData;

        if (this._config.parent) {
          var children = SelectorEngine__default["default"].find(CLASS_NAME_DEEPER_CHILDREN, this._config.parent);
          actives = SelectorEngine__default["default"].find(SELECTOR_ACTIVES, this._config.parent).filter(function (elem) {
            return !children.includes(elem);
          }); // remove children if greater depth
        }

        var container = SelectorEngine__default["default"].findOne(this._selector);

        if (actives.length) {
          var tempActiveData = actives.find(function (elem) {
            return container !== elem;
          });
          activesData = tempActiveData ? Collapse.getInstance(tempActiveData) : null;

          if (activesData && activesData._isTransitioning) {
            return;
          }
        }

        var startEvent = EventHandler__default["default"].trigger(this._element, EVENT_SHOW);

        if (startEvent.defaultPrevented) {
          return;
        }

        actives.forEach(function (elemActive) {
          if (container !== elemActive) {
            Collapse.getOrCreateInstance(elemActive, {
              toggle: false
            }).hide();
          }

          if (!activesData) {
            Data__default["default"].set(elemActive, DATA_KEY, null);
          }
        });

        var dimension = this._getDimension();

        this._element.classList.remove(CLASS_NAME_COLLAPSE);

        this._element.classList.add(CLASS_NAME_COLLAPSING);

        this._element.style[dimension] = 0;

        this._addAriaAndCollapsedClass(this._triggerArray, true);

        this._isTransitioning = true;

        var complete = function complete() {
          _this2._isTransitioning = false;

          _this2._element.classList.remove(CLASS_NAME_COLLAPSING);

          _this2._element.classList.add(CLASS_NAME_COLLAPSE, CLASS_NAME_SHOW);

          _this2._element.style[dimension] = '';
          EventHandler__default["default"].trigger(_this2._element, EVENT_SHOWN);
        };

        var capitalizedDimension = dimension[0].toUpperCase() + dimension.slice(1);
        var scrollSize = "scroll".concat(capitalizedDimension);

        this._queueCallback(complete, this._element, true);

        this._element.style[dimension] = "".concat(this._element[scrollSize], "px");
      }
    }, {
      key: "hide",
      value: function hide() {
        var _this3 = this;

        if (this._isTransitioning || !this._isShown()) {
          return;
        }

        var startEvent = EventHandler__default["default"].trigger(this._element, EVENT_HIDE);

        if (startEvent.defaultPrevented) {
          return;
        }

        var dimension = this._getDimension();

        this._element.style[dimension] = "".concat(this._element.getBoundingClientRect()[dimension], "px");
        reflow(this._element);

        this._element.classList.add(CLASS_NAME_COLLAPSING);

        this._element.classList.remove(CLASS_NAME_COLLAPSE, CLASS_NAME_SHOW);

        var triggerArrayLength = this._triggerArray.length;

        for (var i = 0; i < triggerArrayLength; i++) {
          var trigger = this._triggerArray[i];
          var elem = getElementFromSelector(trigger);

          if (elem && !this._isShown(elem)) {
            this._addAriaAndCollapsedClass([trigger], false);
          }
        }

        this._isTransitioning = true;

        var complete = function complete() {
          _this3._isTransitioning = false;

          _this3._element.classList.remove(CLASS_NAME_COLLAPSING);

          _this3._element.classList.add(CLASS_NAME_COLLAPSE);

          EventHandler__default["default"].trigger(_this3._element, EVENT_HIDDEN);
        };

        this._element.style[dimension] = '';

        this._queueCallback(complete, this._element, true);
      }
    }, {
      key: "_isShown",
      value: function _isShown() {
        var element = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._element;
        return element.classList.contains(CLASS_NAME_SHOW);
      } // Private

    }, {
      key: "_getConfig",
      value: function _getConfig(config) {
        config = _objectSpread(_objectSpread(_objectSpread({}, Default), Manipulator__default["default"].getDataAttributes(this._element)), config);
        config.toggle = Boolean(config.toggle); // Coerce string values

        config.parent = getElement(config.parent);
        typeCheckConfig(NAME, config, DefaultType);
        return config;
      }
    }, {
      key: "_getDimension",
      value: function _getDimension() {
        return this._element.classList.contains(CLASS_NAME_HORIZONTAL) ? WIDTH : HEIGHT;
      }
    }, {
      key: "_initializeChildren",
      value: function _initializeChildren() {
        var _this4 = this;

        if (!this._config.parent) {
          return;
        }

        var children = SelectorEngine__default["default"].find(CLASS_NAME_DEEPER_CHILDREN, this._config.parent);
        SelectorEngine__default["default"].find(SELECTOR_DATA_TOGGLE, this._config.parent).filter(function (elem) {
          return !children.includes(elem);
        }).forEach(function (element) {
          var selected = getElementFromSelector(element);

          if (selected) {
            _this4._addAriaAndCollapsedClass([element], _this4._isShown(selected));
          }
        });
      }
    }, {
      key: "_addAriaAndCollapsedClass",
      value: function _addAriaAndCollapsedClass(triggerArray, isOpen) {
        if (!triggerArray.length) {
          return;
        }

        triggerArray.forEach(function (elem) {
          if (isOpen) {
            elem.classList.remove(CLASS_NAME_COLLAPSED);
          } else {
            elem.classList.add(CLASS_NAME_COLLAPSED);
          }

          elem.setAttribute('aria-expanded', isOpen);
        });
      } // Static

    }], [{
      key: "Default",
      get: function get() {
        return Default;
      }
    }, {
      key: "NAME",
      get: function get() {
        return NAME;
      }
    }, {
      key: "jQueryInterface",
      value: function jQueryInterface(config) {
        return this.each(function () {
          var _config = {};

          if (typeof config === 'string' && /show|hide/.test(config)) {
            _config.toggle = false;
          }

          var data = Collapse.getOrCreateInstance(this, _config);

          if (typeof config === 'string') {
            if (typeof data[config] === 'undefined') {
              throw new TypeError("No method named \"".concat(config, "\""));
            }

            data[config]();
          }
        });
      }
    }]);

    return Collapse;
  }(BaseComponent__default["default"]);
  /**
   * ------------------------------------------------------------------------
   * Data Api implementation
   * ------------------------------------------------------------------------
   */


  EventHandler__default["default"].on(document, EVENT_CLICK_DATA_API, SELECTOR_DATA_TOGGLE, function (event) {
    // preventDefault only for <a> elements (which change the URL) not inside the collapsible element
    if (event.target.tagName === 'A' || event.delegateTarget && event.delegateTarget.tagName === 'A') {
      event.preventDefault();
    }

    var selector = getSelectorFromElement(this);
    var selectorElements = SelectorEngine__default["default"].find(selector);
    selectorElements.forEach(function (element) {
      Collapse.getOrCreateInstance(element, {
        toggle: false
      }).toggle();
    });
  });
  /**
   * ------------------------------------------------------------------------
   * jQuery
   * ------------------------------------------------------------------------
   * add .Collapse to jQuery only if jQuery is present
   */

  defineJQueryPlugin(Collapse);
  return Collapse;
});
"use strict";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/*!
  * Bootstrap dropdown.js v5.1.3 (https://getbootstrap.com/)
  * Copyright 2011-2021 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
  */
(function (global, factory) {
  (typeof exports === "undefined" ? "undefined" : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('@popperjs/core'), require('./dom/event-handler.js'), require('./dom/manipulator.js'), require('./dom/selector-engine.js'), require('./base-component.js')) : typeof define === 'function' && define.amd ? define(['@popperjs/core', './dom/event-handler', './dom/manipulator', './dom/selector-engine', './base-component'], factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.Dropdown = factory(global.Popper, global.EventHandler, global.Manipulator, global.SelectorEngine, global.Base));
})(void 0, function (Popper, EventHandler, Manipulator, SelectorEngine, BaseComponent) {
  'use strict';

  var _interopDefaultLegacy = function _interopDefaultLegacy(e) {
    return e && _typeof(e) === 'object' && 'default' in e ? e : {
      "default": e
    };
  };

  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);

    if (e) {
      var _loop = function _loop(k) {
        if (k !== 'default') {
          var d = Object.getOwnPropertyDescriptor(e, k);
          Object.defineProperty(n, k, d.get ? d : {
            enumerable: true,
            get: function get() {
              return e[k];
            }
          });
        }
      };

      for (var k in e) {
        _loop(k);
      }
    }

    n["default"] = e;
    return Object.freeze(n);
  }

  var Popper__namespace = /*#__PURE__*/_interopNamespace(Popper);

  var EventHandler__default = /*#__PURE__*/_interopDefaultLegacy(EventHandler);

  var Manipulator__default = /*#__PURE__*/_interopDefaultLegacy(Manipulator);

  var SelectorEngine__default = /*#__PURE__*/_interopDefaultLegacy(SelectorEngine);

  var BaseComponent__default = /*#__PURE__*/_interopDefaultLegacy(BaseComponent);
  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v5.1.3): util/index.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */


  var toType = function toType(obj) {
    if (obj === null || obj === undefined) {
      return "".concat(obj);
    }

    return {}.toString.call(obj).match(/\s([a-z]+)/i)[1].toLowerCase();
  };

  var getSelector = function getSelector(element) {
    var selector = element.getAttribute('data-bs-target');

    if (!selector || selector === '#') {
      var hrefAttr = element.getAttribute('href'); // The only valid content that could double as a selector are IDs or classes,
      // so everything starting with `#` or `.`. If a "real" URL is used as the selector,
      // `document.querySelector` will rightfully complain it is invalid.
      // See https://github.com/twbs/bootstrap/issues/32273

      if (!hrefAttr || !hrefAttr.includes('#') && !hrefAttr.startsWith('.')) {
        return null;
      } // Just in case some CMS puts out a full URL with the anchor appended


      if (hrefAttr.includes('#') && !hrefAttr.startsWith('#')) {
        hrefAttr = "#".concat(hrefAttr.split('#')[1]);
      }

      selector = hrefAttr && hrefAttr !== '#' ? hrefAttr.trim() : null;
    }

    return selector;
  };

  var getElementFromSelector = function getElementFromSelector(element) {
    var selector = getSelector(element);
    return selector ? document.querySelector(selector) : null;
  };

  var isElement = function isElement(obj) {
    if (!obj || _typeof(obj) !== 'object') {
      return false;
    }

    if (typeof obj.jquery !== 'undefined') {
      obj = obj[0];
    }

    return typeof obj.nodeType !== 'undefined';
  };

  var getElement = function getElement(obj) {
    if (isElement(obj)) {
      // it's a jQuery object or a node element
      return obj.jquery ? obj[0] : obj;
    }

    if (typeof obj === 'string' && obj.length > 0) {
      return document.querySelector(obj);
    }

    return null;
  };

  var typeCheckConfig = function typeCheckConfig(componentName, config, configTypes) {
    Object.keys(configTypes).forEach(function (property) {
      var expectedTypes = configTypes[property];
      var value = config[property];
      var valueType = value && isElement(value) ? 'element' : toType(value);

      if (!new RegExp(expectedTypes).test(valueType)) {
        throw new TypeError("".concat(componentName.toUpperCase(), ": Option \"").concat(property, "\" provided type \"").concat(valueType, "\" but expected type \"").concat(expectedTypes, "\"."));
      }
    });
  };

  var isVisible = function isVisible(element) {
    if (!isElement(element) || element.getClientRects().length === 0) {
      return false;
    }

    return getComputedStyle(element).getPropertyValue('visibility') === 'visible';
  };

  var isDisabled = function isDisabled(element) {
    if (!element || element.nodeType !== Node.ELEMENT_NODE) {
      return true;
    }

    if (element.classList.contains('disabled')) {
      return true;
    }

    if (typeof element.disabled !== 'undefined') {
      return element.disabled;
    }

    return element.hasAttribute('disabled') && element.getAttribute('disabled') !== 'false';
  };

  var noop = function noop() {};

  var getjQuery = function getjQuery() {
    var _window = window,
        jQuery = _window.jQuery;

    if (jQuery && !document.body.hasAttribute('data-bs-no-jquery')) {
      return jQuery;
    }

    return null;
  };

  var DOMContentLoadedCallbacks = [];

  var onDOMContentLoaded = function onDOMContentLoaded(callback) {
    if (document.readyState === 'loading') {
      // add listener on the first call when the document is in loading state
      if (!DOMContentLoadedCallbacks.length) {
        document.addEventListener('DOMContentLoaded', function () {
          DOMContentLoadedCallbacks.forEach(function (callback) {
            return callback();
          });
        });
      }

      DOMContentLoadedCallbacks.push(callback);
    } else {
      callback();
    }
  };

  var isRTL = function isRTL() {
    return document.documentElement.dir === 'rtl';
  };

  var defineJQueryPlugin = function defineJQueryPlugin(plugin) {
    onDOMContentLoaded(function () {
      var $ = getjQuery();
      /* istanbul ignore if */

      if ($) {
        var name = plugin.NAME;
        var JQUERY_NO_CONFLICT = $.fn[name];
        $.fn[name] = plugin.jQueryInterface;
        $.fn[name].Constructor = plugin;

        $.fn[name].noConflict = function () {
          $.fn[name] = JQUERY_NO_CONFLICT;
          return plugin.jQueryInterface;
        };
      }
    });
  };
  /**
   * Return the previous/next element of a list.
   *
   * @param {array} list    The list of elements
   * @param activeElement   The active element
   * @param shouldGetNext   Choose to get next or previous element
   * @param isCycleAllowed
   * @return {Element|elem} The proper element
   */


  var getNextActiveElement = function getNextActiveElement(list, activeElement, shouldGetNext, isCycleAllowed) {
    var index = list.indexOf(activeElement); // if the element does not exist in the list return an element depending on the direction and if cycle is allowed

    if (index === -1) {
      return list[!shouldGetNext && isCycleAllowed ? list.length - 1 : 0];
    }

    var listLength = list.length;
    index += shouldGetNext ? 1 : -1;

    if (isCycleAllowed) {
      index = (index + listLength) % listLength;
    }

    return list[Math.max(0, Math.min(index, listLength - 1))];
  };
  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v5.1.3): dropdown.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */

  /**
   * ------------------------------------------------------------------------
   * Constants
   * ------------------------------------------------------------------------
   */


  var NAME = 'dropdown';
  var DATA_KEY = 'bs.dropdown';
  var EVENT_KEY = ".".concat(DATA_KEY);
  var DATA_API_KEY = '.data-api';
  var ESCAPE_KEY = 'Escape';
  var SPACE_KEY = 'Space';
  var TAB_KEY = 'Tab';
  var ARROW_UP_KEY = 'ArrowUp';
  var ARROW_DOWN_KEY = 'ArrowDown';
  var RIGHT_MOUSE_BUTTON = 2; // MouseEvent.button value for the secondary button, usually the right button

  var REGEXP_KEYDOWN = new RegExp("".concat(ARROW_UP_KEY, "|").concat(ARROW_DOWN_KEY, "|").concat(ESCAPE_KEY));
  var EVENT_HIDE = "hide".concat(EVENT_KEY);
  var EVENT_HIDDEN = "hidden".concat(EVENT_KEY);
  var EVENT_SHOW = "show".concat(EVENT_KEY);
  var EVENT_SHOWN = "shown".concat(EVENT_KEY);
  var EVENT_CLICK_DATA_API = "click".concat(EVENT_KEY).concat(DATA_API_KEY);
  var EVENT_KEYDOWN_DATA_API = "keydown".concat(EVENT_KEY).concat(DATA_API_KEY);
  var EVENT_KEYUP_DATA_API = "keyup".concat(EVENT_KEY).concat(DATA_API_KEY);
  var CLASS_NAME_SHOW = 'show';
  var CLASS_NAME_DROPUP = 'dropup';
  var CLASS_NAME_DROPEND = 'dropend';
  var CLASS_NAME_DROPSTART = 'dropstart';
  var CLASS_NAME_NAVBAR = 'navbar';
  var SELECTOR_DATA_TOGGLE = '[data-bs-toggle="dropdown"]';
  var SELECTOR_MENU = '.dropdown-menu';
  var SELECTOR_NAVBAR_NAV = '.navbar-nav';
  var SELECTOR_VISIBLE_ITEMS = '.dropdown-menu .dropdown-item:not(.disabled):not(:disabled)';
  var PLACEMENT_TOP = isRTL() ? 'top-end' : 'top-start';
  var PLACEMENT_TOPEND = isRTL() ? 'top-start' : 'top-end';
  var PLACEMENT_BOTTOM = isRTL() ? 'bottom-end' : 'bottom-start';
  var PLACEMENT_BOTTOMEND = isRTL() ? 'bottom-start' : 'bottom-end';
  var PLACEMENT_RIGHT = isRTL() ? 'left-start' : 'right-start';
  var PLACEMENT_LEFT = isRTL() ? 'right-start' : 'left-start';
  var Default = {
    offset: [0, 2],
    boundary: 'clippingParents',
    reference: 'toggle',
    display: 'dynamic',
    popperConfig: null,
    autoClose: true
  };
  var DefaultType = {
    offset: '(array|string|function)',
    boundary: '(string|element)',
    reference: '(string|element|object)',
    display: 'string',
    popperConfig: '(null|object|function)',
    autoClose: '(boolean|string)'
  };
  /**
   * ------------------------------------------------------------------------
   * Class Definition
   * ------------------------------------------------------------------------
   */

  var Dropdown = /*#__PURE__*/function (_BaseComponent__defau) {
    _inherits(Dropdown, _BaseComponent__defau);

    var _super = _createSuper(Dropdown);

    function Dropdown(element, config) {
      var _this;

      _classCallCheck(this, Dropdown);

      _this = _super.call(this, element);
      _this._popper = null;
      _this._config = _this._getConfig(config);
      _this._menu = _this._getMenuElement();
      _this._inNavbar = _this._detectNavbar();
      return _this;
    } // Getters


    _createClass(Dropdown, [{
      key: "toggle",
      value: // Public
      function toggle() {
        return this._isShown() ? this.hide() : this.show();
      }
    }, {
      key: "show",
      value: function show() {
        if (isDisabled(this._element) || this._isShown(this._menu)) {
          return;
        }

        var relatedTarget = {
          relatedTarget: this._element
        };
        var showEvent = EventHandler__default["default"].trigger(this._element, EVENT_SHOW, relatedTarget);

        if (showEvent.defaultPrevented) {
          return;
        }

        var parent = Dropdown.getParentFromElement(this._element); // Totally disable Popper for Dropdowns in Navbar

        if (this._inNavbar) {
          Manipulator__default["default"].setDataAttribute(this._menu, 'popper', 'none');
        } else {
          this._createPopper(parent);
        } // If this is a touch-enabled device we add extra
        // empty mouseover listeners to the body's immediate children;
        // only needed because of broken event delegation on iOS
        // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html


        if ('ontouchstart' in document.documentElement && !parent.closest(SELECTOR_NAVBAR_NAV)) {
          var _ref;

          (_ref = []).concat.apply(_ref, _toConsumableArray(document.body.children)).forEach(function (elem) {
            return EventHandler__default["default"].on(elem, 'mouseover', noop);
          });
        }

        this._element.focus();

        this._element.setAttribute('aria-expanded', true);

        this._menu.classList.add(CLASS_NAME_SHOW);

        this._element.classList.add(CLASS_NAME_SHOW);

        EventHandler__default["default"].trigger(this._element, EVENT_SHOWN, relatedTarget);
      }
    }, {
      key: "hide",
      value: function hide() {
        if (isDisabled(this._element) || !this._isShown(this._menu)) {
          return;
        }

        var relatedTarget = {
          relatedTarget: this._element
        };

        this._completeHide(relatedTarget);
      }
    }, {
      key: "dispose",
      value: function dispose() {
        if (this._popper) {
          this._popper.destroy();
        }

        _get(_getPrototypeOf(Dropdown.prototype), "dispose", this).call(this);
      }
    }, {
      key: "update",
      value: function update() {
        this._inNavbar = this._detectNavbar();

        if (this._popper) {
          this._popper.update();
        }
      } // Private

    }, {
      key: "_completeHide",
      value: function _completeHide(relatedTarget) {
        var hideEvent = EventHandler__default["default"].trigger(this._element, EVENT_HIDE, relatedTarget);

        if (hideEvent.defaultPrevented) {
          return;
        } // If this is a touch-enabled device we remove the extra
        // empty mouseover listeners we added for iOS support


        if ('ontouchstart' in document.documentElement) {
          var _ref2;

          (_ref2 = []).concat.apply(_ref2, _toConsumableArray(document.body.children)).forEach(function (elem) {
            return EventHandler__default["default"].off(elem, 'mouseover', noop);
          });
        }

        if (this._popper) {
          this._popper.destroy();
        }

        this._menu.classList.remove(CLASS_NAME_SHOW);

        this._element.classList.remove(CLASS_NAME_SHOW);

        this._element.setAttribute('aria-expanded', 'false');

        Manipulator__default["default"].removeDataAttribute(this._menu, 'popper');
        EventHandler__default["default"].trigger(this._element, EVENT_HIDDEN, relatedTarget);
      }
    }, {
      key: "_getConfig",
      value: function _getConfig(config) {
        config = _objectSpread(_objectSpread(_objectSpread({}, this.constructor.Default), Manipulator__default["default"].getDataAttributes(this._element)), config);
        typeCheckConfig(NAME, config, this.constructor.DefaultType);

        if (_typeof(config.reference) === 'object' && !isElement(config.reference) && typeof config.reference.getBoundingClientRect !== 'function') {
          // Popper virtual elements require a getBoundingClientRect method
          throw new TypeError("".concat(NAME.toUpperCase(), ": Option \"reference\" provided type \"object\" without a required \"getBoundingClientRect\" method."));
        }

        return config;
      }
    }, {
      key: "_createPopper",
      value: function _createPopper(parent) {
        if (typeof Popper__namespace === 'undefined') {
          throw new TypeError('Bootstrap\'s dropdowns require Popper (https://popper.js.org)');
        }

        var referenceElement = this._element;

        if (this._config.reference === 'parent') {
          referenceElement = parent;
        } else if (isElement(this._config.reference)) {
          referenceElement = getElement(this._config.reference);
        } else if (_typeof(this._config.reference) === 'object') {
          referenceElement = this._config.reference;
        }

        var popperConfig = this._getPopperConfig();

        var isDisplayStatic = popperConfig.modifiers.find(function (modifier) {
          return modifier.name === 'applyStyles' && modifier.enabled === false;
        });
        this._popper = Popper__namespace.createPopper(referenceElement, this._menu, popperConfig);

        if (isDisplayStatic) {
          Manipulator__default["default"].setDataAttribute(this._menu, 'popper', 'static');
        }
      }
    }, {
      key: "_isShown",
      value: function _isShown() {
        var element = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._element;
        return element.classList.contains(CLASS_NAME_SHOW);
      }
    }, {
      key: "_getMenuElement",
      value: function _getMenuElement() {
        return SelectorEngine__default["default"].next(this._element, SELECTOR_MENU)[0];
      }
    }, {
      key: "_getPlacement",
      value: function _getPlacement() {
        var parentDropdown = this._element.parentNode;

        if (parentDropdown.classList.contains(CLASS_NAME_DROPEND)) {
          return PLACEMENT_RIGHT;
        }

        if (parentDropdown.classList.contains(CLASS_NAME_DROPSTART)) {
          return PLACEMENT_LEFT;
        } // We need to trim the value because custom properties can also include spaces


        var isEnd = getComputedStyle(this._menu).getPropertyValue('--bs-position').trim() === 'end';

        if (parentDropdown.classList.contains(CLASS_NAME_DROPUP)) {
          return isEnd ? PLACEMENT_TOPEND : PLACEMENT_TOP;
        }

        return isEnd ? PLACEMENT_BOTTOMEND : PLACEMENT_BOTTOM;
      }
    }, {
      key: "_detectNavbar",
      value: function _detectNavbar() {
        return this._element.closest(".".concat(CLASS_NAME_NAVBAR)) !== null;
      }
    }, {
      key: "_getOffset",
      value: function _getOffset() {
        var _this2 = this;

        var offset = this._config.offset;

        if (typeof offset === 'string') {
          return offset.split(',').map(function (val) {
            return Number.parseInt(val, 10);
          });
        }

        if (typeof offset === 'function') {
          return function (popperData) {
            return offset(popperData, _this2._element);
          };
        }

        return offset;
      }
    }, {
      key: "_getPopperConfig",
      value: function _getPopperConfig() {
        var defaultBsPopperConfig = {
          placement: this._getPlacement(),
          modifiers: [{
            name: 'preventOverflow',
            options: {
              boundary: this._config.boundary
            }
          }, {
            name: 'offset',
            options: {
              offset: this._getOffset()
            }
          }]
        }; // Disable Popper if we have a static display

        if (this._config.display === 'static') {
          defaultBsPopperConfig.modifiers = [{
            name: 'applyStyles',
            enabled: false
          }];
        }

        return _objectSpread(_objectSpread({}, defaultBsPopperConfig), typeof this._config.popperConfig === 'function' ? this._config.popperConfig(defaultBsPopperConfig) : this._config.popperConfig);
      }
    }, {
      key: "_selectMenuItem",
      value: function _selectMenuItem(_ref3) {
        var key = _ref3.key,
            target = _ref3.target;
        var items = SelectorEngine__default["default"].find(SELECTOR_VISIBLE_ITEMS, this._menu).filter(isVisible);

        if (!items.length) {
          return;
        } // if target isn't included in items (e.g. when expanding the dropdown)
        // allow cycling to get the last item in case key equals ARROW_UP_KEY


        getNextActiveElement(items, target, key === ARROW_DOWN_KEY, !items.includes(target)).focus();
      } // Static

    }], [{
      key: "Default",
      get: function get() {
        return Default;
      }
    }, {
      key: "DefaultType",
      get: function get() {
        return DefaultType;
      }
    }, {
      key: "NAME",
      get: function get() {
        return NAME;
      }
    }, {
      key: "jQueryInterface",
      value: function jQueryInterface(config) {
        return this.each(function () {
          var data = Dropdown.getOrCreateInstance(this, config);

          if (typeof config !== 'string') {
            return;
          }

          if (typeof data[config] === 'undefined') {
            throw new TypeError("No method named \"".concat(config, "\""));
          }

          data[config]();
        });
      }
    }, {
      key: "clearMenus",
      value: function clearMenus(event) {
        if (event && (event.button === RIGHT_MOUSE_BUTTON || event.type === 'keyup' && event.key !== TAB_KEY)) {
          return;
        }

        var toggles = SelectorEngine__default["default"].find(SELECTOR_DATA_TOGGLE);

        for (var i = 0, len = toggles.length; i < len; i++) {
          var context = Dropdown.getInstance(toggles[i]);

          if (!context || context._config.autoClose === false) {
            continue;
          }

          if (!context._isShown()) {
            continue;
          }

          var relatedTarget = {
            relatedTarget: context._element
          };

          if (event) {
            var composedPath = event.composedPath();
            var isMenuTarget = composedPath.includes(context._menu);

            if (composedPath.includes(context._element) || context._config.autoClose === 'inside' && !isMenuTarget || context._config.autoClose === 'outside' && isMenuTarget) {
              continue;
            } // Tab navigation through the dropdown menu or events from contained inputs shouldn't close the menu


            if (context._menu.contains(event.target) && (event.type === 'keyup' && event.key === TAB_KEY || /input|select|option|textarea|form/i.test(event.target.tagName))) {
              continue;
            }

            if (event.type === 'click') {
              relatedTarget.clickEvent = event;
            }
          }

          context._completeHide(relatedTarget);
        }
      }
    }, {
      key: "getParentFromElement",
      value: function getParentFromElement(element) {
        return getElementFromSelector(element) || element.parentNode;
      }
    }, {
      key: "dataApiKeydownHandler",
      value: function dataApiKeydownHandler(event) {
        // If not input/textarea:
        //  - And not a key in REGEXP_KEYDOWN => not a dropdown command
        // If input/textarea:
        //  - If space key => not a dropdown command
        //  - If key is other than escape
        //    - If key is not up or down => not a dropdown command
        //    - If trigger inside the menu => not a dropdown command
        if (/input|textarea/i.test(event.target.tagName) ? event.key === SPACE_KEY || event.key !== ESCAPE_KEY && (event.key !== ARROW_DOWN_KEY && event.key !== ARROW_UP_KEY || event.target.closest(SELECTOR_MENU)) : !REGEXP_KEYDOWN.test(event.key)) {
          return;
        }

        var isActive = this.classList.contains(CLASS_NAME_SHOW);

        if (!isActive && event.key === ESCAPE_KEY) {
          return;
        }

        event.preventDefault();
        event.stopPropagation();

        if (isDisabled(this)) {
          return;
        }

        var getToggleButton = this.matches(SELECTOR_DATA_TOGGLE) ? this : SelectorEngine__default["default"].prev(this, SELECTOR_DATA_TOGGLE)[0];
        var instance = Dropdown.getOrCreateInstance(getToggleButton);

        if (event.key === ESCAPE_KEY) {
          instance.hide();
          return;
        }

        if (event.key === ARROW_UP_KEY || event.key === ARROW_DOWN_KEY) {
          if (!isActive) {
            instance.show();
          }

          instance._selectMenuItem(event);

          return;
        }

        if (!isActive || event.key === SPACE_KEY) {
          Dropdown.clearMenus();
        }
      }
    }]);

    return Dropdown;
  }(BaseComponent__default["default"]);
  /**
   * ------------------------------------------------------------------------
   * Data Api implementation
   * ------------------------------------------------------------------------
   */


  EventHandler__default["default"].on(document, EVENT_KEYDOWN_DATA_API, SELECTOR_DATA_TOGGLE, Dropdown.dataApiKeydownHandler);
  EventHandler__default["default"].on(document, EVENT_KEYDOWN_DATA_API, SELECTOR_MENU, Dropdown.dataApiKeydownHandler);
  EventHandler__default["default"].on(document, EVENT_CLICK_DATA_API, Dropdown.clearMenus);
  EventHandler__default["default"].on(document, EVENT_KEYUP_DATA_API, Dropdown.clearMenus);
  EventHandler__default["default"].on(document, EVENT_CLICK_DATA_API, SELECTOR_DATA_TOGGLE, function (event) {
    event.preventDefault();
    Dropdown.getOrCreateInstance(this).toggle();
  });
  /**
   * ------------------------------------------------------------------------
   * jQuery
   * ------------------------------------------------------------------------
   * add .Dropdown to jQuery only if jQuery is present
   */

  defineJQueryPlugin(Dropdown);
  return Dropdown;
});
"use strict";

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/*!
  * Bootstrap modal.js v5.1.3 (https://getbootstrap.com/)
  * Copyright 2011-2021 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
  */
(function (global, factory) {
  (typeof exports === "undefined" ? "undefined" : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('./dom/event-handler.js'), require('./dom/manipulator.js'), require('./dom/selector-engine.js'), require('./base-component.js')) : typeof define === 'function' && define.amd ? define(['./dom/event-handler', './dom/manipulator', './dom/selector-engine', './base-component'], factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.Modal = factory(global.EventHandler, global.Manipulator, global.SelectorEngine, global.Base));
})(void 0, function (EventHandler, Manipulator, SelectorEngine, BaseComponent) {
  'use strict';

  var _interopDefaultLegacy = function _interopDefaultLegacy(e) {
    return e && _typeof(e) === 'object' && 'default' in e ? e : {
      "default": e
    };
  };

  var EventHandler__default = /*#__PURE__*/_interopDefaultLegacy(EventHandler);

  var Manipulator__default = /*#__PURE__*/_interopDefaultLegacy(Manipulator);

  var SelectorEngine__default = /*#__PURE__*/_interopDefaultLegacy(SelectorEngine);

  var BaseComponent__default = /*#__PURE__*/_interopDefaultLegacy(BaseComponent);
  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v5.1.3): util/index.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */


  var MILLISECONDS_MULTIPLIER = 1000;
  var TRANSITION_END = 'transitionend'; // Shoutout AngusCroll (https://goo.gl/pxwQGp)

  var toType = function toType(obj) {
    if (obj === null || obj === undefined) {
      return "".concat(obj);
    }

    return {}.toString.call(obj).match(/\s([a-z]+)/i)[1].toLowerCase();
  };

  var getSelector = function getSelector(element) {
    var selector = element.getAttribute('data-bs-target');

    if (!selector || selector === '#') {
      var hrefAttr = element.getAttribute('href'); // The only valid content that could double as a selector are IDs or classes,
      // so everything starting with `#` or `.`. If a "real" URL is used as the selector,
      // `document.querySelector` will rightfully complain it is invalid.
      // See https://github.com/twbs/bootstrap/issues/32273

      if (!hrefAttr || !hrefAttr.includes('#') && !hrefAttr.startsWith('.')) {
        return null;
      } // Just in case some CMS puts out a full URL with the anchor appended


      if (hrefAttr.includes('#') && !hrefAttr.startsWith('#')) {
        hrefAttr = "#".concat(hrefAttr.split('#')[1]);
      }

      selector = hrefAttr && hrefAttr !== '#' ? hrefAttr.trim() : null;
    }

    return selector;
  };

  var getElementFromSelector = function getElementFromSelector(element) {
    var selector = getSelector(element);
    return selector ? document.querySelector(selector) : null;
  };

  var getTransitionDurationFromElement = function getTransitionDurationFromElement(element) {
    if (!element) {
      return 0;
    } // Get transition-duration of the element


    var _window$getComputedSt = window.getComputedStyle(element),
        transitionDuration = _window$getComputedSt.transitionDuration,
        transitionDelay = _window$getComputedSt.transitionDelay;

    var floatTransitionDuration = Number.parseFloat(transitionDuration);
    var floatTransitionDelay = Number.parseFloat(transitionDelay); // Return 0 if element or transition duration is not found

    if (!floatTransitionDuration && !floatTransitionDelay) {
      return 0;
    } // If multiple durations are defined, take the first


    transitionDuration = transitionDuration.split(',')[0];
    transitionDelay = transitionDelay.split(',')[0];
    return (Number.parseFloat(transitionDuration) + Number.parseFloat(transitionDelay)) * MILLISECONDS_MULTIPLIER;
  };

  var triggerTransitionEnd = function triggerTransitionEnd(element) {
    element.dispatchEvent(new Event(TRANSITION_END));
  };

  var isElement = function isElement(obj) {
    if (!obj || _typeof(obj) !== 'object') {
      return false;
    }

    if (typeof obj.jquery !== 'undefined') {
      obj = obj[0];
    }

    return typeof obj.nodeType !== 'undefined';
  };

  var getElement = function getElement(obj) {
    if (isElement(obj)) {
      // it's a jQuery object or a node element
      return obj.jquery ? obj[0] : obj;
    }

    if (typeof obj === 'string' && obj.length > 0) {
      return document.querySelector(obj);
    }

    return null;
  };

  var typeCheckConfig = function typeCheckConfig(componentName, config, configTypes) {
    Object.keys(configTypes).forEach(function (property) {
      var expectedTypes = configTypes[property];
      var value = config[property];
      var valueType = value && isElement(value) ? 'element' : toType(value);

      if (!new RegExp(expectedTypes).test(valueType)) {
        throw new TypeError("".concat(componentName.toUpperCase(), ": Option \"").concat(property, "\" provided type \"").concat(valueType, "\" but expected type \"").concat(expectedTypes, "\"."));
      }
    });
  };

  var isVisible = function isVisible(element) {
    if (!isElement(element) || element.getClientRects().length === 0) {
      return false;
    }

    return getComputedStyle(element).getPropertyValue('visibility') === 'visible';
  };

  var isDisabled = function isDisabled(element) {
    if (!element || element.nodeType !== Node.ELEMENT_NODE) {
      return true;
    }

    if (element.classList.contains('disabled')) {
      return true;
    }

    if (typeof element.disabled !== 'undefined') {
      return element.disabled;
    }

    return element.hasAttribute('disabled') && element.getAttribute('disabled') !== 'false';
  };
  /**
   * Trick to restart an element's animation
   *
   * @param {HTMLElement} element
   * @return void
   *
   * @see https://www.charistheo.io/blog/2021/02/restart-a-css-animation-with-javascript/#restarting-a-css-animation
   */


  var reflow = function reflow(element) {
    // eslint-disable-next-line no-unused-expressions
    element.offsetHeight;
  };

  var getjQuery = function getjQuery() {
    var _window = window,
        jQuery = _window.jQuery;

    if (jQuery && !document.body.hasAttribute('data-bs-no-jquery')) {
      return jQuery;
    }

    return null;
  };

  var DOMContentLoadedCallbacks = [];

  var onDOMContentLoaded = function onDOMContentLoaded(callback) {
    if (document.readyState === 'loading') {
      // add listener on the first call when the document is in loading state
      if (!DOMContentLoadedCallbacks.length) {
        document.addEventListener('DOMContentLoaded', function () {
          DOMContentLoadedCallbacks.forEach(function (callback) {
            return callback();
          });
        });
      }

      DOMContentLoadedCallbacks.push(callback);
    } else {
      callback();
    }
  };

  var isRTL = function isRTL() {
    return document.documentElement.dir === 'rtl';
  };

  var defineJQueryPlugin = function defineJQueryPlugin(plugin) {
    onDOMContentLoaded(function () {
      var $ = getjQuery();
      /* istanbul ignore if */

      if ($) {
        var name = plugin.NAME;
        var JQUERY_NO_CONFLICT = $.fn[name];
        $.fn[name] = plugin.jQueryInterface;
        $.fn[name].Constructor = plugin;

        $.fn[name].noConflict = function () {
          $.fn[name] = JQUERY_NO_CONFLICT;
          return plugin.jQueryInterface;
        };
      }
    });
  };

  var execute = function execute(callback) {
    if (typeof callback === 'function') {
      callback();
    }
  };

  var executeAfterTransition = function executeAfterTransition(callback, transitionElement) {
    var waitForTransition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

    if (!waitForTransition) {
      execute(callback);
      return;
    }

    var durationPadding = 5;
    var emulatedDuration = getTransitionDurationFromElement(transitionElement) + durationPadding;
    var called = false;

    var handler = function handler(_ref) {
      var target = _ref.target;

      if (target !== transitionElement) {
        return;
      }

      called = true;
      transitionElement.removeEventListener(TRANSITION_END, handler);
      execute(callback);
    };

    transitionElement.addEventListener(TRANSITION_END, handler);
    setTimeout(function () {
      if (!called) {
        triggerTransitionEnd(transitionElement);
      }
    }, emulatedDuration);
  };
  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v5.1.3): util/scrollBar.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */


  var SELECTOR_FIXED_CONTENT = '.fixed-top, .fixed-bottom, .is-fixed, .sticky-top';
  var SELECTOR_STICKY_CONTENT = '.sticky-top';

  var ScrollBarHelper = /*#__PURE__*/function () {
    function ScrollBarHelper() {
      _classCallCheck(this, ScrollBarHelper);

      this._element = document.body;
    }

    _createClass(ScrollBarHelper, [{
      key: "getWidth",
      value: function getWidth() {
        // https://developer.mozilla.org/en-US/docs/Web/API/Window/innerWidth#usage_notes
        var documentWidth = document.documentElement.clientWidth;
        return Math.abs(window.innerWidth - documentWidth);
      }
    }, {
      key: "hide",
      value: function hide() {
        var width = this.getWidth();

        this._disableOverFlow(); // give padding to element to balance the hidden scrollbar width


        this._setElementAttributes(this._element, 'paddingRight', function (calculatedValue) {
          return calculatedValue + width;
        }); // trick: We adjust positive paddingRight and negative marginRight to sticky-top elements to keep showing fullwidth


        this._setElementAttributes(SELECTOR_FIXED_CONTENT, 'paddingRight', function (calculatedValue) {
          return calculatedValue + width;
        });

        this._setElementAttributes(SELECTOR_STICKY_CONTENT, 'marginRight', function (calculatedValue) {
          return calculatedValue - width;
        });
      }
    }, {
      key: "_disableOverFlow",
      value: function _disableOverFlow() {
        this._saveInitialAttribute(this._element, 'overflow');

        this._element.style.overflow = 'hidden';
      }
    }, {
      key: "_setElementAttributes",
      value: function _setElementAttributes(selector, styleProp, callback) {
        var _this = this;

        var scrollbarWidth = this.getWidth();

        var manipulationCallBack = function manipulationCallBack(element) {
          if (element !== _this._element && window.innerWidth > element.clientWidth + scrollbarWidth) {
            return;
          }

          _this._saveInitialAttribute(element, styleProp);

          var calculatedValue = window.getComputedStyle(element)[styleProp];
          element.style[styleProp] = "".concat(callback(Number.parseFloat(calculatedValue)), "px");
        };

        this._applyManipulationCallback(selector, manipulationCallBack);
      }
    }, {
      key: "reset",
      value: function reset() {
        this._resetElementAttributes(this._element, 'overflow');

        this._resetElementAttributes(this._element, 'paddingRight');

        this._resetElementAttributes(SELECTOR_FIXED_CONTENT, 'paddingRight');

        this._resetElementAttributes(SELECTOR_STICKY_CONTENT, 'marginRight');
      }
    }, {
      key: "_saveInitialAttribute",
      value: function _saveInitialAttribute(element, styleProp) {
        var actualValue = element.style[styleProp];

        if (actualValue) {
          Manipulator__default["default"].setDataAttribute(element, styleProp, actualValue);
        }
      }
    }, {
      key: "_resetElementAttributes",
      value: function _resetElementAttributes(selector, styleProp) {
        var manipulationCallBack = function manipulationCallBack(element) {
          var value = Manipulator__default["default"].getDataAttribute(element, styleProp);

          if (typeof value === 'undefined') {
            element.style.removeProperty(styleProp);
          } else {
            Manipulator__default["default"].removeDataAttribute(element, styleProp);
            element.style[styleProp] = value;
          }
        };

        this._applyManipulationCallback(selector, manipulationCallBack);
      }
    }, {
      key: "_applyManipulationCallback",
      value: function _applyManipulationCallback(selector, callBack) {
        if (isElement(selector)) {
          callBack(selector);
        } else {
          SelectorEngine__default["default"].find(selector, this._element).forEach(callBack);
        }
      }
    }, {
      key: "isOverflowing",
      value: function isOverflowing() {
        return this.getWidth() > 0;
      }
    }]);

    return ScrollBarHelper;
  }();
  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v5.1.3): util/backdrop.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */


  var Default$2 = {
    className: 'modal-backdrop',
    isVisible: true,
    // if false, we use the backdrop helper without adding any element to the dom
    isAnimated: false,
    rootElement: 'body',
    // give the choice to place backdrop under different elements
    clickCallback: null
  };
  var DefaultType$2 = {
    className: 'string',
    isVisible: 'boolean',
    isAnimated: 'boolean',
    rootElement: '(element|string)',
    clickCallback: '(function|null)'
  };
  var NAME$2 = 'backdrop';
  var CLASS_NAME_FADE$1 = 'fade';
  var CLASS_NAME_SHOW$1 = 'show';
  var EVENT_MOUSEDOWN = "mousedown.bs.".concat(NAME$2);

  var Backdrop = /*#__PURE__*/function () {
    function Backdrop(config) {
      _classCallCheck(this, Backdrop);

      this._config = this._getConfig(config);
      this._isAppended = false;
      this._element = null;
    }

    _createClass(Backdrop, [{
      key: "show",
      value: function show(callback) {
        if (!this._config.isVisible) {
          execute(callback);
          return;
        }

        this._append();

        if (this._config.isAnimated) {
          reflow(this._getElement());
        }

        this._getElement().classList.add(CLASS_NAME_SHOW$1);

        this._emulateAnimation(function () {
          execute(callback);
        });
      }
    }, {
      key: "hide",
      value: function hide(callback) {
        var _this2 = this;

        if (!this._config.isVisible) {
          execute(callback);
          return;
        }

        this._getElement().classList.remove(CLASS_NAME_SHOW$1);

        this._emulateAnimation(function () {
          _this2.dispose();

          execute(callback);
        });
      } // Private

    }, {
      key: "_getElement",
      value: function _getElement() {
        if (!this._element) {
          var backdrop = document.createElement('div');
          backdrop.className = this._config.className;

          if (this._config.isAnimated) {
            backdrop.classList.add(CLASS_NAME_FADE$1);
          }

          this._element = backdrop;
        }

        return this._element;
      }
    }, {
      key: "_getConfig",
      value: function _getConfig(config) {
        config = _objectSpread(_objectSpread({}, Default$2), _typeof(config) === 'object' ? config : {}); // use getElement() with the default "body" to get a fresh Element on each instantiation

        config.rootElement = getElement(config.rootElement);
        typeCheckConfig(NAME$2, config, DefaultType$2);
        return config;
      }
    }, {
      key: "_append",
      value: function _append() {
        var _this3 = this;

        if (this._isAppended) {
          return;
        }

        this._config.rootElement.append(this._getElement());

        EventHandler__default["default"].on(this._getElement(), EVENT_MOUSEDOWN, function () {
          execute(_this3._config.clickCallback);
        });
        this._isAppended = true;
      }
    }, {
      key: "dispose",
      value: function dispose() {
        if (!this._isAppended) {
          return;
        }

        EventHandler__default["default"].off(this._element, EVENT_MOUSEDOWN);

        this._element.remove();

        this._isAppended = false;
      }
    }, {
      key: "_emulateAnimation",
      value: function _emulateAnimation(callback) {
        executeAfterTransition(callback, this._getElement(), this._config.isAnimated);
      }
    }]);

    return Backdrop;
  }();
  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v5.1.3): util/focustrap.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */


  var Default$1 = {
    trapElement: null,
    // The element to trap focus inside of
    autofocus: true
  };
  var DefaultType$1 = {
    trapElement: 'element',
    autofocus: 'boolean'
  };
  var NAME$1 = 'focustrap';
  var DATA_KEY$1 = 'bs.focustrap';
  var EVENT_KEY$1 = ".".concat(DATA_KEY$1);
  var EVENT_FOCUSIN = "focusin".concat(EVENT_KEY$1);
  var EVENT_KEYDOWN_TAB = "keydown.tab".concat(EVENT_KEY$1);
  var TAB_KEY = 'Tab';
  var TAB_NAV_FORWARD = 'forward';
  var TAB_NAV_BACKWARD = 'backward';

  var FocusTrap = /*#__PURE__*/function () {
    function FocusTrap(config) {
      _classCallCheck(this, FocusTrap);

      this._config = this._getConfig(config);
      this._isActive = false;
      this._lastTabNavDirection = null;
    }

    _createClass(FocusTrap, [{
      key: "activate",
      value: function activate() {
        var _this4 = this;

        var _this$_config = this._config,
            trapElement = _this$_config.trapElement,
            autofocus = _this$_config.autofocus;

        if (this._isActive) {
          return;
        }

        if (autofocus) {
          trapElement.focus();
        }

        EventHandler__default["default"].off(document, EVENT_KEY$1); // guard against infinite focus loop

        EventHandler__default["default"].on(document, EVENT_FOCUSIN, function (event) {
          return _this4._handleFocusin(event);
        });
        EventHandler__default["default"].on(document, EVENT_KEYDOWN_TAB, function (event) {
          return _this4._handleKeydown(event);
        });
        this._isActive = true;
      }
    }, {
      key: "deactivate",
      value: function deactivate() {
        if (!this._isActive) {
          return;
        }

        this._isActive = false;
        EventHandler__default["default"].off(document, EVENT_KEY$1);
      } // Private

    }, {
      key: "_handleFocusin",
      value: function _handleFocusin(event) {
        var target = event.target;
        var trapElement = this._config.trapElement;

        if (target === document || target === trapElement || trapElement.contains(target)) {
          return;
        }

        var elements = SelectorEngine__default["default"].focusableChildren(trapElement);

        if (elements.length === 0) {
          trapElement.focus();
        } else if (this._lastTabNavDirection === TAB_NAV_BACKWARD) {
          elements[elements.length - 1].focus();
        } else {
          elements[0].focus();
        }
      }
    }, {
      key: "_handleKeydown",
      value: function _handleKeydown(event) {
        if (event.key !== TAB_KEY) {
          return;
        }

        this._lastTabNavDirection = event.shiftKey ? TAB_NAV_BACKWARD : TAB_NAV_FORWARD;
      }
    }, {
      key: "_getConfig",
      value: function _getConfig(config) {
        config = _objectSpread(_objectSpread({}, Default$1), _typeof(config) === 'object' ? config : {});
        typeCheckConfig(NAME$1, config, DefaultType$1);
        return config;
      }
    }]);

    return FocusTrap;
  }();
  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v5.1.3): util/component-functions.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */


  var enableDismissTrigger = function enableDismissTrigger(component) {
    var method = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'hide';
    var clickEvent = "click.dismiss".concat(component.EVENT_KEY);
    var name = component.NAME;
    EventHandler__default["default"].on(document, clickEvent, "[data-bs-dismiss=\"".concat(name, "\"]"), function (event) {
      if (['A', 'AREA'].includes(this.tagName)) {
        event.preventDefault();
      }

      if (isDisabled(this)) {
        return;
      }

      var target = getElementFromSelector(this) || this.closest(".".concat(name));
      var instance = component.getOrCreateInstance(target); // Method argument is left, for Alert and only, as it doesn't implement the 'hide' method

      instance[method]();
    });
  };
  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v5.1.3): modal.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */

  /**
   * ------------------------------------------------------------------------
   * Constants
   * ------------------------------------------------------------------------
   */


  var NAME = 'modal';
  var DATA_KEY = 'bs.modal';
  var EVENT_KEY = ".".concat(DATA_KEY);
  var DATA_API_KEY = '.data-api';
  var ESCAPE_KEY = 'Escape';
  var Default = {
    backdrop: true,
    keyboard: true,
    focus: true
  };
  var DefaultType = {
    backdrop: '(boolean|string)',
    keyboard: 'boolean',
    focus: 'boolean'
  };
  var EVENT_HIDE = "hide".concat(EVENT_KEY);
  var EVENT_HIDE_PREVENTED = "hidePrevented".concat(EVENT_KEY);
  var EVENT_HIDDEN = "hidden".concat(EVENT_KEY);
  var EVENT_SHOW = "show".concat(EVENT_KEY);
  var EVENT_SHOWN = "shown".concat(EVENT_KEY);
  var EVENT_RESIZE = "resize".concat(EVENT_KEY);
  var EVENT_CLICK_DISMISS = "click.dismiss".concat(EVENT_KEY);
  var EVENT_KEYDOWN_DISMISS = "keydown.dismiss".concat(EVENT_KEY);
  var EVENT_MOUSEUP_DISMISS = "mouseup.dismiss".concat(EVENT_KEY);
  var EVENT_MOUSEDOWN_DISMISS = "mousedown.dismiss".concat(EVENT_KEY);
  var EVENT_CLICK_DATA_API = "click".concat(EVENT_KEY).concat(DATA_API_KEY);
  var CLASS_NAME_OPEN = 'modal-open';
  var CLASS_NAME_FADE = 'fade';
  var CLASS_NAME_SHOW = 'show';
  var CLASS_NAME_STATIC = 'modal-static';
  var OPEN_SELECTOR = '.modal.show';
  var SELECTOR_DIALOG = '.modal-dialog';
  var SELECTOR_MODAL_BODY = '.modal-body';
  var SELECTOR_DATA_TOGGLE = '[data-bs-toggle="modal"]';
  /**
   * ------------------------------------------------------------------------
   * Class Definition
   * ------------------------------------------------------------------------
   */

  var Modal = /*#__PURE__*/function (_BaseComponent__defau) {
    _inherits(Modal, _BaseComponent__defau);

    var _super = _createSuper(Modal);

    function Modal(element, config) {
      var _this5;

      _classCallCheck(this, Modal);

      _this5 = _super.call(this, element);
      _this5._config = _this5._getConfig(config);
      _this5._dialog = SelectorEngine__default["default"].findOne(SELECTOR_DIALOG, _this5._element);
      _this5._backdrop = _this5._initializeBackDrop();
      _this5._focustrap = _this5._initializeFocusTrap();
      _this5._isShown = false;
      _this5._ignoreBackdropClick = false;
      _this5._isTransitioning = false;
      _this5._scrollBar = new ScrollBarHelper();
      return _this5;
    } // Getters


    _createClass(Modal, [{
      key: "toggle",
      value: // Public
      function toggle(relatedTarget) {
        return this._isShown ? this.hide() : this.show(relatedTarget);
      }
    }, {
      key: "show",
      value: function show(relatedTarget) {
        var _this6 = this;

        if (this._isShown || this._isTransitioning) {
          return;
        }

        var showEvent = EventHandler__default["default"].trigger(this._element, EVENT_SHOW, {
          relatedTarget: relatedTarget
        });

        if (showEvent.defaultPrevented) {
          return;
        }

        this._isShown = true;

        if (this._isAnimated()) {
          this._isTransitioning = true;
        }

        this._scrollBar.hide();

        document.body.classList.add(CLASS_NAME_OPEN);

        this._adjustDialog();

        this._setEscapeEvent();

        this._setResizeEvent();

        EventHandler__default["default"].on(this._dialog, EVENT_MOUSEDOWN_DISMISS, function () {
          EventHandler__default["default"].one(_this6._element, EVENT_MOUSEUP_DISMISS, function (event) {
            if (event.target === _this6._element) {
              _this6._ignoreBackdropClick = true;
            }
          });
        });

        this._showBackdrop(function () {
          return _this6._showElement(relatedTarget);
        });
      }
    }, {
      key: "hide",
      value: function hide() {
        var _this7 = this;

        if (!this._isShown || this._isTransitioning) {
          return;
        }

        var hideEvent = EventHandler__default["default"].trigger(this._element, EVENT_HIDE);

        if (hideEvent.defaultPrevented) {
          return;
        }

        this._isShown = false;

        var isAnimated = this._isAnimated();

        if (isAnimated) {
          this._isTransitioning = true;
        }

        this._setEscapeEvent();

        this._setResizeEvent();

        this._focustrap.deactivate();

        this._element.classList.remove(CLASS_NAME_SHOW);

        EventHandler__default["default"].off(this._element, EVENT_CLICK_DISMISS);
        EventHandler__default["default"].off(this._dialog, EVENT_MOUSEDOWN_DISMISS);

        this._queueCallback(function () {
          return _this7._hideModal();
        }, this._element, isAnimated);
      }
    }, {
      key: "dispose",
      value: function dispose() {
        [window, this._dialog].forEach(function (htmlElement) {
          return EventHandler__default["default"].off(htmlElement, EVENT_KEY);
        });

        this._backdrop.dispose();

        this._focustrap.deactivate();

        _get(_getPrototypeOf(Modal.prototype), "dispose", this).call(this);
      }
    }, {
      key: "handleUpdate",
      value: function handleUpdate() {
        this._adjustDialog();
      } // Private

    }, {
      key: "_initializeBackDrop",
      value: function _initializeBackDrop() {
        return new Backdrop({
          isVisible: Boolean(this._config.backdrop),
          // 'static' option will be translated to true, and booleans will keep their value
          isAnimated: this._isAnimated()
        });
      }
    }, {
      key: "_initializeFocusTrap",
      value: function _initializeFocusTrap() {
        return new FocusTrap({
          trapElement: this._element
        });
      }
    }, {
      key: "_getConfig",
      value: function _getConfig(config) {
        config = _objectSpread(_objectSpread(_objectSpread({}, Default), Manipulator__default["default"].getDataAttributes(this._element)), _typeof(config) === 'object' ? config : {});
        typeCheckConfig(NAME, config, DefaultType);
        return config;
      }
    }, {
      key: "_showElement",
      value: function _showElement(relatedTarget) {
        var _this8 = this;

        var isAnimated = this._isAnimated();

        var modalBody = SelectorEngine__default["default"].findOne(SELECTOR_MODAL_BODY, this._dialog);

        if (!this._element.parentNode || this._element.parentNode.nodeType !== Node.ELEMENT_NODE) {
          // Don't move modal's DOM position
          document.body.append(this._element);
        }

        this._element.style.display = 'block';

        this._element.removeAttribute('aria-hidden');

        this._element.setAttribute('aria-modal', true);

        this._element.setAttribute('role', 'dialog');

        this._element.scrollTop = 0;

        if (modalBody) {
          modalBody.scrollTop = 0;
        }

        if (isAnimated) {
          reflow(this._element);
        }

        this._element.classList.add(CLASS_NAME_SHOW);

        var transitionComplete = function transitionComplete() {
          if (_this8._config.focus) {
            _this8._focustrap.activate();
          }

          _this8._isTransitioning = false;
          EventHandler__default["default"].trigger(_this8._element, EVENT_SHOWN, {
            relatedTarget: relatedTarget
          });
        };

        this._queueCallback(transitionComplete, this._dialog, isAnimated);
      }
    }, {
      key: "_setEscapeEvent",
      value: function _setEscapeEvent() {
        var _this9 = this;

        if (this._isShown) {
          EventHandler__default["default"].on(this._element, EVENT_KEYDOWN_DISMISS, function (event) {
            if (_this9._config.keyboard && event.key === ESCAPE_KEY) {
              event.preventDefault();

              _this9.hide();
            } else if (!_this9._config.keyboard && event.key === ESCAPE_KEY) {
              _this9._triggerBackdropTransition();
            }
          });
        } else {
          EventHandler__default["default"].off(this._element, EVENT_KEYDOWN_DISMISS);
        }
      }
    }, {
      key: "_setResizeEvent",
      value: function _setResizeEvent() {
        var _this10 = this;

        if (this._isShown) {
          EventHandler__default["default"].on(window, EVENT_RESIZE, function () {
            return _this10._adjustDialog();
          });
        } else {
          EventHandler__default["default"].off(window, EVENT_RESIZE);
        }
      }
    }, {
      key: "_hideModal",
      value: function _hideModal() {
        var _this11 = this;

        this._element.style.display = 'none';

        this._element.setAttribute('aria-hidden', true);

        this._element.removeAttribute('aria-modal');

        this._element.removeAttribute('role');

        this._isTransitioning = false;

        this._backdrop.hide(function () {
          document.body.classList.remove(CLASS_NAME_OPEN);

          _this11._resetAdjustments();

          _this11._scrollBar.reset();

          EventHandler__default["default"].trigger(_this11._element, EVENT_HIDDEN);
        });
      }
    }, {
      key: "_showBackdrop",
      value: function _showBackdrop(callback) {
        var _this12 = this;

        EventHandler__default["default"].on(this._element, EVENT_CLICK_DISMISS, function (event) {
          if (_this12._ignoreBackdropClick) {
            _this12._ignoreBackdropClick = false;
            return;
          }

          if (event.target !== event.currentTarget) {
            return;
          }

          if (_this12._config.backdrop === true) {
            _this12.hide();
          } else if (_this12._config.backdrop === 'static') {
            _this12._triggerBackdropTransition();
          }
        });

        this._backdrop.show(callback);
      }
    }, {
      key: "_isAnimated",
      value: function _isAnimated() {
        return this._element.classList.contains(CLASS_NAME_FADE);
      }
    }, {
      key: "_triggerBackdropTransition",
      value: function _triggerBackdropTransition() {
        var _this13 = this;

        var hideEvent = EventHandler__default["default"].trigger(this._element, EVENT_HIDE_PREVENTED);

        if (hideEvent.defaultPrevented) {
          return;
        }

        var _this$_element = this._element,
            classList = _this$_element.classList,
            scrollHeight = _this$_element.scrollHeight,
            style = _this$_element.style;
        var isModalOverflowing = scrollHeight > document.documentElement.clientHeight; // return if the following background transition hasn't yet completed

        if (!isModalOverflowing && style.overflowY === 'hidden' || classList.contains(CLASS_NAME_STATIC)) {
          return;
        }

        if (!isModalOverflowing) {
          style.overflowY = 'hidden';
        }

        classList.add(CLASS_NAME_STATIC);

        this._queueCallback(function () {
          classList.remove(CLASS_NAME_STATIC);

          if (!isModalOverflowing) {
            _this13._queueCallback(function () {
              style.overflowY = '';
            }, _this13._dialog);
          }
        }, this._dialog);

        this._element.focus();
      } // ----------------------------------------------------------------------
      // the following methods are used to handle overflowing modals
      // ----------------------------------------------------------------------

    }, {
      key: "_adjustDialog",
      value: function _adjustDialog() {
        var isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;

        var scrollbarWidth = this._scrollBar.getWidth();

        var isBodyOverflowing = scrollbarWidth > 0;

        if (!isBodyOverflowing && isModalOverflowing && !isRTL() || isBodyOverflowing && !isModalOverflowing && isRTL()) {
          this._element.style.paddingLeft = "".concat(scrollbarWidth, "px");
        }

        if (isBodyOverflowing && !isModalOverflowing && !isRTL() || !isBodyOverflowing && isModalOverflowing && isRTL()) {
          this._element.style.paddingRight = "".concat(scrollbarWidth, "px");
        }
      }
    }, {
      key: "_resetAdjustments",
      value: function _resetAdjustments() {
        this._element.style.paddingLeft = '';
        this._element.style.paddingRight = '';
      } // Static

    }], [{
      key: "Default",
      get: function get() {
        return Default;
      }
    }, {
      key: "NAME",
      get: function get() {
        return NAME;
      }
    }, {
      key: "jQueryInterface",
      value: function jQueryInterface(config, relatedTarget) {
        return this.each(function () {
          var data = Modal.getOrCreateInstance(this, config);

          if (typeof config !== 'string') {
            return;
          }

          if (typeof data[config] === 'undefined') {
            throw new TypeError("No method named \"".concat(config, "\""));
          }

          data[config](relatedTarget);
        });
      }
    }]);

    return Modal;
  }(BaseComponent__default["default"]);
  /**
   * ------------------------------------------------------------------------
   * Data Api implementation
   * ------------------------------------------------------------------------
   */


  EventHandler__default["default"].on(document, EVENT_CLICK_DATA_API, SELECTOR_DATA_TOGGLE, function (event) {
    var _this14 = this;

    var target = getElementFromSelector(this);

    if (['A', 'AREA'].includes(this.tagName)) {
      event.preventDefault();
    }

    EventHandler__default["default"].one(target, EVENT_SHOW, function (showEvent) {
      if (showEvent.defaultPrevented) {
        // only register focus restorer if modal will actually get shown
        return;
      }

      EventHandler__default["default"].one(target, EVENT_HIDDEN, function () {
        if (isVisible(_this14)) {
          _this14.focus();
        }
      });
    }); // avoid conflict when clicking moddal toggler while another one is open

    var allReadyOpen = SelectorEngine__default["default"].findOne(OPEN_SELECTOR);

    if (allReadyOpen) {
      Modal.getInstance(allReadyOpen).hide();
    }

    var data = Modal.getOrCreateInstance(target);
    data.toggle(this);
  });
  enableDismissTrigger(Modal);
  /**
   * ------------------------------------------------------------------------
   * jQuery
   * ------------------------------------------------------------------------
   * add .Modal to jQuery only if jQuery is present
   */

  defineJQueryPlugin(Modal);
  return Modal;
});
"use strict";

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/*!
  * Bootstrap offcanvas.js v5.1.3 (https://getbootstrap.com/)
  * Copyright 2011-2021 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
  */
(function (global, factory) {
  (typeof exports === "undefined" ? "undefined" : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('./dom/selector-engine.js'), require('./dom/manipulator.js'), require('./dom/event-handler.js'), require('./base-component.js')) : typeof define === 'function' && define.amd ? define(['./dom/selector-engine', './dom/manipulator', './dom/event-handler', './base-component'], factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.Offcanvas = factory(global.SelectorEngine, global.Manipulator, global.EventHandler, global.Base));
})(void 0, function (SelectorEngine, Manipulator, EventHandler, BaseComponent) {
  'use strict';

  var _interopDefaultLegacy = function _interopDefaultLegacy(e) {
    return e && _typeof(e) === 'object' && 'default' in e ? e : {
      "default": e
    };
  };

  var SelectorEngine__default = /*#__PURE__*/_interopDefaultLegacy(SelectorEngine);

  var Manipulator__default = /*#__PURE__*/_interopDefaultLegacy(Manipulator);

  var EventHandler__default = /*#__PURE__*/_interopDefaultLegacy(EventHandler);

  var BaseComponent__default = /*#__PURE__*/_interopDefaultLegacy(BaseComponent);
  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v5.1.3): util/index.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */


  var MILLISECONDS_MULTIPLIER = 1000;
  var TRANSITION_END = 'transitionend'; // Shoutout AngusCroll (https://goo.gl/pxwQGp)

  var toType = function toType(obj) {
    if (obj === null || obj === undefined) {
      return "".concat(obj);
    }

    return {}.toString.call(obj).match(/\s([a-z]+)/i)[1].toLowerCase();
  };

  var getSelector = function getSelector(element) {
    var selector = element.getAttribute('data-bs-target');

    if (!selector || selector === '#') {
      var hrefAttr = element.getAttribute('href'); // The only valid content that could double as a selector are IDs or classes,
      // so everything starting with `#` or `.`. If a "real" URL is used as the selector,
      // `document.querySelector` will rightfully complain it is invalid.
      // See https://github.com/twbs/bootstrap/issues/32273

      if (!hrefAttr || !hrefAttr.includes('#') && !hrefAttr.startsWith('.')) {
        return null;
      } // Just in case some CMS puts out a full URL with the anchor appended


      if (hrefAttr.includes('#') && !hrefAttr.startsWith('#')) {
        hrefAttr = "#".concat(hrefAttr.split('#')[1]);
      }

      selector = hrefAttr && hrefAttr !== '#' ? hrefAttr.trim() : null;
    }

    return selector;
  };

  var getElementFromSelector = function getElementFromSelector(element) {
    var selector = getSelector(element);
    return selector ? document.querySelector(selector) : null;
  };

  var getTransitionDurationFromElement = function getTransitionDurationFromElement(element) {
    if (!element) {
      return 0;
    } // Get transition-duration of the element


    var _window$getComputedSt = window.getComputedStyle(element),
        transitionDuration = _window$getComputedSt.transitionDuration,
        transitionDelay = _window$getComputedSt.transitionDelay;

    var floatTransitionDuration = Number.parseFloat(transitionDuration);
    var floatTransitionDelay = Number.parseFloat(transitionDelay); // Return 0 if element or transition duration is not found

    if (!floatTransitionDuration && !floatTransitionDelay) {
      return 0;
    } // If multiple durations are defined, take the first


    transitionDuration = transitionDuration.split(',')[0];
    transitionDelay = transitionDelay.split(',')[0];
    return (Number.parseFloat(transitionDuration) + Number.parseFloat(transitionDelay)) * MILLISECONDS_MULTIPLIER;
  };

  var triggerTransitionEnd = function triggerTransitionEnd(element) {
    element.dispatchEvent(new Event(TRANSITION_END));
  };

  var isElement = function isElement(obj) {
    if (!obj || _typeof(obj) !== 'object') {
      return false;
    }

    if (typeof obj.jquery !== 'undefined') {
      obj = obj[0];
    }

    return typeof obj.nodeType !== 'undefined';
  };

  var getElement = function getElement(obj) {
    if (isElement(obj)) {
      // it's a jQuery object or a node element
      return obj.jquery ? obj[0] : obj;
    }

    if (typeof obj === 'string' && obj.length > 0) {
      return document.querySelector(obj);
    }

    return null;
  };

  var typeCheckConfig = function typeCheckConfig(componentName, config, configTypes) {
    Object.keys(configTypes).forEach(function (property) {
      var expectedTypes = configTypes[property];
      var value = config[property];
      var valueType = value && isElement(value) ? 'element' : toType(value);

      if (!new RegExp(expectedTypes).test(valueType)) {
        throw new TypeError("".concat(componentName.toUpperCase(), ": Option \"").concat(property, "\" provided type \"").concat(valueType, "\" but expected type \"").concat(expectedTypes, "\"."));
      }
    });
  };

  var isVisible = function isVisible(element) {
    if (!isElement(element) || element.getClientRects().length === 0) {
      return false;
    }

    return getComputedStyle(element).getPropertyValue('visibility') === 'visible';
  };

  var isDisabled = function isDisabled(element) {
    if (!element || element.nodeType !== Node.ELEMENT_NODE) {
      return true;
    }

    if (element.classList.contains('disabled')) {
      return true;
    }

    if (typeof element.disabled !== 'undefined') {
      return element.disabled;
    }

    return element.hasAttribute('disabled') && element.getAttribute('disabled') !== 'false';
  };
  /**
   * Trick to restart an element's animation
   *
   * @param {HTMLElement} element
   * @return void
   *
   * @see https://www.charistheo.io/blog/2021/02/restart-a-css-animation-with-javascript/#restarting-a-css-animation
   */


  var reflow = function reflow(element) {
    // eslint-disable-next-line no-unused-expressions
    element.offsetHeight;
  };

  var getjQuery = function getjQuery() {
    var _window = window,
        jQuery = _window.jQuery;

    if (jQuery && !document.body.hasAttribute('data-bs-no-jquery')) {
      return jQuery;
    }

    return null;
  };

  var DOMContentLoadedCallbacks = [];

  var onDOMContentLoaded = function onDOMContentLoaded(callback) {
    if (document.readyState === 'loading') {
      // add listener on the first call when the document is in loading state
      if (!DOMContentLoadedCallbacks.length) {
        document.addEventListener('DOMContentLoaded', function () {
          DOMContentLoadedCallbacks.forEach(function (callback) {
            return callback();
          });
        });
      }

      DOMContentLoadedCallbacks.push(callback);
    } else {
      callback();
    }
  };

  var defineJQueryPlugin = function defineJQueryPlugin(plugin) {
    onDOMContentLoaded(function () {
      var $ = getjQuery();
      /* istanbul ignore if */

      if ($) {
        var name = plugin.NAME;
        var JQUERY_NO_CONFLICT = $.fn[name];
        $.fn[name] = plugin.jQueryInterface;
        $.fn[name].Constructor = plugin;

        $.fn[name].noConflict = function () {
          $.fn[name] = JQUERY_NO_CONFLICT;
          return plugin.jQueryInterface;
        };
      }
    });
  };

  var execute = function execute(callback) {
    if (typeof callback === 'function') {
      callback();
    }
  };

  var executeAfterTransition = function executeAfterTransition(callback, transitionElement) {
    var waitForTransition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

    if (!waitForTransition) {
      execute(callback);
      return;
    }

    var durationPadding = 5;
    var emulatedDuration = getTransitionDurationFromElement(transitionElement) + durationPadding;
    var called = false;

    var handler = function handler(_ref) {
      var target = _ref.target;

      if (target !== transitionElement) {
        return;
      }

      called = true;
      transitionElement.removeEventListener(TRANSITION_END, handler);
      execute(callback);
    };

    transitionElement.addEventListener(TRANSITION_END, handler);
    setTimeout(function () {
      if (!called) {
        triggerTransitionEnd(transitionElement);
      }
    }, emulatedDuration);
  };
  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v5.1.3): util/scrollBar.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */


  var SELECTOR_FIXED_CONTENT = '.fixed-top, .fixed-bottom, .is-fixed, .sticky-top';
  var SELECTOR_STICKY_CONTENT = '.sticky-top';

  var ScrollBarHelper = /*#__PURE__*/function () {
    function ScrollBarHelper() {
      _classCallCheck(this, ScrollBarHelper);

      this._element = document.body;
    }

    _createClass(ScrollBarHelper, [{
      key: "getWidth",
      value: function getWidth() {
        // https://developer.mozilla.org/en-US/docs/Web/API/Window/innerWidth#usage_notes
        var documentWidth = document.documentElement.clientWidth;
        return Math.abs(window.innerWidth - documentWidth);
      }
    }, {
      key: "hide",
      value: function hide() {
        var width = this.getWidth();

        this._disableOverFlow(); // give padding to element to balance the hidden scrollbar width


        this._setElementAttributes(this._element, 'paddingRight', function (calculatedValue) {
          return calculatedValue + width;
        }); // trick: We adjust positive paddingRight and negative marginRight to sticky-top elements to keep showing fullwidth


        this._setElementAttributes(SELECTOR_FIXED_CONTENT, 'paddingRight', function (calculatedValue) {
          return calculatedValue + width;
        });

        this._setElementAttributes(SELECTOR_STICKY_CONTENT, 'marginRight', function (calculatedValue) {
          return calculatedValue - width;
        });
      }
    }, {
      key: "_disableOverFlow",
      value: function _disableOverFlow() {
        this._saveInitialAttribute(this._element, 'overflow');

        this._element.style.overflow = 'hidden';
      }
    }, {
      key: "_setElementAttributes",
      value: function _setElementAttributes(selector, styleProp, callback) {
        var _this = this;

        var scrollbarWidth = this.getWidth();

        var manipulationCallBack = function manipulationCallBack(element) {
          if (element !== _this._element && window.innerWidth > element.clientWidth + scrollbarWidth) {
            return;
          }

          _this._saveInitialAttribute(element, styleProp);

          var calculatedValue = window.getComputedStyle(element)[styleProp];
          element.style[styleProp] = "".concat(callback(Number.parseFloat(calculatedValue)), "px");
        };

        this._applyManipulationCallback(selector, manipulationCallBack);
      }
    }, {
      key: "reset",
      value: function reset() {
        this._resetElementAttributes(this._element, 'overflow');

        this._resetElementAttributes(this._element, 'paddingRight');

        this._resetElementAttributes(SELECTOR_FIXED_CONTENT, 'paddingRight');

        this._resetElementAttributes(SELECTOR_STICKY_CONTENT, 'marginRight');
      }
    }, {
      key: "_saveInitialAttribute",
      value: function _saveInitialAttribute(element, styleProp) {
        var actualValue = element.style[styleProp];

        if (actualValue) {
          Manipulator__default["default"].setDataAttribute(element, styleProp, actualValue);
        }
      }
    }, {
      key: "_resetElementAttributes",
      value: function _resetElementAttributes(selector, styleProp) {
        var manipulationCallBack = function manipulationCallBack(element) {
          var value = Manipulator__default["default"].getDataAttribute(element, styleProp);

          if (typeof value === 'undefined') {
            element.style.removeProperty(styleProp);
          } else {
            Manipulator__default["default"].removeDataAttribute(element, styleProp);
            element.style[styleProp] = value;
          }
        };

        this._applyManipulationCallback(selector, manipulationCallBack);
      }
    }, {
      key: "_applyManipulationCallback",
      value: function _applyManipulationCallback(selector, callBack) {
        if (isElement(selector)) {
          callBack(selector);
        } else {
          SelectorEngine__default["default"].find(selector, this._element).forEach(callBack);
        }
      }
    }, {
      key: "isOverflowing",
      value: function isOverflowing() {
        return this.getWidth() > 0;
      }
    }]);

    return ScrollBarHelper;
  }();
  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v5.1.3): util/backdrop.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */


  var Default$2 = {
    className: 'modal-backdrop',
    isVisible: true,
    // if false, we use the backdrop helper without adding any element to the dom
    isAnimated: false,
    rootElement: 'body',
    // give the choice to place backdrop under different elements
    clickCallback: null
  };
  var DefaultType$2 = {
    className: 'string',
    isVisible: 'boolean',
    isAnimated: 'boolean',
    rootElement: '(element|string)',
    clickCallback: '(function|null)'
  };
  var NAME$2 = 'backdrop';
  var CLASS_NAME_FADE = 'fade';
  var CLASS_NAME_SHOW$1 = 'show';
  var EVENT_MOUSEDOWN = "mousedown.bs.".concat(NAME$2);

  var Backdrop = /*#__PURE__*/function () {
    function Backdrop(config) {
      _classCallCheck(this, Backdrop);

      this._config = this._getConfig(config);
      this._isAppended = false;
      this._element = null;
    }

    _createClass(Backdrop, [{
      key: "show",
      value: function show(callback) {
        if (!this._config.isVisible) {
          execute(callback);
          return;
        }

        this._append();

        if (this._config.isAnimated) {
          reflow(this._getElement());
        }

        this._getElement().classList.add(CLASS_NAME_SHOW$1);

        this._emulateAnimation(function () {
          execute(callback);
        });
      }
    }, {
      key: "hide",
      value: function hide(callback) {
        var _this2 = this;

        if (!this._config.isVisible) {
          execute(callback);
          return;
        }

        this._getElement().classList.remove(CLASS_NAME_SHOW$1);

        this._emulateAnimation(function () {
          _this2.dispose();

          execute(callback);
        });
      } // Private

    }, {
      key: "_getElement",
      value: function _getElement() {
        if (!this._element) {
          var backdrop = document.createElement('div');
          backdrop.className = this._config.className;

          if (this._config.isAnimated) {
            backdrop.classList.add(CLASS_NAME_FADE);
          }

          this._element = backdrop;
        }

        return this._element;
      }
    }, {
      key: "_getConfig",
      value: function _getConfig(config) {
        config = _objectSpread(_objectSpread({}, Default$2), _typeof(config) === 'object' ? config : {}); // use getElement() with the default "body" to get a fresh Element on each instantiation

        config.rootElement = getElement(config.rootElement);
        typeCheckConfig(NAME$2, config, DefaultType$2);
        return config;
      }
    }, {
      key: "_append",
      value: function _append() {
        var _this3 = this;

        if (this._isAppended) {
          return;
        }

        this._config.rootElement.append(this._getElement());

        EventHandler__default["default"].on(this._getElement(), EVENT_MOUSEDOWN, function () {
          execute(_this3._config.clickCallback);
        });
        this._isAppended = true;
      }
    }, {
      key: "dispose",
      value: function dispose() {
        if (!this._isAppended) {
          return;
        }

        EventHandler__default["default"].off(this._element, EVENT_MOUSEDOWN);

        this._element.remove();

        this._isAppended = false;
      }
    }, {
      key: "_emulateAnimation",
      value: function _emulateAnimation(callback) {
        executeAfterTransition(callback, this._getElement(), this._config.isAnimated);
      }
    }]);

    return Backdrop;
  }();
  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v5.1.3): util/focustrap.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */


  var Default$1 = {
    trapElement: null,
    // The element to trap focus inside of
    autofocus: true
  };
  var DefaultType$1 = {
    trapElement: 'element',
    autofocus: 'boolean'
  };
  var NAME$1 = 'focustrap';
  var DATA_KEY$1 = 'bs.focustrap';
  var EVENT_KEY$1 = ".".concat(DATA_KEY$1);
  var EVENT_FOCUSIN = "focusin".concat(EVENT_KEY$1);
  var EVENT_KEYDOWN_TAB = "keydown.tab".concat(EVENT_KEY$1);
  var TAB_KEY = 'Tab';
  var TAB_NAV_FORWARD = 'forward';
  var TAB_NAV_BACKWARD = 'backward';

  var FocusTrap = /*#__PURE__*/function () {
    function FocusTrap(config) {
      _classCallCheck(this, FocusTrap);

      this._config = this._getConfig(config);
      this._isActive = false;
      this._lastTabNavDirection = null;
    }

    _createClass(FocusTrap, [{
      key: "activate",
      value: function activate() {
        var _this4 = this;

        var _this$_config = this._config,
            trapElement = _this$_config.trapElement,
            autofocus = _this$_config.autofocus;

        if (this._isActive) {
          return;
        }

        if (autofocus) {
          trapElement.focus();
        }

        EventHandler__default["default"].off(document, EVENT_KEY$1); // guard against infinite focus loop

        EventHandler__default["default"].on(document, EVENT_FOCUSIN, function (event) {
          return _this4._handleFocusin(event);
        });
        EventHandler__default["default"].on(document, EVENT_KEYDOWN_TAB, function (event) {
          return _this4._handleKeydown(event);
        });
        this._isActive = true;
      }
    }, {
      key: "deactivate",
      value: function deactivate() {
        if (!this._isActive) {
          return;
        }

        this._isActive = false;
        EventHandler__default["default"].off(document, EVENT_KEY$1);
      } // Private

    }, {
      key: "_handleFocusin",
      value: function _handleFocusin(event) {
        var target = event.target;
        var trapElement = this._config.trapElement;

        if (target === document || target === trapElement || trapElement.contains(target)) {
          return;
        }

        var elements = SelectorEngine__default["default"].focusableChildren(trapElement);

        if (elements.length === 0) {
          trapElement.focus();
        } else if (this._lastTabNavDirection === TAB_NAV_BACKWARD) {
          elements[elements.length - 1].focus();
        } else {
          elements[0].focus();
        }
      }
    }, {
      key: "_handleKeydown",
      value: function _handleKeydown(event) {
        if (event.key !== TAB_KEY) {
          return;
        }

        this._lastTabNavDirection = event.shiftKey ? TAB_NAV_BACKWARD : TAB_NAV_FORWARD;
      }
    }, {
      key: "_getConfig",
      value: function _getConfig(config) {
        config = _objectSpread(_objectSpread({}, Default$1), _typeof(config) === 'object' ? config : {});
        typeCheckConfig(NAME$1, config, DefaultType$1);
        return config;
      }
    }]);

    return FocusTrap;
  }();
  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v5.1.3): util/component-functions.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */


  var enableDismissTrigger = function enableDismissTrigger(component) {
    var method = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'hide';
    var clickEvent = "click.dismiss".concat(component.EVENT_KEY);
    var name = component.NAME;
    EventHandler__default["default"].on(document, clickEvent, "[data-bs-dismiss=\"".concat(name, "\"]"), function (event) {
      if (['A', 'AREA'].includes(this.tagName)) {
        event.preventDefault();
      }

      if (isDisabled(this)) {
        return;
      }

      var target = getElementFromSelector(this) || this.closest(".".concat(name));
      var instance = component.getOrCreateInstance(target); // Method argument is left, for Alert and only, as it doesn't implement the 'hide' method

      instance[method]();
    });
  };
  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v5.1.3): offcanvas.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */

  /**
   * ------------------------------------------------------------------------
   * Constants
   * ------------------------------------------------------------------------
   */


  var NAME = 'offcanvas';
  var DATA_KEY = 'bs.offcanvas';
  var EVENT_KEY = ".".concat(DATA_KEY);
  var DATA_API_KEY = '.data-api';
  var EVENT_LOAD_DATA_API = "load".concat(EVENT_KEY).concat(DATA_API_KEY);
  var ESCAPE_KEY = 'Escape';
  var Default = {
    backdrop: true,
    keyboard: true,
    scroll: false
  };
  var DefaultType = {
    backdrop: 'boolean',
    keyboard: 'boolean',
    scroll: 'boolean'
  };
  var CLASS_NAME_SHOW = 'show';
  var CLASS_NAME_BACKDROP = 'offcanvas-backdrop';
  var OPEN_SELECTOR = '.offcanvas.show';
  var EVENT_SHOW = "show".concat(EVENT_KEY);
  var EVENT_SHOWN = "shown".concat(EVENT_KEY);
  var EVENT_HIDE = "hide".concat(EVENT_KEY);
  var EVENT_HIDDEN = "hidden".concat(EVENT_KEY);
  var EVENT_CLICK_DATA_API = "click".concat(EVENT_KEY).concat(DATA_API_KEY);
  var EVENT_KEYDOWN_DISMISS = "keydown.dismiss".concat(EVENT_KEY);
  var SELECTOR_DATA_TOGGLE = '[data-bs-toggle="offcanvas"]';
  /**
   * ------------------------------------------------------------------------
   * Class Definition
   * ------------------------------------------------------------------------
   */

  var Offcanvas = /*#__PURE__*/function (_BaseComponent__defau) {
    _inherits(Offcanvas, _BaseComponent__defau);

    var _super = _createSuper(Offcanvas);

    function Offcanvas(element, config) {
      var _this5;

      _classCallCheck(this, Offcanvas);

      _this5 = _super.call(this, element);
      _this5._config = _this5._getConfig(config);
      _this5._isShown = false;
      _this5._backdrop = _this5._initializeBackDrop();
      _this5._focustrap = _this5._initializeFocusTrap();

      _this5._addEventListeners();

      return _this5;
    } // Getters


    _createClass(Offcanvas, [{
      key: "toggle",
      value: // Public
      function toggle(relatedTarget) {
        return this._isShown ? this.hide() : this.show(relatedTarget);
      }
    }, {
      key: "show",
      value: function show(relatedTarget) {
        var _this6 = this;

        if (this._isShown) {
          return;
        }

        var showEvent = EventHandler__default["default"].trigger(this._element, EVENT_SHOW, {
          relatedTarget: relatedTarget
        });

        if (showEvent.defaultPrevented) {
          return;
        }

        this._isShown = true;
        this._element.style.visibility = 'visible';

        this._backdrop.show();

        if (!this._config.scroll) {
          new ScrollBarHelper().hide();
        }

        this._element.removeAttribute('aria-hidden');

        this._element.setAttribute('aria-modal', true);

        this._element.setAttribute('role', 'dialog');

        this._element.classList.add(CLASS_NAME_SHOW);

        var completeCallBack = function completeCallBack() {
          if (!_this6._config.scroll) {
            _this6._focustrap.activate();
          }

          EventHandler__default["default"].trigger(_this6._element, EVENT_SHOWN, {
            relatedTarget: relatedTarget
          });
        };

        this._queueCallback(completeCallBack, this._element, true);
      }
    }, {
      key: "hide",
      value: function hide() {
        var _this7 = this;

        if (!this._isShown) {
          return;
        }

        var hideEvent = EventHandler__default["default"].trigger(this._element, EVENT_HIDE);

        if (hideEvent.defaultPrevented) {
          return;
        }

        this._focustrap.deactivate();

        this._element.blur();

        this._isShown = false;

        this._element.classList.remove(CLASS_NAME_SHOW);

        this._backdrop.hide();

        var completeCallback = function completeCallback() {
          _this7._element.setAttribute('aria-hidden', true);

          _this7._element.removeAttribute('aria-modal');

          _this7._element.removeAttribute('role');

          _this7._element.style.visibility = 'hidden';

          if (!_this7._config.scroll) {
            new ScrollBarHelper().reset();
          }

          EventHandler__default["default"].trigger(_this7._element, EVENT_HIDDEN);
        };

        this._queueCallback(completeCallback, this._element, true);
      }
    }, {
      key: "dispose",
      value: function dispose() {
        this._backdrop.dispose();

        this._focustrap.deactivate();

        _get(_getPrototypeOf(Offcanvas.prototype), "dispose", this).call(this);
      } // Private

    }, {
      key: "_getConfig",
      value: function _getConfig(config) {
        config = _objectSpread(_objectSpread(_objectSpread({}, Default), Manipulator__default["default"].getDataAttributes(this._element)), _typeof(config) === 'object' ? config : {});
        typeCheckConfig(NAME, config, DefaultType);
        return config;
      }
    }, {
      key: "_initializeBackDrop",
      value: function _initializeBackDrop() {
        var _this8 = this;

        return new Backdrop({
          className: CLASS_NAME_BACKDROP,
          isVisible: this._config.backdrop,
          isAnimated: true,
          rootElement: this._element.parentNode,
          clickCallback: function clickCallback() {
            return _this8.hide();
          }
        });
      }
    }, {
      key: "_initializeFocusTrap",
      value: function _initializeFocusTrap() {
        return new FocusTrap({
          trapElement: this._element
        });
      }
    }, {
      key: "_addEventListeners",
      value: function _addEventListeners() {
        var _this9 = this;

        EventHandler__default["default"].on(this._element, EVENT_KEYDOWN_DISMISS, function (event) {
          if (_this9._config.keyboard && event.key === ESCAPE_KEY) {
            _this9.hide();
          }
        });
      } // Static

    }], [{
      key: "NAME",
      get: function get() {
        return NAME;
      }
    }, {
      key: "Default",
      get: function get() {
        return Default;
      }
    }, {
      key: "jQueryInterface",
      value: function jQueryInterface(config) {
        return this.each(function () {
          var data = Offcanvas.getOrCreateInstance(this, config);

          if (typeof config !== 'string') {
            return;
          }

          if (data[config] === undefined || config.startsWith('_') || config === 'constructor') {
            throw new TypeError("No method named \"".concat(config, "\""));
          }

          data[config](this);
        });
      }
    }]);

    return Offcanvas;
  }(BaseComponent__default["default"]);
  /**
   * ------------------------------------------------------------------------
   * Data Api implementation
   * ------------------------------------------------------------------------
   */


  EventHandler__default["default"].on(document, EVENT_CLICK_DATA_API, SELECTOR_DATA_TOGGLE, function (event) {
    var _this10 = this;

    var target = getElementFromSelector(this);

    if (['A', 'AREA'].includes(this.tagName)) {
      event.preventDefault();
    }

    if (isDisabled(this)) {
      return;
    }

    EventHandler__default["default"].one(target, EVENT_HIDDEN, function () {
      // focus on trigger when it is closed
      if (isVisible(_this10)) {
        _this10.focus();
      }
    }); // avoid conflict when clicking a toggler of an offcanvas, while another is open

    var allReadyOpen = SelectorEngine__default["default"].findOne(OPEN_SELECTOR);

    if (allReadyOpen && allReadyOpen !== target) {
      Offcanvas.getInstance(allReadyOpen).hide();
    }

    var data = Offcanvas.getOrCreateInstance(target);
    data.toggle(this);
  });
  EventHandler__default["default"].on(window, EVENT_LOAD_DATA_API, function () {
    return SelectorEngine__default["default"].find(OPEN_SELECTOR).forEach(function (el) {
      return Offcanvas.getOrCreateInstance(el).show();
    });
  });
  enableDismissTrigger(Offcanvas);
  /**
   * ------------------------------------------------------------------------
   * jQuery
   * ------------------------------------------------------------------------
   */

  defineJQueryPlugin(Offcanvas);
  return Offcanvas;
});
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/*!
  * Bootstrap popover.js v5.1.3 (https://getbootstrap.com/)
  * Copyright 2011-2021 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
  */
(function (global, factory) {
  (typeof exports === "undefined" ? "undefined" : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('./tooltip.js')) : typeof define === 'function' && define.amd ? define(['./tooltip'], factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.Popover = factory(global.Tooltip));
})(void 0, function (Tooltip) {
  'use strict';

  var _interopDefaultLegacy = function _interopDefaultLegacy(e) {
    return e && _typeof(e) === 'object' && 'default' in e ? e : {
      "default": e
    };
  };

  var Tooltip__default = /*#__PURE__*/_interopDefaultLegacy(Tooltip);
  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v5.1.3): util/index.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */


  var getjQuery = function getjQuery() {
    var _window = window,
        jQuery = _window.jQuery;

    if (jQuery && !document.body.hasAttribute('data-bs-no-jquery')) {
      return jQuery;
    }

    return null;
  };

  var DOMContentLoadedCallbacks = [];

  var onDOMContentLoaded = function onDOMContentLoaded(callback) {
    if (document.readyState === 'loading') {
      // add listener on the first call when the document is in loading state
      if (!DOMContentLoadedCallbacks.length) {
        document.addEventListener('DOMContentLoaded', function () {
          DOMContentLoadedCallbacks.forEach(function (callback) {
            return callback();
          });
        });
      }

      DOMContentLoadedCallbacks.push(callback);
    } else {
      callback();
    }
  };

  var defineJQueryPlugin = function defineJQueryPlugin(plugin) {
    onDOMContentLoaded(function () {
      var $ = getjQuery();
      /* istanbul ignore if */

      if ($) {
        var name = plugin.NAME;
        var JQUERY_NO_CONFLICT = $.fn[name];
        $.fn[name] = plugin.jQueryInterface;
        $.fn[name].Constructor = plugin;

        $.fn[name].noConflict = function () {
          $.fn[name] = JQUERY_NO_CONFLICT;
          return plugin.jQueryInterface;
        };
      }
    });
  };
  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v5.1.3): popover.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */

  /**
   * ------------------------------------------------------------------------
   * Constants
   * ------------------------------------------------------------------------
   */


  var NAME = 'popover';
  var DATA_KEY = 'bs.popover';
  var EVENT_KEY = ".".concat(DATA_KEY);
  var CLASS_PREFIX = 'bs-popover';

  var Default = _objectSpread(_objectSpread({}, Tooltip__default["default"].Default), {}, {
    placement: 'right',
    offset: [0, 8],
    trigger: 'click',
    content: '',
    template: '<div class="popover" role="tooltip">' + '<div class="popover-arrow"></div>' + '<h3 class="popover-header"></h3>' + '<div class="popover-body"></div>' + '</div>'
  });

  var DefaultType = _objectSpread(_objectSpread({}, Tooltip__default["default"].DefaultType), {}, {
    content: '(string|element|function)'
  });

  var Event = {
    HIDE: "hide".concat(EVENT_KEY),
    HIDDEN: "hidden".concat(EVENT_KEY),
    SHOW: "show".concat(EVENT_KEY),
    SHOWN: "shown".concat(EVENT_KEY),
    INSERTED: "inserted".concat(EVENT_KEY),
    CLICK: "click".concat(EVENT_KEY),
    FOCUSIN: "focusin".concat(EVENT_KEY),
    FOCUSOUT: "focusout".concat(EVENT_KEY),
    MOUSEENTER: "mouseenter".concat(EVENT_KEY),
    MOUSELEAVE: "mouseleave".concat(EVENT_KEY)
  };
  var SELECTOR_TITLE = '.popover-header';
  var SELECTOR_CONTENT = '.popover-body';
  /**
   * ------------------------------------------------------------------------
   * Class Definition
   * ------------------------------------------------------------------------
   */

  var Popover = /*#__PURE__*/function (_Tooltip__default$def) {
    _inherits(Popover, _Tooltip__default$def);

    var _super = _createSuper(Popover);

    function Popover() {
      _classCallCheck(this, Popover);

      return _super.apply(this, arguments);
    }

    _createClass(Popover, [{
      key: "isWithContent",
      value: // Overrides
      function isWithContent() {
        return this.getTitle() || this._getContent();
      }
    }, {
      key: "setContent",
      value: function setContent(tip) {
        this._sanitizeAndSetContent(tip, this.getTitle(), SELECTOR_TITLE);

        this._sanitizeAndSetContent(tip, this._getContent(), SELECTOR_CONTENT);
      } // Private

    }, {
      key: "_getContent",
      value: function _getContent() {
        return this._resolvePossibleFunction(this._config.content);
      }
    }, {
      key: "_getBasicClassPrefix",
      value: function _getBasicClassPrefix() {
        return CLASS_PREFIX;
      } // Static

    }], [{
      key: "Default",
      get: // Getters
      function get() {
        return Default;
      }
    }, {
      key: "NAME",
      get: function get() {
        return NAME;
      }
    }, {
      key: "Event",
      get: function get() {
        return Event;
      }
    }, {
      key: "DefaultType",
      get: function get() {
        return DefaultType;
      }
    }, {
      key: "jQueryInterface",
      value: function jQueryInterface(config) {
        return this.each(function () {
          var data = Popover.getOrCreateInstance(this, config);

          if (typeof config === 'string') {
            if (typeof data[config] === 'undefined') {
              throw new TypeError("No method named \"".concat(config, "\""));
            }

            data[config]();
          }
        });
      }
    }]);

    return Popover;
  }(Tooltip__default["default"]);
  /**
   * ------------------------------------------------------------------------
   * jQuery
   * ------------------------------------------------------------------------
   * add .Popover to jQuery only if jQuery is present
   */


  defineJQueryPlugin(Popover);
  return Popover;
});
"use strict";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/*!
  * Bootstrap scrollspy.js v5.1.3 (https://getbootstrap.com/)
  * Copyright 2011-2021 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
  */
(function (global, factory) {
  (typeof exports === "undefined" ? "undefined" : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('./dom/event-handler.js'), require('./dom/manipulator.js'), require('./dom/selector-engine.js'), require('./base-component.js')) : typeof define === 'function' && define.amd ? define(['./dom/event-handler', './dom/manipulator', './dom/selector-engine', './base-component'], factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.ScrollSpy = factory(global.EventHandler, global.Manipulator, global.SelectorEngine, global.Base));
})(void 0, function (EventHandler, Manipulator, SelectorEngine, BaseComponent) {
  'use strict';

  var _interopDefaultLegacy = function _interopDefaultLegacy(e) {
    return e && _typeof(e) === 'object' && 'default' in e ? e : {
      "default": e
    };
  };

  var EventHandler__default = /*#__PURE__*/_interopDefaultLegacy(EventHandler);

  var Manipulator__default = /*#__PURE__*/_interopDefaultLegacy(Manipulator);

  var SelectorEngine__default = /*#__PURE__*/_interopDefaultLegacy(SelectorEngine);

  var BaseComponent__default = /*#__PURE__*/_interopDefaultLegacy(BaseComponent);
  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v5.1.3): util/index.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */


  var toType = function toType(obj) {
    if (obj === null || obj === undefined) {
      return "".concat(obj);
    }

    return {}.toString.call(obj).match(/\s([a-z]+)/i)[1].toLowerCase();
  };

  var getSelector = function getSelector(element) {
    var selector = element.getAttribute('data-bs-target');

    if (!selector || selector === '#') {
      var hrefAttr = element.getAttribute('href'); // The only valid content that could double as a selector are IDs or classes,
      // so everything starting with `#` or `.`. If a "real" URL is used as the selector,
      // `document.querySelector` will rightfully complain it is invalid.
      // See https://github.com/twbs/bootstrap/issues/32273

      if (!hrefAttr || !hrefAttr.includes('#') && !hrefAttr.startsWith('.')) {
        return null;
      } // Just in case some CMS puts out a full URL with the anchor appended


      if (hrefAttr.includes('#') && !hrefAttr.startsWith('#')) {
        hrefAttr = "#".concat(hrefAttr.split('#')[1]);
      }

      selector = hrefAttr && hrefAttr !== '#' ? hrefAttr.trim() : null;
    }

    return selector;
  };

  var getSelectorFromElement = function getSelectorFromElement(element) {
    var selector = getSelector(element);

    if (selector) {
      return document.querySelector(selector) ? selector : null;
    }

    return null;
  };

  var isElement = function isElement(obj) {
    if (!obj || _typeof(obj) !== 'object') {
      return false;
    }

    if (typeof obj.jquery !== 'undefined') {
      obj = obj[0];
    }

    return typeof obj.nodeType !== 'undefined';
  };

  var getElement = function getElement(obj) {
    if (isElement(obj)) {
      // it's a jQuery object or a node element
      return obj.jquery ? obj[0] : obj;
    }

    if (typeof obj === 'string' && obj.length > 0) {
      return document.querySelector(obj);
    }

    return null;
  };

  var typeCheckConfig = function typeCheckConfig(componentName, config, configTypes) {
    Object.keys(configTypes).forEach(function (property) {
      var expectedTypes = configTypes[property];
      var value = config[property];
      var valueType = value && isElement(value) ? 'element' : toType(value);

      if (!new RegExp(expectedTypes).test(valueType)) {
        throw new TypeError("".concat(componentName.toUpperCase(), ": Option \"").concat(property, "\" provided type \"").concat(valueType, "\" but expected type \"").concat(expectedTypes, "\"."));
      }
    });
  };

  var getjQuery = function getjQuery() {
    var _window = window,
        jQuery = _window.jQuery;

    if (jQuery && !document.body.hasAttribute('data-bs-no-jquery')) {
      return jQuery;
    }

    return null;
  };

  var DOMContentLoadedCallbacks = [];

  var onDOMContentLoaded = function onDOMContentLoaded(callback) {
    if (document.readyState === 'loading') {
      // add listener on the first call when the document is in loading state
      if (!DOMContentLoadedCallbacks.length) {
        document.addEventListener('DOMContentLoaded', function () {
          DOMContentLoadedCallbacks.forEach(function (callback) {
            return callback();
          });
        });
      }

      DOMContentLoadedCallbacks.push(callback);
    } else {
      callback();
    }
  };

  var defineJQueryPlugin = function defineJQueryPlugin(plugin) {
    onDOMContentLoaded(function () {
      var $ = getjQuery();
      /* istanbul ignore if */

      if ($) {
        var name = plugin.NAME;
        var JQUERY_NO_CONFLICT = $.fn[name];
        $.fn[name] = plugin.jQueryInterface;
        $.fn[name].Constructor = plugin;

        $.fn[name].noConflict = function () {
          $.fn[name] = JQUERY_NO_CONFLICT;
          return plugin.jQueryInterface;
        };
      }
    });
  };
  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v5.1.3): scrollspy.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */

  /**
   * ------------------------------------------------------------------------
   * Constants
   * ------------------------------------------------------------------------
   */


  var NAME = 'scrollspy';
  var DATA_KEY = 'bs.scrollspy';
  var EVENT_KEY = ".".concat(DATA_KEY);
  var DATA_API_KEY = '.data-api';
  var Default = {
    offset: 10,
    method: 'auto',
    target: ''
  };
  var DefaultType = {
    offset: 'number',
    method: 'string',
    target: '(string|element)'
  };
  var EVENT_ACTIVATE = "activate".concat(EVENT_KEY);
  var EVENT_SCROLL = "scroll".concat(EVENT_KEY);
  var EVENT_LOAD_DATA_API = "load".concat(EVENT_KEY).concat(DATA_API_KEY);
  var CLASS_NAME_DROPDOWN_ITEM = 'dropdown-item';
  var CLASS_NAME_ACTIVE = 'active';
  var SELECTOR_DATA_SPY = '[data-bs-spy="scroll"]';
  var SELECTOR_NAV_LIST_GROUP = '.nav, .list-group';
  var SELECTOR_NAV_LINKS = '.nav-link';
  var SELECTOR_NAV_ITEMS = '.nav-item';
  var SELECTOR_LIST_ITEMS = '.list-group-item';
  var SELECTOR_LINK_ITEMS = "".concat(SELECTOR_NAV_LINKS, ", ").concat(SELECTOR_LIST_ITEMS, ", .").concat(CLASS_NAME_DROPDOWN_ITEM);
  var SELECTOR_DROPDOWN = '.dropdown';
  var SELECTOR_DROPDOWN_TOGGLE = '.dropdown-toggle';
  var METHOD_OFFSET = 'offset';
  var METHOD_POSITION = 'position';
  /**
   * ------------------------------------------------------------------------
   * Class Definition
   * ------------------------------------------------------------------------
   */

  var ScrollSpy = /*#__PURE__*/function (_BaseComponent__defau) {
    _inherits(ScrollSpy, _BaseComponent__defau);

    var _super = _createSuper(ScrollSpy);

    function ScrollSpy(element, config) {
      var _this;

      _classCallCheck(this, ScrollSpy);

      _this = _super.call(this, element);
      _this._scrollElement = _this._element.tagName === 'BODY' ? window : _this._element;
      _this._config = _this._getConfig(config);
      _this._offsets = [];
      _this._targets = [];
      _this._activeTarget = null;
      _this._scrollHeight = 0;
      EventHandler__default["default"].on(_this._scrollElement, EVENT_SCROLL, function () {
        return _this._process();
      });

      _this.refresh();

      _this._process();

      return _this;
    } // Getters


    _createClass(ScrollSpy, [{
      key: "refresh",
      value: // Public
      function refresh() {
        var _this2 = this;

        var autoMethod = this._scrollElement === this._scrollElement.window ? METHOD_OFFSET : METHOD_POSITION;
        var offsetMethod = this._config.method === 'auto' ? autoMethod : this._config.method;
        var offsetBase = offsetMethod === METHOD_POSITION ? this._getScrollTop() : 0;
        this._offsets = [];
        this._targets = [];
        this._scrollHeight = this._getScrollHeight();
        var targets = SelectorEngine__default["default"].find(SELECTOR_LINK_ITEMS, this._config.target);
        targets.map(function (element) {
          var targetSelector = getSelectorFromElement(element);
          var target = targetSelector ? SelectorEngine__default["default"].findOne(targetSelector) : null;

          if (target) {
            var targetBCR = target.getBoundingClientRect();

            if (targetBCR.width || targetBCR.height) {
              return [Manipulator__default["default"][offsetMethod](target).top + offsetBase, targetSelector];
            }
          }

          return null;
        }).filter(function (item) {
          return item;
        }).sort(function (a, b) {
          return a[0] - b[0];
        }).forEach(function (item) {
          _this2._offsets.push(item[0]);

          _this2._targets.push(item[1]);
        });
      }
    }, {
      key: "dispose",
      value: function dispose() {
        EventHandler__default["default"].off(this._scrollElement, EVENT_KEY);

        _get(_getPrototypeOf(ScrollSpy.prototype), "dispose", this).call(this);
      } // Private

    }, {
      key: "_getConfig",
      value: function _getConfig(config) {
        config = _objectSpread(_objectSpread(_objectSpread({}, Default), Manipulator__default["default"].getDataAttributes(this._element)), _typeof(config) === 'object' && config ? config : {});
        config.target = getElement(config.target) || document.documentElement;
        typeCheckConfig(NAME, config, DefaultType);
        return config;
      }
    }, {
      key: "_getScrollTop",
      value: function _getScrollTop() {
        return this._scrollElement === window ? this._scrollElement.pageYOffset : this._scrollElement.scrollTop;
      }
    }, {
      key: "_getScrollHeight",
      value: function _getScrollHeight() {
        return this._scrollElement.scrollHeight || Math.max(document.body.scrollHeight, document.documentElement.scrollHeight);
      }
    }, {
      key: "_getOffsetHeight",
      value: function _getOffsetHeight() {
        return this._scrollElement === window ? window.innerHeight : this._scrollElement.getBoundingClientRect().height;
      }
    }, {
      key: "_process",
      value: function _process() {
        var scrollTop = this._getScrollTop() + this._config.offset;

        var scrollHeight = this._getScrollHeight();

        var maxScroll = this._config.offset + scrollHeight - this._getOffsetHeight();

        if (this._scrollHeight !== scrollHeight) {
          this.refresh();
        }

        if (scrollTop >= maxScroll) {
          var target = this._targets[this._targets.length - 1];

          if (this._activeTarget !== target) {
            this._activate(target);
          }

          return;
        }

        if (this._activeTarget && scrollTop < this._offsets[0] && this._offsets[0] > 0) {
          this._activeTarget = null;

          this._clear();

          return;
        }

        for (var i = this._offsets.length; i--;) {
          var isActiveTarget = this._activeTarget !== this._targets[i] && scrollTop >= this._offsets[i] && (typeof this._offsets[i + 1] === 'undefined' || scrollTop < this._offsets[i + 1]);

          if (isActiveTarget) {
            this._activate(this._targets[i]);
          }
        }
      }
    }, {
      key: "_activate",
      value: function _activate(target) {
        this._activeTarget = target;

        this._clear();

        var queries = SELECTOR_LINK_ITEMS.split(',').map(function (selector) {
          return "".concat(selector, "[data-bs-target=\"").concat(target, "\"],").concat(selector, "[href=\"").concat(target, "\"]");
        });
        var link = SelectorEngine__default["default"].findOne(queries.join(','), this._config.target);
        link.classList.add(CLASS_NAME_ACTIVE);

        if (link.classList.contains(CLASS_NAME_DROPDOWN_ITEM)) {
          SelectorEngine__default["default"].findOne(SELECTOR_DROPDOWN_TOGGLE, link.closest(SELECTOR_DROPDOWN)).classList.add(CLASS_NAME_ACTIVE);
        } else {
          SelectorEngine__default["default"].parents(link, SELECTOR_NAV_LIST_GROUP).forEach(function (listGroup) {
            // Set triggered links parents as active
            // With both <ul> and <nav> markup a parent is the previous sibling of any nav ancestor
            SelectorEngine__default["default"].prev(listGroup, "".concat(SELECTOR_NAV_LINKS, ", ").concat(SELECTOR_LIST_ITEMS)).forEach(function (item) {
              return item.classList.add(CLASS_NAME_ACTIVE);
            }); // Handle special case when .nav-link is inside .nav-item

            SelectorEngine__default["default"].prev(listGroup, SELECTOR_NAV_ITEMS).forEach(function (navItem) {
              SelectorEngine__default["default"].children(navItem, SELECTOR_NAV_LINKS).forEach(function (item) {
                return item.classList.add(CLASS_NAME_ACTIVE);
              });
            });
          });
        }

        EventHandler__default["default"].trigger(this._scrollElement, EVENT_ACTIVATE, {
          relatedTarget: target
        });
      }
    }, {
      key: "_clear",
      value: function _clear() {
        SelectorEngine__default["default"].find(SELECTOR_LINK_ITEMS, this._config.target).filter(function (node) {
          return node.classList.contains(CLASS_NAME_ACTIVE);
        }).forEach(function (node) {
          return node.classList.remove(CLASS_NAME_ACTIVE);
        });
      } // Static

    }], [{
      key: "Default",
      get: function get() {
        return Default;
      }
    }, {
      key: "NAME",
      get: function get() {
        return NAME;
      }
    }, {
      key: "jQueryInterface",
      value: function jQueryInterface(config) {
        return this.each(function () {
          var data = ScrollSpy.getOrCreateInstance(this, config);

          if (typeof config !== 'string') {
            return;
          }

          if (typeof data[config] === 'undefined') {
            throw new TypeError("No method named \"".concat(config, "\""));
          }

          data[config]();
        });
      }
    }]);

    return ScrollSpy;
  }(BaseComponent__default["default"]);
  /**
   * ------------------------------------------------------------------------
   * Data Api implementation
   * ------------------------------------------------------------------------
   */


  EventHandler__default["default"].on(window, EVENT_LOAD_DATA_API, function () {
    SelectorEngine__default["default"].find(SELECTOR_DATA_SPY).forEach(function (spy) {
      return new ScrollSpy(spy);
    });
  });
  /**
   * ------------------------------------------------------------------------
   * jQuery
   * ------------------------------------------------------------------------
   * add .ScrollSpy to jQuery only if jQuery is present
   */

  defineJQueryPlugin(ScrollSpy);
  return ScrollSpy;
});
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/*!
  * Bootstrap tab.js v5.1.3 (https://getbootstrap.com/)
  * Copyright 2011-2021 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
  */
(function (global, factory) {
  (typeof exports === "undefined" ? "undefined" : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('./dom/event-handler.js'), require('./dom/selector-engine.js'), require('./base-component.js')) : typeof define === 'function' && define.amd ? define(['./dom/event-handler', './dom/selector-engine', './base-component'], factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.Tab = factory(global.EventHandler, global.SelectorEngine, global.Base));
})(void 0, function (EventHandler, SelectorEngine, BaseComponent) {
  'use strict';

  var _interopDefaultLegacy = function _interopDefaultLegacy(e) {
    return e && _typeof(e) === 'object' && 'default' in e ? e : {
      "default": e
    };
  };

  var EventHandler__default = /*#__PURE__*/_interopDefaultLegacy(EventHandler);

  var SelectorEngine__default = /*#__PURE__*/_interopDefaultLegacy(SelectorEngine);

  var BaseComponent__default = /*#__PURE__*/_interopDefaultLegacy(BaseComponent);
  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v5.1.3): util/index.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */


  var getSelector = function getSelector(element) {
    var selector = element.getAttribute('data-bs-target');

    if (!selector || selector === '#') {
      var hrefAttr = element.getAttribute('href'); // The only valid content that could double as a selector are IDs or classes,
      // so everything starting with `#` or `.`. If a "real" URL is used as the selector,
      // `document.querySelector` will rightfully complain it is invalid.
      // See https://github.com/twbs/bootstrap/issues/32273

      if (!hrefAttr || !hrefAttr.includes('#') && !hrefAttr.startsWith('.')) {
        return null;
      } // Just in case some CMS puts out a full URL with the anchor appended


      if (hrefAttr.includes('#') && !hrefAttr.startsWith('#')) {
        hrefAttr = "#".concat(hrefAttr.split('#')[1]);
      }

      selector = hrefAttr && hrefAttr !== '#' ? hrefAttr.trim() : null;
    }

    return selector;
  };

  var getElementFromSelector = function getElementFromSelector(element) {
    var selector = getSelector(element);
    return selector ? document.querySelector(selector) : null;
  };

  var isDisabled = function isDisabled(element) {
    if (!element || element.nodeType !== Node.ELEMENT_NODE) {
      return true;
    }

    if (element.classList.contains('disabled')) {
      return true;
    }

    if (typeof element.disabled !== 'undefined') {
      return element.disabled;
    }

    return element.hasAttribute('disabled') && element.getAttribute('disabled') !== 'false';
  };
  /**
   * Trick to restart an element's animation
   *
   * @param {HTMLElement} element
   * @return void
   *
   * @see https://www.charistheo.io/blog/2021/02/restart-a-css-animation-with-javascript/#restarting-a-css-animation
   */


  var reflow = function reflow(element) {
    // eslint-disable-next-line no-unused-expressions
    element.offsetHeight;
  };

  var getjQuery = function getjQuery() {
    var _window = window,
        jQuery = _window.jQuery;

    if (jQuery && !document.body.hasAttribute('data-bs-no-jquery')) {
      return jQuery;
    }

    return null;
  };

  var DOMContentLoadedCallbacks = [];

  var onDOMContentLoaded = function onDOMContentLoaded(callback) {
    if (document.readyState === 'loading') {
      // add listener on the first call when the document is in loading state
      if (!DOMContentLoadedCallbacks.length) {
        document.addEventListener('DOMContentLoaded', function () {
          DOMContentLoadedCallbacks.forEach(function (callback) {
            return callback();
          });
        });
      }

      DOMContentLoadedCallbacks.push(callback);
    } else {
      callback();
    }
  };

  var defineJQueryPlugin = function defineJQueryPlugin(plugin) {
    onDOMContentLoaded(function () {
      var $ = getjQuery();
      /* istanbul ignore if */

      if ($) {
        var name = plugin.NAME;
        var JQUERY_NO_CONFLICT = $.fn[name];
        $.fn[name] = plugin.jQueryInterface;
        $.fn[name].Constructor = plugin;

        $.fn[name].noConflict = function () {
          $.fn[name] = JQUERY_NO_CONFLICT;
          return plugin.jQueryInterface;
        };
      }
    });
  };
  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v5.1.3): tab.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */

  /**
   * ------------------------------------------------------------------------
   * Constants
   * ------------------------------------------------------------------------
   */


  var NAME = 'tab';
  var DATA_KEY = 'bs.tab';
  var EVENT_KEY = ".".concat(DATA_KEY);
  var DATA_API_KEY = '.data-api';
  var EVENT_HIDE = "hide".concat(EVENT_KEY);
  var EVENT_HIDDEN = "hidden".concat(EVENT_KEY);
  var EVENT_SHOW = "show".concat(EVENT_KEY);
  var EVENT_SHOWN = "shown".concat(EVENT_KEY);
  var EVENT_CLICK_DATA_API = "click".concat(EVENT_KEY).concat(DATA_API_KEY);
  var CLASS_NAME_DROPDOWN_MENU = 'dropdown-menu';
  var CLASS_NAME_ACTIVE = 'active';
  var CLASS_NAME_FADE = 'fade';
  var CLASS_NAME_SHOW = 'show';
  var SELECTOR_DROPDOWN = '.dropdown';
  var SELECTOR_NAV_LIST_GROUP = '.nav, .list-group';
  var SELECTOR_ACTIVE = '.active';
  var SELECTOR_ACTIVE_UL = ':scope > li > .active';
  var SELECTOR_DATA_TOGGLE = '[data-bs-toggle="tab"], [data-bs-toggle="pill"], [data-bs-toggle="list"]';
  var SELECTOR_DROPDOWN_TOGGLE = '.dropdown-toggle';
  var SELECTOR_DROPDOWN_ACTIVE_CHILD = ':scope > .dropdown-menu .active';
  /**
   * ------------------------------------------------------------------------
   * Class Definition
   * ------------------------------------------------------------------------
   */

  var Tab = /*#__PURE__*/function (_BaseComponent__defau) {
    _inherits(Tab, _BaseComponent__defau);

    var _super = _createSuper(Tab);

    function Tab() {
      _classCallCheck(this, Tab);

      return _super.apply(this, arguments);
    }

    _createClass(Tab, [{
      key: "show",
      value: // Public
      function show() {
        var _this = this;

        if (this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE && this._element.classList.contains(CLASS_NAME_ACTIVE)) {
          return;
        }

        var previous;
        var target = getElementFromSelector(this._element);

        var listElement = this._element.closest(SELECTOR_NAV_LIST_GROUP);

        if (listElement) {
          var itemSelector = listElement.nodeName === 'UL' || listElement.nodeName === 'OL' ? SELECTOR_ACTIVE_UL : SELECTOR_ACTIVE;
          previous = SelectorEngine__default["default"].find(itemSelector, listElement);
          previous = previous[previous.length - 1];
        }

        var hideEvent = previous ? EventHandler__default["default"].trigger(previous, EVENT_HIDE, {
          relatedTarget: this._element
        }) : null;
        var showEvent = EventHandler__default["default"].trigger(this._element, EVENT_SHOW, {
          relatedTarget: previous
        });

        if (showEvent.defaultPrevented || hideEvent !== null && hideEvent.defaultPrevented) {
          return;
        }

        this._activate(this._element, listElement);

        var complete = function complete() {
          EventHandler__default["default"].trigger(previous, EVENT_HIDDEN, {
            relatedTarget: _this._element
          });
          EventHandler__default["default"].trigger(_this._element, EVENT_SHOWN, {
            relatedTarget: previous
          });
        };

        if (target) {
          this._activate(target, target.parentNode, complete);
        } else {
          complete();
        }
      } // Private

    }, {
      key: "_activate",
      value: function _activate(element, container, callback) {
        var _this2 = this;

        var activeElements = container && (container.nodeName === 'UL' || container.nodeName === 'OL') ? SelectorEngine__default["default"].find(SELECTOR_ACTIVE_UL, container) : SelectorEngine__default["default"].children(container, SELECTOR_ACTIVE);
        var active = activeElements[0];
        var isTransitioning = callback && active && active.classList.contains(CLASS_NAME_FADE);

        var complete = function complete() {
          return _this2._transitionComplete(element, active, callback);
        };

        if (active && isTransitioning) {
          active.classList.remove(CLASS_NAME_SHOW);

          this._queueCallback(complete, element, true);
        } else {
          complete();
        }
      }
    }, {
      key: "_transitionComplete",
      value: function _transitionComplete(element, active, callback) {
        if (active) {
          active.classList.remove(CLASS_NAME_ACTIVE);
          var dropdownChild = SelectorEngine__default["default"].findOne(SELECTOR_DROPDOWN_ACTIVE_CHILD, active.parentNode);

          if (dropdownChild) {
            dropdownChild.classList.remove(CLASS_NAME_ACTIVE);
          }

          if (active.getAttribute('role') === 'tab') {
            active.setAttribute('aria-selected', false);
          }
        }

        element.classList.add(CLASS_NAME_ACTIVE);

        if (element.getAttribute('role') === 'tab') {
          element.setAttribute('aria-selected', true);
        }

        reflow(element);

        if (element.classList.contains(CLASS_NAME_FADE)) {
          element.classList.add(CLASS_NAME_SHOW);
        }

        var parent = element.parentNode;

        if (parent && parent.nodeName === 'LI') {
          parent = parent.parentNode;
        }

        if (parent && parent.classList.contains(CLASS_NAME_DROPDOWN_MENU)) {
          var dropdownElement = element.closest(SELECTOR_DROPDOWN);

          if (dropdownElement) {
            SelectorEngine__default["default"].find(SELECTOR_DROPDOWN_TOGGLE, dropdownElement).forEach(function (dropdown) {
              return dropdown.classList.add(CLASS_NAME_ACTIVE);
            });
          }

          element.setAttribute('aria-expanded', true);
        }

        if (callback) {
          callback();
        }
      } // Static

    }], [{
      key: "NAME",
      get: // Getters
      function get() {
        return NAME;
      }
    }, {
      key: "jQueryInterface",
      value: function jQueryInterface(config) {
        return this.each(function () {
          var data = Tab.getOrCreateInstance(this);

          if (typeof config === 'string') {
            if (typeof data[config] === 'undefined') {
              throw new TypeError("No method named \"".concat(config, "\""));
            }

            data[config]();
          }
        });
      }
    }]);

    return Tab;
  }(BaseComponent__default["default"]);
  /**
   * ------------------------------------------------------------------------
   * Data Api implementation
   * ------------------------------------------------------------------------
   */


  EventHandler__default["default"].on(document, EVENT_CLICK_DATA_API, SELECTOR_DATA_TOGGLE, function (event) {
    if (['A', 'AREA'].includes(this.tagName)) {
      event.preventDefault();
    }

    if (isDisabled(this)) {
      return;
    }

    var data = Tab.getOrCreateInstance(this);
    data.show();
  });
  /**
   * ------------------------------------------------------------------------
   * jQuery
   * ------------------------------------------------------------------------
   * add .Tab to jQuery only if jQuery is present
   */

  defineJQueryPlugin(Tab);
  return Tab;
});
"use strict";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/*!
  * Bootstrap toast.js v5.1.3 (https://getbootstrap.com/)
  * Copyright 2011-2021 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
  */
(function (global, factory) {
  (typeof exports === "undefined" ? "undefined" : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('./dom/event-handler.js'), require('./dom/manipulator.js'), require('./base-component.js')) : typeof define === 'function' && define.amd ? define(['./dom/event-handler', './dom/manipulator', './base-component'], factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.Toast = factory(global.EventHandler, global.Manipulator, global.Base));
})(void 0, function (EventHandler, Manipulator, BaseComponent) {
  'use strict';

  var _interopDefaultLegacy = function _interopDefaultLegacy(e) {
    return e && _typeof(e) === 'object' && 'default' in e ? e : {
      "default": e
    };
  };

  var EventHandler__default = /*#__PURE__*/_interopDefaultLegacy(EventHandler);

  var Manipulator__default = /*#__PURE__*/_interopDefaultLegacy(Manipulator);

  var BaseComponent__default = /*#__PURE__*/_interopDefaultLegacy(BaseComponent);
  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v5.1.3): util/index.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */


  var toType = function toType(obj) {
    if (obj === null || obj === undefined) {
      return "".concat(obj);
    }

    return {}.toString.call(obj).match(/\s([a-z]+)/i)[1].toLowerCase();
  };

  var getSelector = function getSelector(element) {
    var selector = element.getAttribute('data-bs-target');

    if (!selector || selector === '#') {
      var hrefAttr = element.getAttribute('href'); // The only valid content that could double as a selector are IDs or classes,
      // so everything starting with `#` or `.`. If a "real" URL is used as the selector,
      // `document.querySelector` will rightfully complain it is invalid.
      // See https://github.com/twbs/bootstrap/issues/32273

      if (!hrefAttr || !hrefAttr.includes('#') && !hrefAttr.startsWith('.')) {
        return null;
      } // Just in case some CMS puts out a full URL with the anchor appended


      if (hrefAttr.includes('#') && !hrefAttr.startsWith('#')) {
        hrefAttr = "#".concat(hrefAttr.split('#')[1]);
      }

      selector = hrefAttr && hrefAttr !== '#' ? hrefAttr.trim() : null;
    }

    return selector;
  };

  var getElementFromSelector = function getElementFromSelector(element) {
    var selector = getSelector(element);
    return selector ? document.querySelector(selector) : null;
  };

  var isElement = function isElement(obj) {
    if (!obj || _typeof(obj) !== 'object') {
      return false;
    }

    if (typeof obj.jquery !== 'undefined') {
      obj = obj[0];
    }

    return typeof obj.nodeType !== 'undefined';
  };

  var typeCheckConfig = function typeCheckConfig(componentName, config, configTypes) {
    Object.keys(configTypes).forEach(function (property) {
      var expectedTypes = configTypes[property];
      var value = config[property];
      var valueType = value && isElement(value) ? 'element' : toType(value);

      if (!new RegExp(expectedTypes).test(valueType)) {
        throw new TypeError("".concat(componentName.toUpperCase(), ": Option \"").concat(property, "\" provided type \"").concat(valueType, "\" but expected type \"").concat(expectedTypes, "\"."));
      }
    });
  };

  var isDisabled = function isDisabled(element) {
    if (!element || element.nodeType !== Node.ELEMENT_NODE) {
      return true;
    }

    if (element.classList.contains('disabled')) {
      return true;
    }

    if (typeof element.disabled !== 'undefined') {
      return element.disabled;
    }

    return element.hasAttribute('disabled') && element.getAttribute('disabled') !== 'false';
  };
  /**
   * Trick to restart an element's animation
   *
   * @param {HTMLElement} element
   * @return void
   *
   * @see https://www.charistheo.io/blog/2021/02/restart-a-css-animation-with-javascript/#restarting-a-css-animation
   */


  var reflow = function reflow(element) {
    // eslint-disable-next-line no-unused-expressions
    element.offsetHeight;
  };

  var getjQuery = function getjQuery() {
    var _window = window,
        jQuery = _window.jQuery;

    if (jQuery && !document.body.hasAttribute('data-bs-no-jquery')) {
      return jQuery;
    }

    return null;
  };

  var DOMContentLoadedCallbacks = [];

  var onDOMContentLoaded = function onDOMContentLoaded(callback) {
    if (document.readyState === 'loading') {
      // add listener on the first call when the document is in loading state
      if (!DOMContentLoadedCallbacks.length) {
        document.addEventListener('DOMContentLoaded', function () {
          DOMContentLoadedCallbacks.forEach(function (callback) {
            return callback();
          });
        });
      }

      DOMContentLoadedCallbacks.push(callback);
    } else {
      callback();
    }
  };

  var defineJQueryPlugin = function defineJQueryPlugin(plugin) {
    onDOMContentLoaded(function () {
      var $ = getjQuery();
      /* istanbul ignore if */

      if ($) {
        var name = plugin.NAME;
        var JQUERY_NO_CONFLICT = $.fn[name];
        $.fn[name] = plugin.jQueryInterface;
        $.fn[name].Constructor = plugin;

        $.fn[name].noConflict = function () {
          $.fn[name] = JQUERY_NO_CONFLICT;
          return plugin.jQueryInterface;
        };
      }
    });
  };
  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v5.1.3): util/component-functions.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */


  var enableDismissTrigger = function enableDismissTrigger(component) {
    var method = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'hide';
    var clickEvent = "click.dismiss".concat(component.EVENT_KEY);
    var name = component.NAME;
    EventHandler__default["default"].on(document, clickEvent, "[data-bs-dismiss=\"".concat(name, "\"]"), function (event) {
      if (['A', 'AREA'].includes(this.tagName)) {
        event.preventDefault();
      }

      if (isDisabled(this)) {
        return;
      }

      var target = getElementFromSelector(this) || this.closest(".".concat(name));
      var instance = component.getOrCreateInstance(target); // Method argument is left, for Alert and only, as it doesn't implement the 'hide' method

      instance[method]();
    });
  };
  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v5.1.3): toast.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */

  /**
   * ------------------------------------------------------------------------
   * Constants
   * ------------------------------------------------------------------------
   */


  var NAME = 'toast';
  var DATA_KEY = 'bs.toast';
  var EVENT_KEY = ".".concat(DATA_KEY);
  var EVENT_MOUSEOVER = "mouseover".concat(EVENT_KEY);
  var EVENT_MOUSEOUT = "mouseout".concat(EVENT_KEY);
  var EVENT_FOCUSIN = "focusin".concat(EVENT_KEY);
  var EVENT_FOCUSOUT = "focusout".concat(EVENT_KEY);
  var EVENT_HIDE = "hide".concat(EVENT_KEY);
  var EVENT_HIDDEN = "hidden".concat(EVENT_KEY);
  var EVENT_SHOW = "show".concat(EVENT_KEY);
  var EVENT_SHOWN = "shown".concat(EVENT_KEY);
  var CLASS_NAME_FADE = 'fade';
  var CLASS_NAME_HIDE = 'hide'; // @deprecated - kept here only for backwards compatibility

  var CLASS_NAME_SHOW = 'show';
  var CLASS_NAME_SHOWING = 'showing';
  var DefaultType = {
    animation: 'boolean',
    autohide: 'boolean',
    delay: 'number'
  };
  var Default = {
    animation: true,
    autohide: true,
    delay: 5000
  };
  /**
   * ------------------------------------------------------------------------
   * Class Definition
   * ------------------------------------------------------------------------
   */

  var Toast = /*#__PURE__*/function (_BaseComponent__defau) {
    _inherits(Toast, _BaseComponent__defau);

    var _super = _createSuper(Toast);

    function Toast(element, config) {
      var _this;

      _classCallCheck(this, Toast);

      _this = _super.call(this, element);
      _this._config = _this._getConfig(config);
      _this._timeout = null;
      _this._hasMouseInteraction = false;
      _this._hasKeyboardInteraction = false;

      _this._setListeners();

      return _this;
    } // Getters


    _createClass(Toast, [{
      key: "show",
      value: // Public
      function show() {
        var _this2 = this;

        var showEvent = EventHandler__default["default"].trigger(this._element, EVENT_SHOW);

        if (showEvent.defaultPrevented) {
          return;
        }

        this._clearTimeout();

        if (this._config.animation) {
          this._element.classList.add(CLASS_NAME_FADE);
        }

        var complete = function complete() {
          _this2._element.classList.remove(CLASS_NAME_SHOWING);

          EventHandler__default["default"].trigger(_this2._element, EVENT_SHOWN);

          _this2._maybeScheduleHide();
        };

        this._element.classList.remove(CLASS_NAME_HIDE); // @deprecated


        reflow(this._element);

        this._element.classList.add(CLASS_NAME_SHOW);

        this._element.classList.add(CLASS_NAME_SHOWING);

        this._queueCallback(complete, this._element, this._config.animation);
      }
    }, {
      key: "hide",
      value: function hide() {
        var _this3 = this;

        if (!this._element.classList.contains(CLASS_NAME_SHOW)) {
          return;
        }

        var hideEvent = EventHandler__default["default"].trigger(this._element, EVENT_HIDE);

        if (hideEvent.defaultPrevented) {
          return;
        }

        var complete = function complete() {
          _this3._element.classList.add(CLASS_NAME_HIDE); // @deprecated


          _this3._element.classList.remove(CLASS_NAME_SHOWING);

          _this3._element.classList.remove(CLASS_NAME_SHOW);

          EventHandler__default["default"].trigger(_this3._element, EVENT_HIDDEN);
        };

        this._element.classList.add(CLASS_NAME_SHOWING);

        this._queueCallback(complete, this._element, this._config.animation);
      }
    }, {
      key: "dispose",
      value: function dispose() {
        this._clearTimeout();

        if (this._element.classList.contains(CLASS_NAME_SHOW)) {
          this._element.classList.remove(CLASS_NAME_SHOW);
        }

        _get(_getPrototypeOf(Toast.prototype), "dispose", this).call(this);
      } // Private

    }, {
      key: "_getConfig",
      value: function _getConfig(config) {
        config = _objectSpread(_objectSpread(_objectSpread({}, Default), Manipulator__default["default"].getDataAttributes(this._element)), _typeof(config) === 'object' && config ? config : {});
        typeCheckConfig(NAME, config, this.constructor.DefaultType);
        return config;
      }
    }, {
      key: "_maybeScheduleHide",
      value: function _maybeScheduleHide() {
        var _this4 = this;

        if (!this._config.autohide) {
          return;
        }

        if (this._hasMouseInteraction || this._hasKeyboardInteraction) {
          return;
        }

        this._timeout = setTimeout(function () {
          _this4.hide();
        }, this._config.delay);
      }
    }, {
      key: "_onInteraction",
      value: function _onInteraction(event, isInteracting) {
        switch (event.type) {
          case 'mouseover':
          case 'mouseout':
            this._hasMouseInteraction = isInteracting;
            break;

          case 'focusin':
          case 'focusout':
            this._hasKeyboardInteraction = isInteracting;
            break;
        }

        if (isInteracting) {
          this._clearTimeout();

          return;
        }

        var nextElement = event.relatedTarget;

        if (this._element === nextElement || this._element.contains(nextElement)) {
          return;
        }

        this._maybeScheduleHide();
      }
    }, {
      key: "_setListeners",
      value: function _setListeners() {
        var _this5 = this;

        EventHandler__default["default"].on(this._element, EVENT_MOUSEOVER, function (event) {
          return _this5._onInteraction(event, true);
        });
        EventHandler__default["default"].on(this._element, EVENT_MOUSEOUT, function (event) {
          return _this5._onInteraction(event, false);
        });
        EventHandler__default["default"].on(this._element, EVENT_FOCUSIN, function (event) {
          return _this5._onInteraction(event, true);
        });
        EventHandler__default["default"].on(this._element, EVENT_FOCUSOUT, function (event) {
          return _this5._onInteraction(event, false);
        });
      }
    }, {
      key: "_clearTimeout",
      value: function _clearTimeout() {
        clearTimeout(this._timeout);
        this._timeout = null;
      } // Static

    }], [{
      key: "DefaultType",
      get: function get() {
        return DefaultType;
      }
    }, {
      key: "Default",
      get: function get() {
        return Default;
      }
    }, {
      key: "NAME",
      get: function get() {
        return NAME;
      }
    }, {
      key: "jQueryInterface",
      value: function jQueryInterface(config) {
        return this.each(function () {
          var data = Toast.getOrCreateInstance(this, config);

          if (typeof config === 'string') {
            if (typeof data[config] === 'undefined') {
              throw new TypeError("No method named \"".concat(config, "\""));
            }

            data[config](this);
          }
        });
      }
    }]);

    return Toast;
  }(BaseComponent__default["default"]);

  enableDismissTrigger(Toast);
  /**
   * ------------------------------------------------------------------------
   * jQuery
   * ------------------------------------------------------------------------
   * add .Toast to jQuery only if jQuery is present
   */

  defineJQueryPlugin(Toast);
  return Toast;
});
"use strict";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/*!
  * Bootstrap tooltip.js v5.1.3 (https://getbootstrap.com/)
  * Copyright 2011-2021 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
  */
(function (global, factory) {
  (typeof exports === "undefined" ? "undefined" : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('@popperjs/core'), require('./dom/data.js'), require('./dom/event-handler.js'), require('./dom/manipulator.js'), require('./dom/selector-engine.js'), require('./base-component.js')) : typeof define === 'function' && define.amd ? define(['@popperjs/core', './dom/data', './dom/event-handler', './dom/manipulator', './dom/selector-engine', './base-component'], factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.Tooltip = factory(global.Popper, global.Data, global.EventHandler, global.Manipulator, global.SelectorEngine, global.Base));
})(void 0, function (Popper, Data, EventHandler, Manipulator, SelectorEngine, BaseComponent) {
  'use strict';

  var _interopDefaultLegacy = function _interopDefaultLegacy(e) {
    return e && _typeof(e) === 'object' && 'default' in e ? e : {
      "default": e
    };
  };

  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);

    if (e) {
      var _loop = function _loop(k) {
        if (k !== 'default') {
          var d = Object.getOwnPropertyDescriptor(e, k);
          Object.defineProperty(n, k, d.get ? d : {
            enumerable: true,
            get: function get() {
              return e[k];
            }
          });
        }
      };

      for (var k in e) {
        _loop(k);
      }
    }

    n["default"] = e;
    return Object.freeze(n);
  }

  var Popper__namespace = /*#__PURE__*/_interopNamespace(Popper);

  var Data__default = /*#__PURE__*/_interopDefaultLegacy(Data);

  var EventHandler__default = /*#__PURE__*/_interopDefaultLegacy(EventHandler);

  var Manipulator__default = /*#__PURE__*/_interopDefaultLegacy(Manipulator);

  var SelectorEngine__default = /*#__PURE__*/_interopDefaultLegacy(SelectorEngine);

  var BaseComponent__default = /*#__PURE__*/_interopDefaultLegacy(BaseComponent);
  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v5.1.3): util/index.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */


  var MAX_UID = 1000000;

  var toType = function toType(obj) {
    if (obj === null || obj === undefined) {
      return "".concat(obj);
    }

    return {}.toString.call(obj).match(/\s([a-z]+)/i)[1].toLowerCase();
  };
  /**
   * --------------------------------------------------------------------------
   * Public Util Api
   * --------------------------------------------------------------------------
   */


  var getUID = function getUID(prefix) {
    do {
      prefix += Math.floor(Math.random() * MAX_UID);
    } while (document.getElementById(prefix));

    return prefix;
  };

  var isElement = function isElement(obj) {
    if (!obj || _typeof(obj) !== 'object') {
      return false;
    }

    if (typeof obj.jquery !== 'undefined') {
      obj = obj[0];
    }

    return typeof obj.nodeType !== 'undefined';
  };

  var getElement = function getElement(obj) {
    if (isElement(obj)) {
      // it's a jQuery object or a node element
      return obj.jquery ? obj[0] : obj;
    }

    if (typeof obj === 'string' && obj.length > 0) {
      return document.querySelector(obj);
    }

    return null;
  };

  var typeCheckConfig = function typeCheckConfig(componentName, config, configTypes) {
    Object.keys(configTypes).forEach(function (property) {
      var expectedTypes = configTypes[property];
      var value = config[property];
      var valueType = value && isElement(value) ? 'element' : toType(value);

      if (!new RegExp(expectedTypes).test(valueType)) {
        throw new TypeError("".concat(componentName.toUpperCase(), ": Option \"").concat(property, "\" provided type \"").concat(valueType, "\" but expected type \"").concat(expectedTypes, "\"."));
      }
    });
  };

  var findShadowRoot = function findShadowRoot(element) {
    if (!document.documentElement.attachShadow) {
      return null;
    } // Can find the shadow root otherwise it'll return the document


    if (typeof element.getRootNode === 'function') {
      var root = element.getRootNode();
      return root instanceof ShadowRoot ? root : null;
    }

    if (element instanceof ShadowRoot) {
      return element;
    } // when we don't find a shadow root


    if (!element.parentNode) {
      return null;
    }

    return findShadowRoot(element.parentNode);
  };

  var noop = function noop() {};

  var getjQuery = function getjQuery() {
    var _window = window,
        jQuery = _window.jQuery;

    if (jQuery && !document.body.hasAttribute('data-bs-no-jquery')) {
      return jQuery;
    }

    return null;
  };

  var DOMContentLoadedCallbacks = [];

  var onDOMContentLoaded = function onDOMContentLoaded(callback) {
    if (document.readyState === 'loading') {
      // add listener on the first call when the document is in loading state
      if (!DOMContentLoadedCallbacks.length) {
        document.addEventListener('DOMContentLoaded', function () {
          DOMContentLoadedCallbacks.forEach(function (callback) {
            return callback();
          });
        });
      }

      DOMContentLoadedCallbacks.push(callback);
    } else {
      callback();
    }
  };

  var isRTL = function isRTL() {
    return document.documentElement.dir === 'rtl';
  };

  var defineJQueryPlugin = function defineJQueryPlugin(plugin) {
    onDOMContentLoaded(function () {
      var $ = getjQuery();
      /* istanbul ignore if */

      if ($) {
        var name = plugin.NAME;
        var JQUERY_NO_CONFLICT = $.fn[name];
        $.fn[name] = plugin.jQueryInterface;
        $.fn[name].Constructor = plugin;

        $.fn[name].noConflict = function () {
          $.fn[name] = JQUERY_NO_CONFLICT;
          return plugin.jQueryInterface;
        };
      }
    });
  };
  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v5.1.3): util/sanitizer.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */


  var uriAttributes = new Set(['background', 'cite', 'href', 'itemtype', 'longdesc', 'poster', 'src', 'xlink:href']);
  var ARIA_ATTRIBUTE_PATTERN = /^aria-[\w-]*$/i;
  /**
   * A pattern that recognizes a commonly useful subset of URLs that are safe.
   *
   * Shoutout to Angular https://github.com/angular/angular/blob/12.2.x/packages/core/src/sanitization/url_sanitizer.ts
   */

  var SAFE_URL_PATTERN = /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^#&/:?]*(?:[#/?]|$))/i;
  /**
   * A pattern that matches safe data URLs. Only matches image, video and audio types.
   *
   * Shoutout to Angular https://github.com/angular/angular/blob/12.2.x/packages/core/src/sanitization/url_sanitizer.ts
   */

  var DATA_URL_PATTERN = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[\d+/a-z]+=*$/i;

  var allowedAttribute = function allowedAttribute(attribute, allowedAttributeList) {
    var attributeName = attribute.nodeName.toLowerCase();

    if (allowedAttributeList.includes(attributeName)) {
      if (uriAttributes.has(attributeName)) {
        return Boolean(SAFE_URL_PATTERN.test(attribute.nodeValue) || DATA_URL_PATTERN.test(attribute.nodeValue));
      }

      return true;
    }

    var regExp = allowedAttributeList.filter(function (attributeRegex) {
      return attributeRegex instanceof RegExp;
    }); // Check if a regular expression validates the attribute.

    for (var i = 0, len = regExp.length; i < len; i++) {
      if (regExp[i].test(attributeName)) {
        return true;
      }
    }

    return false;
  };

  var DefaultAllowlist = {
    // Global attributes allowed on any supplied element below.
    '*': ['class', 'dir', 'id', 'lang', 'role', ARIA_ATTRIBUTE_PATTERN],
    a: ['target', 'href', 'title', 'rel'],
    area: [],
    b: [],
    br: [],
    col: [],
    code: [],
    div: [],
    em: [],
    hr: [],
    h1: [],
    h2: [],
    h3: [],
    h4: [],
    h5: [],
    h6: [],
    i: [],
    img: ['src', 'srcset', 'alt', 'title', 'width', 'height'],
    li: [],
    ol: [],
    p: [],
    pre: [],
    s: [],
    small: [],
    span: [],
    sub: [],
    sup: [],
    strong: [],
    u: [],
    ul: []
  };

  function sanitizeHtml(unsafeHtml, allowList, sanitizeFn) {
    var _ref;

    if (!unsafeHtml.length) {
      return unsafeHtml;
    }

    if (sanitizeFn && typeof sanitizeFn === 'function') {
      return sanitizeFn(unsafeHtml);
    }

    var domParser = new window.DOMParser();
    var createdDocument = domParser.parseFromString(unsafeHtml, 'text/html');

    var elements = (_ref = []).concat.apply(_ref, _toConsumableArray(createdDocument.body.querySelectorAll('*')));

    var _loop2 = function _loop2(i, len) {
      var _ref2;

      var element = elements[i];
      var elementName = element.nodeName.toLowerCase();

      if (!Object.keys(allowList).includes(elementName)) {
        element.remove();
        return "continue";
      }

      var attributeList = (_ref2 = []).concat.apply(_ref2, _toConsumableArray(element.attributes));

      var allowedAttributes = [].concat(allowList['*'] || [], allowList[elementName] || []);
      attributeList.forEach(function (attribute) {
        if (!allowedAttribute(attribute, allowedAttributes)) {
          element.removeAttribute(attribute.nodeName);
        }
      });
    };

    for (var i = 0, len = elements.length; i < len; i++) {
      var _ret = _loop2(i, len);

      if (_ret === "continue") continue;
    }

    return createdDocument.body.innerHTML;
  }
  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v5.1.3): tooltip.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */

  /**
   * ------------------------------------------------------------------------
   * Constants
   * ------------------------------------------------------------------------
   */


  var NAME = 'tooltip';
  var DATA_KEY = 'bs.tooltip';
  var EVENT_KEY = ".".concat(DATA_KEY);
  var CLASS_PREFIX = 'bs-tooltip';
  var DISALLOWED_ATTRIBUTES = new Set(['sanitize', 'allowList', 'sanitizeFn']);
  var DefaultType = {
    animation: 'boolean',
    template: 'string',
    title: '(string|element|function)',
    trigger: 'string',
    delay: '(number|object)',
    html: 'boolean',
    selector: '(string|boolean)',
    placement: '(string|function)',
    offset: '(array|string|function)',
    container: '(string|element|boolean)',
    fallbackPlacements: 'array',
    boundary: '(string|element)',
    customClass: '(string|function)',
    sanitize: 'boolean',
    sanitizeFn: '(null|function)',
    allowList: 'object',
    popperConfig: '(null|object|function)'
  };
  var AttachmentMap = {
    AUTO: 'auto',
    TOP: 'top',
    RIGHT: isRTL() ? 'left' : 'right',
    BOTTOM: 'bottom',
    LEFT: isRTL() ? 'right' : 'left'
  };
  var Default = {
    animation: true,
    template: '<div class="tooltip" role="tooltip">' + '<div class="tooltip-arrow"></div>' + '<div class="tooltip-inner"></div>' + '</div>',
    trigger: 'hover focus',
    title: '',
    delay: 0,
    html: false,
    selector: false,
    placement: 'top',
    offset: [0, 0],
    container: false,
    fallbackPlacements: ['top', 'right', 'bottom', 'left'],
    boundary: 'clippingParents',
    customClass: '',
    sanitize: true,
    sanitizeFn: null,
    allowList: DefaultAllowlist,
    popperConfig: null
  };
  var Event = {
    HIDE: "hide".concat(EVENT_KEY),
    HIDDEN: "hidden".concat(EVENT_KEY),
    SHOW: "show".concat(EVENT_KEY),
    SHOWN: "shown".concat(EVENT_KEY),
    INSERTED: "inserted".concat(EVENT_KEY),
    CLICK: "click".concat(EVENT_KEY),
    FOCUSIN: "focusin".concat(EVENT_KEY),
    FOCUSOUT: "focusout".concat(EVENT_KEY),
    MOUSEENTER: "mouseenter".concat(EVENT_KEY),
    MOUSELEAVE: "mouseleave".concat(EVENT_KEY)
  };
  var CLASS_NAME_FADE = 'fade';
  var CLASS_NAME_MODAL = 'modal';
  var CLASS_NAME_SHOW = 'show';
  var HOVER_STATE_SHOW = 'show';
  var HOVER_STATE_OUT = 'out';
  var SELECTOR_TOOLTIP_INNER = '.tooltip-inner';
  var SELECTOR_MODAL = ".".concat(CLASS_NAME_MODAL);
  var EVENT_MODAL_HIDE = 'hide.bs.modal';
  var TRIGGER_HOVER = 'hover';
  var TRIGGER_FOCUS = 'focus';
  var TRIGGER_CLICK = 'click';
  var TRIGGER_MANUAL = 'manual';
  /**
   * ------------------------------------------------------------------------
   * Class Definition
   * ------------------------------------------------------------------------
   */

  var Tooltip = /*#__PURE__*/function (_BaseComponent__defau) {
    _inherits(Tooltip, _BaseComponent__defau);

    var _super = _createSuper(Tooltip);

    function Tooltip(element, config) {
      var _this;

      _classCallCheck(this, Tooltip);

      if (typeof Popper__namespace === 'undefined') {
        throw new TypeError('Bootstrap\'s tooltips require Popper (https://popper.js.org)');
      }

      _this = _super.call(this, element); // private

      _this._isEnabled = true;
      _this._timeout = 0;
      _this._hoverState = '';
      _this._activeTrigger = {};
      _this._popper = null; // Protected

      _this._config = _this._getConfig(config);
      _this.tip = null;

      _this._setListeners();

      return _this;
    } // Getters


    _createClass(Tooltip, [{
      key: "enable",
      value: // Public
      function enable() {
        this._isEnabled = true;
      }
    }, {
      key: "disable",
      value: function disable() {
        this._isEnabled = false;
      }
    }, {
      key: "toggleEnabled",
      value: function toggleEnabled() {
        this._isEnabled = !this._isEnabled;
      }
    }, {
      key: "toggle",
      value: function toggle(event) {
        if (!this._isEnabled) {
          return;
        }

        if (event) {
          var context = this._initializeOnDelegatedTarget(event);

          context._activeTrigger.click = !context._activeTrigger.click;

          if (context._isWithActiveTrigger()) {
            context._enter(null, context);
          } else {
            context._leave(null, context);
          }
        } else {
          if (this.getTipElement().classList.contains(CLASS_NAME_SHOW)) {
            this._leave(null, this);

            return;
          }

          this._enter(null, this);
        }
      }
    }, {
      key: "dispose",
      value: function dispose() {
        clearTimeout(this._timeout);
        EventHandler__default["default"].off(this._element.closest(SELECTOR_MODAL), EVENT_MODAL_HIDE, this._hideModalHandler);

        if (this.tip) {
          this.tip.remove();
        }

        this._disposePopper();

        _get(_getPrototypeOf(Tooltip.prototype), "dispose", this).call(this);
      }
    }, {
      key: "show",
      value: function show() {
        var _this2 = this;

        if (this._element.style.display === 'none') {
          throw new Error('Please use show on visible elements');
        }

        if (!(this.isWithContent() && this._isEnabled)) {
          return;
        }

        var showEvent = EventHandler__default["default"].trigger(this._element, this.constructor.Event.SHOW);
        var shadowRoot = findShadowRoot(this._element);
        var isInTheDom = shadowRoot === null ? this._element.ownerDocument.documentElement.contains(this._element) : shadowRoot.contains(this._element);

        if (showEvent.defaultPrevented || !isInTheDom) {
          return;
        } // A trick to recreate a tooltip in case a new title is given by using the NOT documented `data-bs-original-title`
        // This will be removed later in favor of a `setContent` method


        if (this.constructor.NAME === 'tooltip' && this.tip && this.getTitle() !== this.tip.querySelector(SELECTOR_TOOLTIP_INNER).innerHTML) {
          this._disposePopper();

          this.tip.remove();
          this.tip = null;
        }

        var tip = this.getTipElement();
        var tipId = getUID(this.constructor.NAME);
        tip.setAttribute('id', tipId);

        this._element.setAttribute('aria-describedby', tipId);

        if (this._config.animation) {
          tip.classList.add(CLASS_NAME_FADE);
        }

        var placement = typeof this._config.placement === 'function' ? this._config.placement.call(this, tip, this._element) : this._config.placement;

        var attachment = this._getAttachment(placement);

        this._addAttachmentClass(attachment);

        var container = this._config.container;
        Data__default["default"].set(tip, this.constructor.DATA_KEY, this);

        if (!this._element.ownerDocument.documentElement.contains(this.tip)) {
          container.append(tip);
          EventHandler__default["default"].trigger(this._element, this.constructor.Event.INSERTED);
        }

        if (this._popper) {
          this._popper.update();
        } else {
          this._popper = Popper__namespace.createPopper(this._element, tip, this._getPopperConfig(attachment));
        }

        tip.classList.add(CLASS_NAME_SHOW);

        var customClass = this._resolvePossibleFunction(this._config.customClass);

        if (customClass) {
          var _tip$classList;

          (_tip$classList = tip.classList).add.apply(_tip$classList, _toConsumableArray(customClass.split(' ')));
        } // If this is a touch-enabled device we add extra
        // empty mouseover listeners to the body's immediate children;
        // only needed because of broken event delegation on iOS
        // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html


        if ('ontouchstart' in document.documentElement) {
          var _ref3;

          (_ref3 = []).concat.apply(_ref3, _toConsumableArray(document.body.children)).forEach(function (element) {
            EventHandler__default["default"].on(element, 'mouseover', noop);
          });
        }

        var complete = function complete() {
          var prevHoverState = _this2._hoverState;
          _this2._hoverState = null;
          EventHandler__default["default"].trigger(_this2._element, _this2.constructor.Event.SHOWN);

          if (prevHoverState === HOVER_STATE_OUT) {
            _this2._leave(null, _this2);
          }
        };

        var isAnimated = this.tip.classList.contains(CLASS_NAME_FADE);

        this._queueCallback(complete, this.tip, isAnimated);
      }
    }, {
      key: "hide",
      value: function hide() {
        var _this3 = this;

        if (!this._popper) {
          return;
        }

        var tip = this.getTipElement();

        var complete = function complete() {
          if (_this3._isWithActiveTrigger()) {
            return;
          }

          if (_this3._hoverState !== HOVER_STATE_SHOW) {
            tip.remove();
          }

          _this3._cleanTipClass();

          _this3._element.removeAttribute('aria-describedby');

          EventHandler__default["default"].trigger(_this3._element, _this3.constructor.Event.HIDDEN);

          _this3._disposePopper();
        };

        var hideEvent = EventHandler__default["default"].trigger(this._element, this.constructor.Event.HIDE);

        if (hideEvent.defaultPrevented) {
          return;
        }

        tip.classList.remove(CLASS_NAME_SHOW); // If this is a touch-enabled device we remove the extra
        // empty mouseover listeners we added for iOS support

        if ('ontouchstart' in document.documentElement) {
          var _ref4;

          (_ref4 = []).concat.apply(_ref4, _toConsumableArray(document.body.children)).forEach(function (element) {
            return EventHandler__default["default"].off(element, 'mouseover', noop);
          });
        }

        this._activeTrigger[TRIGGER_CLICK] = false;
        this._activeTrigger[TRIGGER_FOCUS] = false;
        this._activeTrigger[TRIGGER_HOVER] = false;
        var isAnimated = this.tip.classList.contains(CLASS_NAME_FADE);

        this._queueCallback(complete, this.tip, isAnimated);

        this._hoverState = '';
      }
    }, {
      key: "update",
      value: function update() {
        if (this._popper !== null) {
          this._popper.update();
        }
      } // Protected

    }, {
      key: "isWithContent",
      value: function isWithContent() {
        return Boolean(this.getTitle());
      }
    }, {
      key: "getTipElement",
      value: function getTipElement() {
        if (this.tip) {
          return this.tip;
        }

        var element = document.createElement('div');
        element.innerHTML = this._config.template;
        var tip = element.children[0];
        this.setContent(tip);
        tip.classList.remove(CLASS_NAME_FADE, CLASS_NAME_SHOW);
        this.tip = tip;
        return this.tip;
      }
    }, {
      key: "setContent",
      value: function setContent(tip) {
        this._sanitizeAndSetContent(tip, this.getTitle(), SELECTOR_TOOLTIP_INNER);
      }
    }, {
      key: "_sanitizeAndSetContent",
      value: function _sanitizeAndSetContent(template, content, selector) {
        var templateElement = SelectorEngine__default["default"].findOne(selector, template);

        if (!content && templateElement) {
          templateElement.remove();
          return;
        } // we use append for html objects to maintain js events


        this.setElementContent(templateElement, content);
      }
    }, {
      key: "setElementContent",
      value: function setElementContent(element, content) {
        if (element === null) {
          return;
        }

        if (isElement(content)) {
          content = getElement(content); // content is a DOM node or a jQuery

          if (this._config.html) {
            if (content.parentNode !== element) {
              element.innerHTML = '';
              element.append(content);
            }
          } else {
            element.textContent = content.textContent;
          }

          return;
        }

        if (this._config.html) {
          if (this._config.sanitize) {
            content = sanitizeHtml(content, this._config.allowList, this._config.sanitizeFn);
          }

          element.innerHTML = content;
        } else {
          element.textContent = content;
        }
      }
    }, {
      key: "getTitle",
      value: function getTitle() {
        var title = this._element.getAttribute('data-bs-original-title') || this._config.title;

        return this._resolvePossibleFunction(title);
      }
    }, {
      key: "updateAttachment",
      value: function updateAttachment(attachment) {
        if (attachment === 'right') {
          return 'end';
        }

        if (attachment === 'left') {
          return 'start';
        }

        return attachment;
      } // Private

    }, {
      key: "_initializeOnDelegatedTarget",
      value: function _initializeOnDelegatedTarget(event, context) {
        return context || this.constructor.getOrCreateInstance(event.delegateTarget, this._getDelegateConfig());
      }
    }, {
      key: "_getOffset",
      value: function _getOffset() {
        var _this4 = this;

        var offset = this._config.offset;

        if (typeof offset === 'string') {
          return offset.split(',').map(function (val) {
            return Number.parseInt(val, 10);
          });
        }

        if (typeof offset === 'function') {
          return function (popperData) {
            return offset(popperData, _this4._element);
          };
        }

        return offset;
      }
    }, {
      key: "_resolvePossibleFunction",
      value: function _resolvePossibleFunction(content) {
        return typeof content === 'function' ? content.call(this._element) : content;
      }
    }, {
      key: "_getPopperConfig",
      value: function _getPopperConfig(attachment) {
        var _this5 = this;

        var defaultBsPopperConfig = {
          placement: attachment,
          modifiers: [{
            name: 'flip',
            options: {
              fallbackPlacements: this._config.fallbackPlacements
            }
          }, {
            name: 'offset',
            options: {
              offset: this._getOffset()
            }
          }, {
            name: 'preventOverflow',
            options: {
              boundary: this._config.boundary
            }
          }, {
            name: 'arrow',
            options: {
              element: ".".concat(this.constructor.NAME, "-arrow")
            }
          }, {
            name: 'onChange',
            enabled: true,
            phase: 'afterWrite',
            fn: function fn(data) {
              return _this5._handlePopperPlacementChange(data);
            }
          }],
          onFirstUpdate: function onFirstUpdate(data) {
            if (data.options.placement !== data.placement) {
              _this5._handlePopperPlacementChange(data);
            }
          }
        };
        return _objectSpread(_objectSpread({}, defaultBsPopperConfig), typeof this._config.popperConfig === 'function' ? this._config.popperConfig(defaultBsPopperConfig) : this._config.popperConfig);
      }
    }, {
      key: "_addAttachmentClass",
      value: function _addAttachmentClass(attachment) {
        this.getTipElement().classList.add("".concat(this._getBasicClassPrefix(), "-").concat(this.updateAttachment(attachment)));
      }
    }, {
      key: "_getAttachment",
      value: function _getAttachment(placement) {
        return AttachmentMap[placement.toUpperCase()];
      }
    }, {
      key: "_setListeners",
      value: function _setListeners() {
        var _this6 = this;

        var triggers = this._config.trigger.split(' ');

        triggers.forEach(function (trigger) {
          if (trigger === 'click') {
            EventHandler__default["default"].on(_this6._element, _this6.constructor.Event.CLICK, _this6._config.selector, function (event) {
              return _this6.toggle(event);
            });
          } else if (trigger !== TRIGGER_MANUAL) {
            var eventIn = trigger === TRIGGER_HOVER ? _this6.constructor.Event.MOUSEENTER : _this6.constructor.Event.FOCUSIN;
            var eventOut = trigger === TRIGGER_HOVER ? _this6.constructor.Event.MOUSELEAVE : _this6.constructor.Event.FOCUSOUT;
            EventHandler__default["default"].on(_this6._element, eventIn, _this6._config.selector, function (event) {
              return _this6._enter(event);
            });
            EventHandler__default["default"].on(_this6._element, eventOut, _this6._config.selector, function (event) {
              return _this6._leave(event);
            });
          }
        });

        this._hideModalHandler = function () {
          if (_this6._element) {
            _this6.hide();
          }
        };

        EventHandler__default["default"].on(this._element.closest(SELECTOR_MODAL), EVENT_MODAL_HIDE, this._hideModalHandler);

        if (this._config.selector) {
          this._config = _objectSpread(_objectSpread({}, this._config), {}, {
            trigger: 'manual',
            selector: ''
          });
        } else {
          this._fixTitle();
        }
      }
    }, {
      key: "_fixTitle",
      value: function _fixTitle() {
        var title = this._element.getAttribute('title');

        var originalTitleType = _typeof(this._element.getAttribute('data-bs-original-title'));

        if (title || originalTitleType !== 'string') {
          this._element.setAttribute('data-bs-original-title', title || '');

          if (title && !this._element.getAttribute('aria-label') && !this._element.textContent) {
            this._element.setAttribute('aria-label', title);
          }

          this._element.setAttribute('title', '');
        }
      }
    }, {
      key: "_enter",
      value: function _enter(event, context) {
        context = this._initializeOnDelegatedTarget(event, context);

        if (event) {
          context._activeTrigger[event.type === 'focusin' ? TRIGGER_FOCUS : TRIGGER_HOVER] = true;
        }

        if (context.getTipElement().classList.contains(CLASS_NAME_SHOW) || context._hoverState === HOVER_STATE_SHOW) {
          context._hoverState = HOVER_STATE_SHOW;
          return;
        }

        clearTimeout(context._timeout);
        context._hoverState = HOVER_STATE_SHOW;

        if (!context._config.delay || !context._config.delay.show) {
          context.show();
          return;
        }

        context._timeout = setTimeout(function () {
          if (context._hoverState === HOVER_STATE_SHOW) {
            context.show();
          }
        }, context._config.delay.show);
      }
    }, {
      key: "_leave",
      value: function _leave(event, context) {
        context = this._initializeOnDelegatedTarget(event, context);

        if (event) {
          context._activeTrigger[event.type === 'focusout' ? TRIGGER_FOCUS : TRIGGER_HOVER] = context._element.contains(event.relatedTarget);
        }

        if (context._isWithActiveTrigger()) {
          return;
        }

        clearTimeout(context._timeout);
        context._hoverState = HOVER_STATE_OUT;

        if (!context._config.delay || !context._config.delay.hide) {
          context.hide();
          return;
        }

        context._timeout = setTimeout(function () {
          if (context._hoverState === HOVER_STATE_OUT) {
            context.hide();
          }
        }, context._config.delay.hide);
      }
    }, {
      key: "_isWithActiveTrigger",
      value: function _isWithActiveTrigger() {
        for (var trigger in this._activeTrigger) {
          if (this._activeTrigger[trigger]) {
            return true;
          }
        }

        return false;
      }
    }, {
      key: "_getConfig",
      value: function _getConfig(config) {
        var dataAttributes = Manipulator__default["default"].getDataAttributes(this._element);
        Object.keys(dataAttributes).forEach(function (dataAttr) {
          if (DISALLOWED_ATTRIBUTES.has(dataAttr)) {
            delete dataAttributes[dataAttr];
          }
        });
        config = _objectSpread(_objectSpread(_objectSpread({}, this.constructor.Default), dataAttributes), _typeof(config) === 'object' && config ? config : {});
        config.container = config.container === false ? document.body : getElement(config.container);

        if (typeof config.delay === 'number') {
          config.delay = {
            show: config.delay,
            hide: config.delay
          };
        }

        if (typeof config.title === 'number') {
          config.title = config.title.toString();
        }

        if (typeof config.content === 'number') {
          config.content = config.content.toString();
        }

        typeCheckConfig(NAME, config, this.constructor.DefaultType);

        if (config.sanitize) {
          config.template = sanitizeHtml(config.template, config.allowList, config.sanitizeFn);
        }

        return config;
      }
    }, {
      key: "_getDelegateConfig",
      value: function _getDelegateConfig() {
        var config = {};

        for (var key in this._config) {
          if (this.constructor.Default[key] !== this._config[key]) {
            config[key] = this._config[key];
          }
        } // In the future can be replaced with:
        // const keysWithDifferentValues = Object.entries(this._config).filter(entry => this.constructor.Default[entry[0]] !== this._config[entry[0]])
        // `Object.fromEntries(keysWithDifferentValues)`


        return config;
      }
    }, {
      key: "_cleanTipClass",
      value: function _cleanTipClass() {
        var tip = this.getTipElement();
        var basicClassPrefixRegex = new RegExp("(^|\\s)".concat(this._getBasicClassPrefix(), "\\S+"), 'g');
        var tabClass = tip.getAttribute('class').match(basicClassPrefixRegex);

        if (tabClass !== null && tabClass.length > 0) {
          tabClass.map(function (token) {
            return token.trim();
          }).forEach(function (tClass) {
            return tip.classList.remove(tClass);
          });
        }
      }
    }, {
      key: "_getBasicClassPrefix",
      value: function _getBasicClassPrefix() {
        return CLASS_PREFIX;
      }
    }, {
      key: "_handlePopperPlacementChange",
      value: function _handlePopperPlacementChange(popperData) {
        var state = popperData.state;

        if (!state) {
          return;
        }

        this.tip = state.elements.popper;

        this._cleanTipClass();

        this._addAttachmentClass(this._getAttachment(state.placement));
      }
    }, {
      key: "_disposePopper",
      value: function _disposePopper() {
        if (this._popper) {
          this._popper.destroy();

          this._popper = null;
        }
      } // Static

    }], [{
      key: "Default",
      get: function get() {
        return Default;
      }
    }, {
      key: "NAME",
      get: function get() {
        return NAME;
      }
    }, {
      key: "Event",
      get: function get() {
        return Event;
      }
    }, {
      key: "DefaultType",
      get: function get() {
        return DefaultType;
      }
    }, {
      key: "jQueryInterface",
      value: function jQueryInterface(config) {
        return this.each(function () {
          var data = Tooltip.getOrCreateInstance(this, config);

          if (typeof config === 'string') {
            if (typeof data[config] === 'undefined') {
              throw new TypeError("No method named \"".concat(config, "\""));
            }

            data[config]();
          }
        });
      }
    }]);

    return Tooltip;
  }(BaseComponent__default["default"]);
  /**
   * ------------------------------------------------------------------------
   * jQuery
   * ------------------------------------------------------------------------
   * add .Tooltip to jQuery only if jQuery is present
   */


  defineJQueryPlugin(Tooltip);
  return Tooltip;
});
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _index = require("./util/index");

var _eventHandler = _interopRequireDefault(require("./dom/event-handler"));

var _baseComponent = _interopRequireDefault(require("./base-component"));

var _componentFunctions = require("./util/component-functions");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * ------------------------------------------------------------------------
 * Constants
 * ------------------------------------------------------------------------
 */
var NAME = 'alert';
var DATA_KEY = 'bs.alert';
var EVENT_KEY = ".".concat(DATA_KEY);
var EVENT_CLOSE = "close".concat(EVENT_KEY);
var EVENT_CLOSED = "closed".concat(EVENT_KEY);
var CLASS_NAME_FADE = 'fade';
var CLASS_NAME_SHOW = 'show';
/**
 * ------------------------------------------------------------------------
 * Class Definition
 * ------------------------------------------------------------------------
 */

var Alert = /*#__PURE__*/function (_BaseComponent) {
  _inherits(Alert, _BaseComponent);

  var _super = _createSuper(Alert);

  function Alert() {
    _classCallCheck(this, Alert);

    return _super.apply(this, arguments);
  }

  _createClass(Alert, [{
    key: "close",
    value: // Public
    function close() {
      var _this = this;

      var closeEvent = _eventHandler["default"].trigger(this._element, EVENT_CLOSE);

      if (closeEvent.defaultPrevented) {
        return;
      }

      this._element.classList.remove(CLASS_NAME_SHOW);

      var isAnimated = this._element.classList.contains(CLASS_NAME_FADE);

      this._queueCallback(function () {
        return _this._destroyElement();
      }, this._element, isAnimated);
    } // Private

  }, {
    key: "_destroyElement",
    value: function _destroyElement() {
      this._element.remove();

      _eventHandler["default"].trigger(this._element, EVENT_CLOSED);

      this.dispose();
    } // Static

  }], [{
    key: "NAME",
    get: // Getters
    function get() {
      return NAME;
    }
  }, {
    key: "jQueryInterface",
    value: function jQueryInterface(config) {
      return this.each(function () {
        var data = Alert.getOrCreateInstance(this);

        if (typeof config !== 'string') {
          return;
        }

        if (data[config] === undefined || config.startsWith('_') || config === 'constructor') {
          throw new TypeError("No method named \"".concat(config, "\""));
        }

        data[config](this);
      });
    }
  }]);

  return Alert;
}(_baseComponent["default"]);
/**
 * ------------------------------------------------------------------------
 * Data Api implementation
 * ------------------------------------------------------------------------
 */


(0, _componentFunctions.enableDismissTrigger)(Alert, 'close');
/**
 * ------------------------------------------------------------------------
 * jQuery
 * ------------------------------------------------------------------------
 * add .Alert to jQuery only if jQuery is present
 */

(0, _index.defineJQueryPlugin)(Alert);
var _default = Alert;
exports["default"] = _default;
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _data = _interopRequireDefault(require("./dom/data"));

var _index = require("./util/index");

var _eventHandler = _interopRequireDefault(require("./dom/event-handler"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * ------------------------------------------------------------------------
 * Constants
 * ------------------------------------------------------------------------
 */
var VERSION = '5.1.3';

var BaseComponent = /*#__PURE__*/function () {
  function BaseComponent(element) {
    _classCallCheck(this, BaseComponent);

    element = (0, _index.getElement)(element);

    if (!element) {
      return;
    }

    this._element = element;

    _data["default"].set(this._element, this.constructor.DATA_KEY, this);
  }

  _createClass(BaseComponent, [{
    key: "dispose",
    value: function dispose() {
      var _this = this;

      _data["default"].remove(this._element, this.constructor.DATA_KEY);

      _eventHandler["default"].off(this._element, this.constructor.EVENT_KEY);

      Object.getOwnPropertyNames(this).forEach(function (propertyName) {
        _this[propertyName] = null;
      });
    }
  }, {
    key: "_queueCallback",
    value: function _queueCallback(callback, element) {
      var isAnimated = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      (0, _index.executeAfterTransition)(callback, element, isAnimated);
    }
    /** Static */

  }], [{
    key: "getInstance",
    value: function getInstance(element) {
      return _data["default"].get((0, _index.getElement)(element), this.DATA_KEY);
    }
  }, {
    key: "getOrCreateInstance",
    value: function getOrCreateInstance(element) {
      var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return this.getInstance(element) || new this(element, _typeof(config) === 'object' ? config : null);
    }
  }, {
    key: "VERSION",
    get: function get() {
      return VERSION;
    }
  }, {
    key: "NAME",
    get: function get() {
      throw new Error('You have to implement the static method "NAME", for each component!');
    }
  }, {
    key: "DATA_KEY",
    get: function get() {
      return "bs.".concat(this.NAME);
    }
  }, {
    key: "EVENT_KEY",
    get: function get() {
      return ".".concat(this.DATA_KEY);
    }
  }]);

  return BaseComponent;
}();

var _default = BaseComponent;
exports["default"] = _default;
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _index = require("./util/index");

var _eventHandler = _interopRequireDefault(require("./dom/event-handler"));

var _baseComponent = _interopRequireDefault(require("./base-component"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * ------------------------------------------------------------------------
 * Constants
 * ------------------------------------------------------------------------
 */
var NAME = 'button';
var DATA_KEY = 'bs.button';
var EVENT_KEY = ".".concat(DATA_KEY);
var DATA_API_KEY = '.data-api';
var CLASS_NAME_ACTIVE = 'active';
var SELECTOR_DATA_TOGGLE = '[data-bs-toggle="button"]';
var EVENT_CLICK_DATA_API = "click".concat(EVENT_KEY).concat(DATA_API_KEY);
/**
 * ------------------------------------------------------------------------
 * Class Definition
 * ------------------------------------------------------------------------
 */

var Button = /*#__PURE__*/function (_BaseComponent) {
  _inherits(Button, _BaseComponent);

  var _super = _createSuper(Button);

  function Button() {
    _classCallCheck(this, Button);

    return _super.apply(this, arguments);
  }

  _createClass(Button, [{
    key: "toggle",
    value: // Public
    function toggle() {
      // Toggle class and sync the `aria-pressed` attribute with the return value of the `.toggle()` method
      this._element.setAttribute('aria-pressed', this._element.classList.toggle(CLASS_NAME_ACTIVE));
    } // Static

  }], [{
    key: "NAME",
    get: // Getters
    function get() {
      return NAME;
    }
  }, {
    key: "jQueryInterface",
    value: function jQueryInterface(config) {
      return this.each(function () {
        var data = Button.getOrCreateInstance(this);

        if (config === 'toggle') {
          data[config]();
        }
      });
    }
  }]);

  return Button;
}(_baseComponent["default"]);
/**
 * ------------------------------------------------------------------------
 * Data Api implementation
 * ------------------------------------------------------------------------
 */


_eventHandler["default"].on(document, EVENT_CLICK_DATA_API, SELECTOR_DATA_TOGGLE, function (event) {
  event.preventDefault();
  var button = event.target.closest(SELECTOR_DATA_TOGGLE);
  var data = Button.getOrCreateInstance(button);
  data.toggle();
});
/**
 * ------------------------------------------------------------------------
 * jQuery
 * ------------------------------------------------------------------------
 * add .Button to jQuery only if jQuery is present
 */


(0, _index.defineJQueryPlugin)(Button);
var _default = Button;
exports["default"] = _default;
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _index = require("./util/index");

var _eventHandler = _interopRequireDefault(require("./dom/event-handler"));

var _manipulator = _interopRequireDefault(require("./dom/manipulator"));

var _selectorEngine = _interopRequireDefault(require("./dom/selector-engine"));

var _baseComponent = _interopRequireDefault(require("./base-component"));

var _KEY_TO_DIRECTION;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * ------------------------------------------------------------------------
 * Constants
 * ------------------------------------------------------------------------
 */
var NAME = 'carousel';
var DATA_KEY = 'bs.carousel';
var EVENT_KEY = ".".concat(DATA_KEY);
var DATA_API_KEY = '.data-api';
var ARROW_LEFT_KEY = 'ArrowLeft';
var ARROW_RIGHT_KEY = 'ArrowRight';
var TOUCHEVENT_COMPAT_WAIT = 500; // Time for mouse compat events to fire after touch

var SWIPE_THRESHOLD = 40;
var Default = {
  interval: 5000,
  keyboard: true,
  slide: false,
  pause: 'hover',
  wrap: true,
  touch: true
};
var DefaultType = {
  interval: '(number|boolean)',
  keyboard: 'boolean',
  slide: '(boolean|string)',
  pause: '(string|boolean)',
  wrap: 'boolean',
  touch: 'boolean'
};
var ORDER_NEXT = 'next';
var ORDER_PREV = 'prev';
var DIRECTION_LEFT = 'left';
var DIRECTION_RIGHT = 'right';
var KEY_TO_DIRECTION = (_KEY_TO_DIRECTION = {}, _defineProperty(_KEY_TO_DIRECTION, ARROW_LEFT_KEY, DIRECTION_RIGHT), _defineProperty(_KEY_TO_DIRECTION, ARROW_RIGHT_KEY, DIRECTION_LEFT), _KEY_TO_DIRECTION);
var EVENT_SLIDE = "slide".concat(EVENT_KEY);
var EVENT_SLID = "slid".concat(EVENT_KEY);
var EVENT_KEYDOWN = "keydown".concat(EVENT_KEY);
var EVENT_MOUSEENTER = "mouseenter".concat(EVENT_KEY);
var EVENT_MOUSELEAVE = "mouseleave".concat(EVENT_KEY);
var EVENT_TOUCHSTART = "touchstart".concat(EVENT_KEY);
var EVENT_TOUCHMOVE = "touchmove".concat(EVENT_KEY);
var EVENT_TOUCHEND = "touchend".concat(EVENT_KEY);
var EVENT_POINTERDOWN = "pointerdown".concat(EVENT_KEY);
var EVENT_POINTERUP = "pointerup".concat(EVENT_KEY);
var EVENT_DRAG_START = "dragstart".concat(EVENT_KEY);
var EVENT_LOAD_DATA_API = "load".concat(EVENT_KEY).concat(DATA_API_KEY);
var EVENT_CLICK_DATA_API = "click".concat(EVENT_KEY).concat(DATA_API_KEY);
var CLASS_NAME_CAROUSEL = 'carousel';
var CLASS_NAME_ACTIVE = 'active';
var CLASS_NAME_SLIDE = 'slide';
var CLASS_NAME_END = 'carousel-item-end';
var CLASS_NAME_START = 'carousel-item-start';
var CLASS_NAME_NEXT = 'carousel-item-next';
var CLASS_NAME_PREV = 'carousel-item-prev';
var CLASS_NAME_POINTER_EVENT = 'pointer-event';
var SELECTOR_ACTIVE = '.active';
var SELECTOR_ACTIVE_ITEM = '.active.carousel-item';
var SELECTOR_ITEM = '.carousel-item';
var SELECTOR_ITEM_IMG = '.carousel-item img';
var SELECTOR_NEXT_PREV = '.carousel-item-next, .carousel-item-prev';
var SELECTOR_INDICATORS = '.carousel-indicators';
var SELECTOR_INDICATOR = '[data-bs-target]';
var SELECTOR_DATA_SLIDE = '[data-bs-slide], [data-bs-slide-to]';
var SELECTOR_DATA_RIDE = '[data-bs-ride="carousel"]';
var POINTER_TYPE_TOUCH = 'touch';
var POINTER_TYPE_PEN = 'pen';
/**
 * ------------------------------------------------------------------------
 * Class Definition
 * ------------------------------------------------------------------------
 */

var Carousel = /*#__PURE__*/function (_BaseComponent) {
  _inherits(Carousel, _BaseComponent);

  var _super = _createSuper(Carousel);

  function Carousel(element, config) {
    var _this;

    _classCallCheck(this, Carousel);

    _this = _super.call(this, element);
    _this._items = null;
    _this._interval = null;
    _this._activeElement = null;
    _this._isPaused = false;
    _this._isSliding = false;
    _this.touchTimeout = null;
    _this.touchStartX = 0;
    _this.touchDeltaX = 0;
    _this._config = _this._getConfig(config);
    _this._indicatorsElement = _selectorEngine["default"].findOne(SELECTOR_INDICATORS, _this._element);
    _this._touchSupported = 'ontouchstart' in document.documentElement || navigator.maxTouchPoints > 0;
    _this._pointerEvent = Boolean(window.PointerEvent);

    _this._addEventListeners();

    return _this;
  } // Getters


  _createClass(Carousel, [{
    key: "next",
    value: // Public
    function next() {
      this._slide(ORDER_NEXT);
    }
  }, {
    key: "nextWhenVisible",
    value: function nextWhenVisible() {
      // Don't call next when the page isn't visible
      // or the carousel or its parent isn't visible
      if (!document.hidden && (0, _index.isVisible)(this._element)) {
        this.next();
      }
    }
  }, {
    key: "prev",
    value: function prev() {
      this._slide(ORDER_PREV);
    }
  }, {
    key: "pause",
    value: function pause(event) {
      if (!event) {
        this._isPaused = true;
      }

      if (_selectorEngine["default"].findOne(SELECTOR_NEXT_PREV, this._element)) {
        (0, _index.triggerTransitionEnd)(this._element);
        this.cycle(true);
      }

      clearInterval(this._interval);
      this._interval = null;
    }
  }, {
    key: "cycle",
    value: function cycle(event) {
      if (!event) {
        this._isPaused = false;
      }

      if (this._interval) {
        clearInterval(this._interval);
        this._interval = null;
      }

      if (this._config && this._config.interval && !this._isPaused) {
        this._updateInterval();

        this._interval = setInterval((document.visibilityState ? this.nextWhenVisible : this.next).bind(this), this._config.interval);
      }
    }
  }, {
    key: "to",
    value: function to(index) {
      var _this2 = this;

      this._activeElement = _selectorEngine["default"].findOne(SELECTOR_ACTIVE_ITEM, this._element);

      var activeIndex = this._getItemIndex(this._activeElement);

      if (index > this._items.length - 1 || index < 0) {
        return;
      }

      if (this._isSliding) {
        _eventHandler["default"].one(this._element, EVENT_SLID, function () {
          return _this2.to(index);
        });

        return;
      }

      if (activeIndex === index) {
        this.pause();
        this.cycle();
        return;
      }

      var order = index > activeIndex ? ORDER_NEXT : ORDER_PREV;

      this._slide(order, this._items[index]);
    } // Private

  }, {
    key: "_getConfig",
    value: function _getConfig(config) {
      config = _objectSpread(_objectSpread(_objectSpread({}, Default), _manipulator["default"].getDataAttributes(this._element)), _typeof(config) === 'object' ? config : {});
      (0, _index.typeCheckConfig)(NAME, config, DefaultType);
      return config;
    }
  }, {
    key: "_handleSwipe",
    value: function _handleSwipe() {
      var absDeltax = Math.abs(this.touchDeltaX);

      if (absDeltax <= SWIPE_THRESHOLD) {
        return;
      }

      var direction = absDeltax / this.touchDeltaX;
      this.touchDeltaX = 0;

      if (!direction) {
        return;
      }

      this._slide(direction > 0 ? DIRECTION_RIGHT : DIRECTION_LEFT);
    }
  }, {
    key: "_addEventListeners",
    value: function _addEventListeners() {
      var _this3 = this;

      if (this._config.keyboard) {
        _eventHandler["default"].on(this._element, EVENT_KEYDOWN, function (event) {
          return _this3._keydown(event);
        });
      }

      if (this._config.pause === 'hover') {
        _eventHandler["default"].on(this._element, EVENT_MOUSEENTER, function (event) {
          return _this3.pause(event);
        });

        _eventHandler["default"].on(this._element, EVENT_MOUSELEAVE, function (event) {
          return _this3.cycle(event);
        });
      }

      if (this._config.touch && this._touchSupported) {
        this._addTouchEventListeners();
      }
    }
  }, {
    key: "_addTouchEventListeners",
    value: function _addTouchEventListeners() {
      var _this4 = this;

      var hasPointerPenTouch = function hasPointerPenTouch(event) {
        return _this4._pointerEvent && (event.pointerType === POINTER_TYPE_PEN || event.pointerType === POINTER_TYPE_TOUCH);
      };

      var start = function start(event) {
        if (hasPointerPenTouch(event)) {
          _this4.touchStartX = event.clientX;
        } else if (!_this4._pointerEvent) {
          _this4.touchStartX = event.touches[0].clientX;
        }
      };

      var move = function move(event) {
        // ensure swiping with one touch and not pinching
        _this4.touchDeltaX = event.touches && event.touches.length > 1 ? 0 : event.touches[0].clientX - _this4.touchStartX;
      };

      var end = function end(event) {
        if (hasPointerPenTouch(event)) {
          _this4.touchDeltaX = event.clientX - _this4.touchStartX;
        }

        _this4._handleSwipe();

        if (_this4._config.pause === 'hover') {
          // If it's a touch-enabled device, mouseenter/leave are fired as
          // part of the mouse compatibility events on first tap - the carousel
          // would stop cycling until user tapped out of it;
          // here, we listen for touchend, explicitly pause the carousel
          // (as if it's the second time we tap on it, mouseenter compat event
          // is NOT fired) and after a timeout (to allow for mouse compatibility
          // events to fire) we explicitly restart cycling
          _this4.pause();

          if (_this4.touchTimeout) {
            clearTimeout(_this4.touchTimeout);
          }

          _this4.touchTimeout = setTimeout(function (event) {
            return _this4.cycle(event);
          }, TOUCHEVENT_COMPAT_WAIT + _this4._config.interval);
        }
      };

      _selectorEngine["default"].find(SELECTOR_ITEM_IMG, this._element).forEach(function (itemImg) {
        _eventHandler["default"].on(itemImg, EVENT_DRAG_START, function (event) {
          return event.preventDefault();
        });
      });

      if (this._pointerEvent) {
        _eventHandler["default"].on(this._element, EVENT_POINTERDOWN, function (event) {
          return start(event);
        });

        _eventHandler["default"].on(this._element, EVENT_POINTERUP, function (event) {
          return end(event);
        });

        this._element.classList.add(CLASS_NAME_POINTER_EVENT);
      } else {
        _eventHandler["default"].on(this._element, EVENT_TOUCHSTART, function (event) {
          return start(event);
        });

        _eventHandler["default"].on(this._element, EVENT_TOUCHMOVE, function (event) {
          return move(event);
        });

        _eventHandler["default"].on(this._element, EVENT_TOUCHEND, function (event) {
          return end(event);
        });
      }
    }
  }, {
    key: "_keydown",
    value: function _keydown(event) {
      if (/input|textarea/i.test(event.target.tagName)) {
        return;
      }

      var direction = KEY_TO_DIRECTION[event.key];

      if (direction) {
        event.preventDefault();

        this._slide(direction);
      }
    }
  }, {
    key: "_getItemIndex",
    value: function _getItemIndex(element) {
      this._items = element && element.parentNode ? _selectorEngine["default"].find(SELECTOR_ITEM, element.parentNode) : [];
      return this._items.indexOf(element);
    }
  }, {
    key: "_getItemByOrder",
    value: function _getItemByOrder(order, activeElement) {
      var isNext = order === ORDER_NEXT;
      return (0, _index.getNextActiveElement)(this._items, activeElement, isNext, this._config.wrap);
    }
  }, {
    key: "_triggerSlideEvent",
    value: function _triggerSlideEvent(relatedTarget, eventDirectionName) {
      var targetIndex = this._getItemIndex(relatedTarget);

      var fromIndex = this._getItemIndex(_selectorEngine["default"].findOne(SELECTOR_ACTIVE_ITEM, this._element));

      return _eventHandler["default"].trigger(this._element, EVENT_SLIDE, {
        relatedTarget: relatedTarget,
        direction: eventDirectionName,
        from: fromIndex,
        to: targetIndex
      });
    }
  }, {
    key: "_setActiveIndicatorElement",
    value: function _setActiveIndicatorElement(element) {
      if (this._indicatorsElement) {
        var activeIndicator = _selectorEngine["default"].findOne(SELECTOR_ACTIVE, this._indicatorsElement);

        activeIndicator.classList.remove(CLASS_NAME_ACTIVE);
        activeIndicator.removeAttribute('aria-current');

        var indicators = _selectorEngine["default"].find(SELECTOR_INDICATOR, this._indicatorsElement);

        for (var i = 0; i < indicators.length; i++) {
          if (Number.parseInt(indicators[i].getAttribute('data-bs-slide-to'), 10) === this._getItemIndex(element)) {
            indicators[i].classList.add(CLASS_NAME_ACTIVE);
            indicators[i].setAttribute('aria-current', 'true');
            break;
          }
        }
      }
    }
  }, {
    key: "_updateInterval",
    value: function _updateInterval() {
      var element = this._activeElement || _selectorEngine["default"].findOne(SELECTOR_ACTIVE_ITEM, this._element);

      if (!element) {
        return;
      }

      var elementInterval = Number.parseInt(element.getAttribute('data-bs-interval'), 10);

      if (elementInterval) {
        this._config.defaultInterval = this._config.defaultInterval || this._config.interval;
        this._config.interval = elementInterval;
      } else {
        this._config.interval = this._config.defaultInterval || this._config.interval;
      }
    }
  }, {
    key: "_slide",
    value: function _slide(directionOrOrder, element) {
      var _this5 = this;

      var order = this._directionToOrder(directionOrOrder);

      var activeElement = _selectorEngine["default"].findOne(SELECTOR_ACTIVE_ITEM, this._element);

      var activeElementIndex = this._getItemIndex(activeElement);

      var nextElement = element || this._getItemByOrder(order, activeElement);

      var nextElementIndex = this._getItemIndex(nextElement);

      var isCycling = Boolean(this._interval);
      var isNext = order === ORDER_NEXT;
      var directionalClassName = isNext ? CLASS_NAME_START : CLASS_NAME_END;
      var orderClassName = isNext ? CLASS_NAME_NEXT : CLASS_NAME_PREV;

      var eventDirectionName = this._orderToDirection(order);

      if (nextElement && nextElement.classList.contains(CLASS_NAME_ACTIVE)) {
        this._isSliding = false;
        return;
      }

      if (this._isSliding) {
        return;
      }

      var slideEvent = this._triggerSlideEvent(nextElement, eventDirectionName);

      if (slideEvent.defaultPrevented) {
        return;
      }

      if (!activeElement || !nextElement) {
        // Some weirdness is happening, so we bail
        return;
      }

      this._isSliding = true;

      if (isCycling) {
        this.pause();
      }

      this._setActiveIndicatorElement(nextElement);

      this._activeElement = nextElement;

      var triggerSlidEvent = function triggerSlidEvent() {
        _eventHandler["default"].trigger(_this5._element, EVENT_SLID, {
          relatedTarget: nextElement,
          direction: eventDirectionName,
          from: activeElementIndex,
          to: nextElementIndex
        });
      };

      if (this._element.classList.contains(CLASS_NAME_SLIDE)) {
        nextElement.classList.add(orderClassName);
        (0, _index.reflow)(nextElement);
        activeElement.classList.add(directionalClassName);
        nextElement.classList.add(directionalClassName);

        var completeCallBack = function completeCallBack() {
          nextElement.classList.remove(directionalClassName, orderClassName);
          nextElement.classList.add(CLASS_NAME_ACTIVE);
          activeElement.classList.remove(CLASS_NAME_ACTIVE, orderClassName, directionalClassName);
          _this5._isSliding = false;
          setTimeout(triggerSlidEvent, 0);
        };

        this._queueCallback(completeCallBack, activeElement, true);
      } else {
        activeElement.classList.remove(CLASS_NAME_ACTIVE);
        nextElement.classList.add(CLASS_NAME_ACTIVE);
        this._isSliding = false;
        triggerSlidEvent();
      }

      if (isCycling) {
        this.cycle();
      }
    }
  }, {
    key: "_directionToOrder",
    value: function _directionToOrder(direction) {
      if (![DIRECTION_RIGHT, DIRECTION_LEFT].includes(direction)) {
        return direction;
      }

      if ((0, _index.isRTL)()) {
        return direction === DIRECTION_LEFT ? ORDER_PREV : ORDER_NEXT;
      }

      return direction === DIRECTION_LEFT ? ORDER_NEXT : ORDER_PREV;
    }
  }, {
    key: "_orderToDirection",
    value: function _orderToDirection(order) {
      if (![ORDER_NEXT, ORDER_PREV].includes(order)) {
        return order;
      }

      if ((0, _index.isRTL)()) {
        return order === ORDER_PREV ? DIRECTION_LEFT : DIRECTION_RIGHT;
      }

      return order === ORDER_PREV ? DIRECTION_RIGHT : DIRECTION_LEFT;
    } // Static

  }], [{
    key: "Default",
    get: function get() {
      return Default;
    }
  }, {
    key: "NAME",
    get: function get() {
      return NAME;
    }
  }, {
    key: "carouselInterface",
    value: function carouselInterface(element, config) {
      var data = Carousel.getOrCreateInstance(element, config);
      var _config = data._config;

      if (_typeof(config) === 'object') {
        _config = _objectSpread(_objectSpread({}, _config), config);
      }

      var action = typeof config === 'string' ? config : _config.slide;

      if (typeof config === 'number') {
        data.to(config);
      } else if (typeof action === 'string') {
        if (typeof data[action] === 'undefined') {
          throw new TypeError("No method named \"".concat(action, "\""));
        }

        data[action]();
      } else if (_config.interval && _config.ride) {
        data.pause();
        data.cycle();
      }
    }
  }, {
    key: "jQueryInterface",
    value: function jQueryInterface(config) {
      return this.each(function () {
        Carousel.carouselInterface(this, config);
      });
    }
  }, {
    key: "dataApiClickHandler",
    value: function dataApiClickHandler(event) {
      var target = (0, _index.getElementFromSelector)(this);

      if (!target || !target.classList.contains(CLASS_NAME_CAROUSEL)) {
        return;
      }

      var config = _objectSpread(_objectSpread({}, _manipulator["default"].getDataAttributes(target)), _manipulator["default"].getDataAttributes(this));

      var slideIndex = this.getAttribute('data-bs-slide-to');

      if (slideIndex) {
        config.interval = false;
      }

      Carousel.carouselInterface(target, config);

      if (slideIndex) {
        Carousel.getInstance(target).to(slideIndex);
      }

      event.preventDefault();
    }
  }]);

  return Carousel;
}(_baseComponent["default"]);
/**
 * ------------------------------------------------------------------------
 * Data Api implementation
 * ------------------------------------------------------------------------
 */


_eventHandler["default"].on(document, EVENT_CLICK_DATA_API, SELECTOR_DATA_SLIDE, Carousel.dataApiClickHandler);

_eventHandler["default"].on(window, EVENT_LOAD_DATA_API, function () {
  var carousels = _selectorEngine["default"].find(SELECTOR_DATA_RIDE);

  for (var i = 0, len = carousels.length; i < len; i++) {
    Carousel.carouselInterface(carousels[i], Carousel.getInstance(carousels[i]));
  }
});
/**
 * ------------------------------------------------------------------------
 * jQuery
 * ------------------------------------------------------------------------
 * add .Carousel to jQuery only if jQuery is present
 */


(0, _index.defineJQueryPlugin)(Carousel);
var _default = Carousel;
exports["default"] = _default;
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _index = require("./util/index");

var _data = _interopRequireDefault(require("./dom/data"));

var _eventHandler = _interopRequireDefault(require("./dom/event-handler"));

var _manipulator = _interopRequireDefault(require("./dom/manipulator"));

var _selectorEngine = _interopRequireDefault(require("./dom/selector-engine"));

var _baseComponent = _interopRequireDefault(require("./base-component"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * ------------------------------------------------------------------------
 * Constants
 * ------------------------------------------------------------------------
 */
var NAME = 'collapse';
var DATA_KEY = 'bs.collapse';
var EVENT_KEY = ".".concat(DATA_KEY);
var DATA_API_KEY = '.data-api';
var Default = {
  toggle: true,
  parent: null
};
var DefaultType = {
  toggle: 'boolean',
  parent: '(null|element)'
};
var EVENT_SHOW = "show".concat(EVENT_KEY);
var EVENT_SHOWN = "shown".concat(EVENT_KEY);
var EVENT_HIDE = "hide".concat(EVENT_KEY);
var EVENT_HIDDEN = "hidden".concat(EVENT_KEY);
var EVENT_CLICK_DATA_API = "click".concat(EVENT_KEY).concat(DATA_API_KEY);
var CLASS_NAME_SHOW = 'show';
var CLASS_NAME_COLLAPSE = 'collapse';
var CLASS_NAME_COLLAPSING = 'collapsing';
var CLASS_NAME_COLLAPSED = 'collapsed';
var CLASS_NAME_DEEPER_CHILDREN = ":scope .".concat(CLASS_NAME_COLLAPSE, " .").concat(CLASS_NAME_COLLAPSE);
var CLASS_NAME_HORIZONTAL = 'collapse-horizontal';
var WIDTH = 'width';
var HEIGHT = 'height';
var SELECTOR_ACTIVES = '.collapse.show, .collapse.collapsing';
var SELECTOR_DATA_TOGGLE = '[data-bs-toggle="collapse"]';
/**
 * ------------------------------------------------------------------------
 * Class Definition
 * ------------------------------------------------------------------------
 */

var Collapse = /*#__PURE__*/function (_BaseComponent) {
  _inherits(Collapse, _BaseComponent);

  var _super = _createSuper(Collapse);

  function Collapse(element, config) {
    var _this;

    _classCallCheck(this, Collapse);

    _this = _super.call(this, element);
    _this._isTransitioning = false;
    _this._config = _this._getConfig(config);
    _this._triggerArray = [];

    var toggleList = _selectorEngine["default"].find(SELECTOR_DATA_TOGGLE);

    for (var i = 0, len = toggleList.length; i < len; i++) {
      var elem = toggleList[i];
      var selector = (0, _index.getSelectorFromElement)(elem);

      var filterElement = _selectorEngine["default"].find(selector).filter(function (foundElem) {
        return foundElem === _this._element;
      });

      if (selector !== null && filterElement.length) {
        _this._selector = selector;

        _this._triggerArray.push(elem);
      }
    }

    _this._initializeChildren();

    if (!_this._config.parent) {
      _this._addAriaAndCollapsedClass(_this._triggerArray, _this._isShown());
    }

    if (_this._config.toggle) {
      _this.toggle();
    }

    return _this;
  } // Getters


  _createClass(Collapse, [{
    key: "toggle",
    value: // Public
    function toggle() {
      if (this._isShown()) {
        this.hide();
      } else {
        this.show();
      }
    }
  }, {
    key: "show",
    value: function show() {
      var _this2 = this;

      if (this._isTransitioning || this._isShown()) {
        return;
      }

      var actives = [];
      var activesData;

      if (this._config.parent) {
        var children = _selectorEngine["default"].find(CLASS_NAME_DEEPER_CHILDREN, this._config.parent);

        actives = _selectorEngine["default"].find(SELECTOR_ACTIVES, this._config.parent).filter(function (elem) {
          return !children.includes(elem);
        }); // remove children if greater depth
      }

      var container = _selectorEngine["default"].findOne(this._selector);

      if (actives.length) {
        var tempActiveData = actives.find(function (elem) {
          return container !== elem;
        });
        activesData = tempActiveData ? Collapse.getInstance(tempActiveData) : null;

        if (activesData && activesData._isTransitioning) {
          return;
        }
      }

      var startEvent = _eventHandler["default"].trigger(this._element, EVENT_SHOW);

      if (startEvent.defaultPrevented) {
        return;
      }

      actives.forEach(function (elemActive) {
        if (container !== elemActive) {
          Collapse.getOrCreateInstance(elemActive, {
            toggle: false
          }).hide();
        }

        if (!activesData) {
          _data["default"].set(elemActive, DATA_KEY, null);
        }
      });

      var dimension = this._getDimension();

      this._element.classList.remove(CLASS_NAME_COLLAPSE);

      this._element.classList.add(CLASS_NAME_COLLAPSING);

      this._element.style[dimension] = 0;

      this._addAriaAndCollapsedClass(this._triggerArray, true);

      this._isTransitioning = true;

      var complete = function complete() {
        _this2._isTransitioning = false;

        _this2._element.classList.remove(CLASS_NAME_COLLAPSING);

        _this2._element.classList.add(CLASS_NAME_COLLAPSE, CLASS_NAME_SHOW);

        _this2._element.style[dimension] = '';

        _eventHandler["default"].trigger(_this2._element, EVENT_SHOWN);
      };

      var capitalizedDimension = dimension[0].toUpperCase() + dimension.slice(1);
      var scrollSize = "scroll".concat(capitalizedDimension);

      this._queueCallback(complete, this._element, true);

      this._element.style[dimension] = "".concat(this._element[scrollSize], "px");
    }
  }, {
    key: "hide",
    value: function hide() {
      var _this3 = this;

      if (this._isTransitioning || !this._isShown()) {
        return;
      }

      var startEvent = _eventHandler["default"].trigger(this._element, EVENT_HIDE);

      if (startEvent.defaultPrevented) {
        return;
      }

      var dimension = this._getDimension();

      this._element.style[dimension] = "".concat(this._element.getBoundingClientRect()[dimension], "px");
      (0, _index.reflow)(this._element);

      this._element.classList.add(CLASS_NAME_COLLAPSING);

      this._element.classList.remove(CLASS_NAME_COLLAPSE, CLASS_NAME_SHOW);

      var triggerArrayLength = this._triggerArray.length;

      for (var i = 0; i < triggerArrayLength; i++) {
        var trigger = this._triggerArray[i];
        var elem = (0, _index.getElementFromSelector)(trigger);

        if (elem && !this._isShown(elem)) {
          this._addAriaAndCollapsedClass([trigger], false);
        }
      }

      this._isTransitioning = true;

      var complete = function complete() {
        _this3._isTransitioning = false;

        _this3._element.classList.remove(CLASS_NAME_COLLAPSING);

        _this3._element.classList.add(CLASS_NAME_COLLAPSE);

        _eventHandler["default"].trigger(_this3._element, EVENT_HIDDEN);
      };

      this._element.style[dimension] = '';

      this._queueCallback(complete, this._element, true);
    }
  }, {
    key: "_isShown",
    value: function _isShown() {
      var element = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._element;
      return element.classList.contains(CLASS_NAME_SHOW);
    } // Private

  }, {
    key: "_getConfig",
    value: function _getConfig(config) {
      config = _objectSpread(_objectSpread(_objectSpread({}, Default), _manipulator["default"].getDataAttributes(this._element)), config);
      config.toggle = Boolean(config.toggle); // Coerce string values

      config.parent = (0, _index.getElement)(config.parent);
      (0, _index.typeCheckConfig)(NAME, config, DefaultType);
      return config;
    }
  }, {
    key: "_getDimension",
    value: function _getDimension() {
      return this._element.classList.contains(CLASS_NAME_HORIZONTAL) ? WIDTH : HEIGHT;
    }
  }, {
    key: "_initializeChildren",
    value: function _initializeChildren() {
      var _this4 = this;

      if (!this._config.parent) {
        return;
      }

      var children = _selectorEngine["default"].find(CLASS_NAME_DEEPER_CHILDREN, this._config.parent);

      _selectorEngine["default"].find(SELECTOR_DATA_TOGGLE, this._config.parent).filter(function (elem) {
        return !children.includes(elem);
      }).forEach(function (element) {
        var selected = (0, _index.getElementFromSelector)(element);

        if (selected) {
          _this4._addAriaAndCollapsedClass([element], _this4._isShown(selected));
        }
      });
    }
  }, {
    key: "_addAriaAndCollapsedClass",
    value: function _addAriaAndCollapsedClass(triggerArray, isOpen) {
      if (!triggerArray.length) {
        return;
      }

      triggerArray.forEach(function (elem) {
        if (isOpen) {
          elem.classList.remove(CLASS_NAME_COLLAPSED);
        } else {
          elem.classList.add(CLASS_NAME_COLLAPSED);
        }

        elem.setAttribute('aria-expanded', isOpen);
      });
    } // Static

  }], [{
    key: "Default",
    get: function get() {
      return Default;
    }
  }, {
    key: "NAME",
    get: function get() {
      return NAME;
    }
  }, {
    key: "jQueryInterface",
    value: function jQueryInterface(config) {
      return this.each(function () {
        var _config = {};

        if (typeof config === 'string' && /show|hide/.test(config)) {
          _config.toggle = false;
        }

        var data = Collapse.getOrCreateInstance(this, _config);

        if (typeof config === 'string') {
          if (typeof data[config] === 'undefined') {
            throw new TypeError("No method named \"".concat(config, "\""));
          }

          data[config]();
        }
      });
    }
  }]);

  return Collapse;
}(_baseComponent["default"]);
/**
 * ------------------------------------------------------------------------
 * Data Api implementation
 * ------------------------------------------------------------------------
 */


_eventHandler["default"].on(document, EVENT_CLICK_DATA_API, SELECTOR_DATA_TOGGLE, function (event) {
  // preventDefault only for <a> elements (which change the URL) not inside the collapsible element
  if (event.target.tagName === 'A' || event.delegateTarget && event.delegateTarget.tagName === 'A') {
    event.preventDefault();
  }

  var selector = (0, _index.getSelectorFromElement)(this);

  var selectorElements = _selectorEngine["default"].find(selector);

  selectorElements.forEach(function (element) {
    Collapse.getOrCreateInstance(element, {
      toggle: false
    }).toggle();
  });
});
/**
 * ------------------------------------------------------------------------
 * jQuery
 * ------------------------------------------------------------------------
 * add .Collapse to jQuery only if jQuery is present
 */


(0, _index.defineJQueryPlugin)(Collapse);
var _default = Collapse;
exports["default"] = _default;
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var Popper = _interopRequireWildcard(require("@popperjs/core"));

var _index = require("./util/index");

var _eventHandler = _interopRequireDefault(require("./dom/event-handler"));

var _manipulator = _interopRequireDefault(require("./dom/manipulator"));

var _selectorEngine = _interopRequireDefault(require("./dom/selector-engine"));

var _baseComponent = _interopRequireDefault(require("./base-component"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * ------------------------------------------------------------------------
 * Constants
 * ------------------------------------------------------------------------
 */
var NAME = 'dropdown';
var DATA_KEY = 'bs.dropdown';
var EVENT_KEY = ".".concat(DATA_KEY);
var DATA_API_KEY = '.data-api';
var ESCAPE_KEY = 'Escape';
var SPACE_KEY = 'Space';
var TAB_KEY = 'Tab';
var ARROW_UP_KEY = 'ArrowUp';
var ARROW_DOWN_KEY = 'ArrowDown';
var RIGHT_MOUSE_BUTTON = 2; // MouseEvent.button value for the secondary button, usually the right button

var REGEXP_KEYDOWN = new RegExp("".concat(ARROW_UP_KEY, "|").concat(ARROW_DOWN_KEY, "|").concat(ESCAPE_KEY));
var EVENT_HIDE = "hide".concat(EVENT_KEY);
var EVENT_HIDDEN = "hidden".concat(EVENT_KEY);
var EVENT_SHOW = "show".concat(EVENT_KEY);
var EVENT_SHOWN = "shown".concat(EVENT_KEY);
var EVENT_CLICK_DATA_API = "click".concat(EVENT_KEY).concat(DATA_API_KEY);
var EVENT_KEYDOWN_DATA_API = "keydown".concat(EVENT_KEY).concat(DATA_API_KEY);
var EVENT_KEYUP_DATA_API = "keyup".concat(EVENT_KEY).concat(DATA_API_KEY);
var CLASS_NAME_SHOW = 'show';
var CLASS_NAME_DROPUP = 'dropup';
var CLASS_NAME_DROPEND = 'dropend';
var CLASS_NAME_DROPSTART = 'dropstart';
var CLASS_NAME_NAVBAR = 'navbar';
var SELECTOR_DATA_TOGGLE = '[data-bs-toggle="dropdown"]';
var SELECTOR_MENU = '.dropdown-menu';
var SELECTOR_NAVBAR_NAV = '.navbar-nav';
var SELECTOR_VISIBLE_ITEMS = '.dropdown-menu .dropdown-item:not(.disabled):not(:disabled)';
var PLACEMENT_TOP = (0, _index.isRTL)() ? 'top-end' : 'top-start';
var PLACEMENT_TOPEND = (0, _index.isRTL)() ? 'top-start' : 'top-end';
var PLACEMENT_BOTTOM = (0, _index.isRTL)() ? 'bottom-end' : 'bottom-start';
var PLACEMENT_BOTTOMEND = (0, _index.isRTL)() ? 'bottom-start' : 'bottom-end';
var PLACEMENT_RIGHT = (0, _index.isRTL)() ? 'left-start' : 'right-start';
var PLACEMENT_LEFT = (0, _index.isRTL)() ? 'right-start' : 'left-start';
var Default = {
  offset: [0, 2],
  boundary: 'clippingParents',
  reference: 'toggle',
  display: 'dynamic',
  popperConfig: null,
  autoClose: true
};
var DefaultType = {
  offset: '(array|string|function)',
  boundary: '(string|element)',
  reference: '(string|element|object)',
  display: 'string',
  popperConfig: '(null|object|function)',
  autoClose: '(boolean|string)'
};
/**
 * ------------------------------------------------------------------------
 * Class Definition
 * ------------------------------------------------------------------------
 */

var Dropdown = /*#__PURE__*/function (_BaseComponent) {
  _inherits(Dropdown, _BaseComponent);

  var _super = _createSuper(Dropdown);

  function Dropdown(element, config) {
    var _this;

    _classCallCheck(this, Dropdown);

    _this = _super.call(this, element);
    _this._popper = null;
    _this._config = _this._getConfig(config);
    _this._menu = _this._getMenuElement();
    _this._inNavbar = _this._detectNavbar();
    return _this;
  } // Getters


  _createClass(Dropdown, [{
    key: "toggle",
    value: // Public
    function toggle() {
      return this._isShown() ? this.hide() : this.show();
    }
  }, {
    key: "show",
    value: function show() {
      if ((0, _index.isDisabled)(this._element) || this._isShown(this._menu)) {
        return;
      }

      var relatedTarget = {
        relatedTarget: this._element
      };

      var showEvent = _eventHandler["default"].trigger(this._element, EVENT_SHOW, relatedTarget);

      if (showEvent.defaultPrevented) {
        return;
      }

      var parent = Dropdown.getParentFromElement(this._element); // Totally disable Popper for Dropdowns in Navbar

      if (this._inNavbar) {
        _manipulator["default"].setDataAttribute(this._menu, 'popper', 'none');
      } else {
        this._createPopper(parent);
      } // If this is a touch-enabled device we add extra
      // empty mouseover listeners to the body's immediate children;
      // only needed because of broken event delegation on iOS
      // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html


      if ('ontouchstart' in document.documentElement && !parent.closest(SELECTOR_NAVBAR_NAV)) {
        var _ref;

        (_ref = []).concat.apply(_ref, _toConsumableArray(document.body.children)).forEach(function (elem) {
          return _eventHandler["default"].on(elem, 'mouseover', _index.noop);
        });
      }

      this._element.focus();

      this._element.setAttribute('aria-expanded', true);

      this._menu.classList.add(CLASS_NAME_SHOW);

      this._element.classList.add(CLASS_NAME_SHOW);

      _eventHandler["default"].trigger(this._element, EVENT_SHOWN, relatedTarget);
    }
  }, {
    key: "hide",
    value: function hide() {
      if ((0, _index.isDisabled)(this._element) || !this._isShown(this._menu)) {
        return;
      }

      var relatedTarget = {
        relatedTarget: this._element
      };

      this._completeHide(relatedTarget);
    }
  }, {
    key: "dispose",
    value: function dispose() {
      if (this._popper) {
        this._popper.destroy();
      }

      _get(_getPrototypeOf(Dropdown.prototype), "dispose", this).call(this);
    }
  }, {
    key: "update",
    value: function update() {
      this._inNavbar = this._detectNavbar();

      if (this._popper) {
        this._popper.update();
      }
    } // Private

  }, {
    key: "_completeHide",
    value: function _completeHide(relatedTarget) {
      var hideEvent = _eventHandler["default"].trigger(this._element, EVENT_HIDE, relatedTarget);

      if (hideEvent.defaultPrevented) {
        return;
      } // If this is a touch-enabled device we remove the extra
      // empty mouseover listeners we added for iOS support


      if ('ontouchstart' in document.documentElement) {
        var _ref2;

        (_ref2 = []).concat.apply(_ref2, _toConsumableArray(document.body.children)).forEach(function (elem) {
          return _eventHandler["default"].off(elem, 'mouseover', _index.noop);
        });
      }

      if (this._popper) {
        this._popper.destroy();
      }

      this._menu.classList.remove(CLASS_NAME_SHOW);

      this._element.classList.remove(CLASS_NAME_SHOW);

      this._element.setAttribute('aria-expanded', 'false');

      _manipulator["default"].removeDataAttribute(this._menu, 'popper');

      _eventHandler["default"].trigger(this._element, EVENT_HIDDEN, relatedTarget);
    }
  }, {
    key: "_getConfig",
    value: function _getConfig(config) {
      config = _objectSpread(_objectSpread(_objectSpread({}, this.constructor.Default), _manipulator["default"].getDataAttributes(this._element)), config);
      (0, _index.typeCheckConfig)(NAME, config, this.constructor.DefaultType);

      if (_typeof(config.reference) === 'object' && !(0, _index.isElement)(config.reference) && typeof config.reference.getBoundingClientRect !== 'function') {
        // Popper virtual elements require a getBoundingClientRect method
        throw new TypeError("".concat(NAME.toUpperCase(), ": Option \"reference\" provided type \"object\" without a required \"getBoundingClientRect\" method."));
      }

      return config;
    }
  }, {
    key: "_createPopper",
    value: function _createPopper(parent) {
      if (typeof Popper === 'undefined') {
        throw new TypeError('Bootstrap\'s dropdowns require Popper (https://popper.js.org)');
      }

      var referenceElement = this._element;

      if (this._config.reference === 'parent') {
        referenceElement = parent;
      } else if ((0, _index.isElement)(this._config.reference)) {
        referenceElement = (0, _index.getElement)(this._config.reference);
      } else if (_typeof(this._config.reference) === 'object') {
        referenceElement = this._config.reference;
      }

      var popperConfig = this._getPopperConfig();

      var isDisplayStatic = popperConfig.modifiers.find(function (modifier) {
        return modifier.name === 'applyStyles' && modifier.enabled === false;
      });
      this._popper = Popper.createPopper(referenceElement, this._menu, popperConfig);

      if (isDisplayStatic) {
        _manipulator["default"].setDataAttribute(this._menu, 'popper', 'static');
      }
    }
  }, {
    key: "_isShown",
    value: function _isShown() {
      var element = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._element;
      return element.classList.contains(CLASS_NAME_SHOW);
    }
  }, {
    key: "_getMenuElement",
    value: function _getMenuElement() {
      return _selectorEngine["default"].next(this._element, SELECTOR_MENU)[0];
    }
  }, {
    key: "_getPlacement",
    value: function _getPlacement() {
      var parentDropdown = this._element.parentNode;

      if (parentDropdown.classList.contains(CLASS_NAME_DROPEND)) {
        return PLACEMENT_RIGHT;
      }

      if (parentDropdown.classList.contains(CLASS_NAME_DROPSTART)) {
        return PLACEMENT_LEFT;
      } // We need to trim the value because custom properties can also include spaces


      var isEnd = getComputedStyle(this._menu).getPropertyValue('--bs-position').trim() === 'end';

      if (parentDropdown.classList.contains(CLASS_NAME_DROPUP)) {
        return isEnd ? PLACEMENT_TOPEND : PLACEMENT_TOP;
      }

      return isEnd ? PLACEMENT_BOTTOMEND : PLACEMENT_BOTTOM;
    }
  }, {
    key: "_detectNavbar",
    value: function _detectNavbar() {
      return this._element.closest(".".concat(CLASS_NAME_NAVBAR)) !== null;
    }
  }, {
    key: "_getOffset",
    value: function _getOffset() {
      var _this2 = this;

      var offset = this._config.offset;

      if (typeof offset === 'string') {
        return offset.split(',').map(function (val) {
          return Number.parseInt(val, 10);
        });
      }

      if (typeof offset === 'function') {
        return function (popperData) {
          return offset(popperData, _this2._element);
        };
      }

      return offset;
    }
  }, {
    key: "_getPopperConfig",
    value: function _getPopperConfig() {
      var defaultBsPopperConfig = {
        placement: this._getPlacement(),
        modifiers: [{
          name: 'preventOverflow',
          options: {
            boundary: this._config.boundary
          }
        }, {
          name: 'offset',
          options: {
            offset: this._getOffset()
          }
        }]
      }; // Disable Popper if we have a static display

      if (this._config.display === 'static') {
        defaultBsPopperConfig.modifiers = [{
          name: 'applyStyles',
          enabled: false
        }];
      }

      return _objectSpread(_objectSpread({}, defaultBsPopperConfig), typeof this._config.popperConfig === 'function' ? this._config.popperConfig(defaultBsPopperConfig) : this._config.popperConfig);
    }
  }, {
    key: "_selectMenuItem",
    value: function _selectMenuItem(_ref3) {
      var key = _ref3.key,
          target = _ref3.target;

      var items = _selectorEngine["default"].find(SELECTOR_VISIBLE_ITEMS, this._menu).filter(_index.isVisible);

      if (!items.length) {
        return;
      } // if target isn't included in items (e.g. when expanding the dropdown)
      // allow cycling to get the last item in case key equals ARROW_UP_KEY


      (0, _index.getNextActiveElement)(items, target, key === ARROW_DOWN_KEY, !items.includes(target)).focus();
    } // Static

  }], [{
    key: "Default",
    get: function get() {
      return Default;
    }
  }, {
    key: "DefaultType",
    get: function get() {
      return DefaultType;
    }
  }, {
    key: "NAME",
    get: function get() {
      return NAME;
    }
  }, {
    key: "jQueryInterface",
    value: function jQueryInterface(config) {
      return this.each(function () {
        var data = Dropdown.getOrCreateInstance(this, config);

        if (typeof config !== 'string') {
          return;
        }

        if (typeof data[config] === 'undefined') {
          throw new TypeError("No method named \"".concat(config, "\""));
        }

        data[config]();
      });
    }
  }, {
    key: "clearMenus",
    value: function clearMenus(event) {
      if (event && (event.button === RIGHT_MOUSE_BUTTON || event.type === 'keyup' && event.key !== TAB_KEY)) {
        return;
      }

      var toggles = _selectorEngine["default"].find(SELECTOR_DATA_TOGGLE);

      for (var i = 0, len = toggles.length; i < len; i++) {
        var context = Dropdown.getInstance(toggles[i]);

        if (!context || context._config.autoClose === false) {
          continue;
        }

        if (!context._isShown()) {
          continue;
        }

        var relatedTarget = {
          relatedTarget: context._element
        };

        if (event) {
          var composedPath = event.composedPath();
          var isMenuTarget = composedPath.includes(context._menu);

          if (composedPath.includes(context._element) || context._config.autoClose === 'inside' && !isMenuTarget || context._config.autoClose === 'outside' && isMenuTarget) {
            continue;
          } // Tab navigation through the dropdown menu or events from contained inputs shouldn't close the menu


          if (context._menu.contains(event.target) && (event.type === 'keyup' && event.key === TAB_KEY || /input|select|option|textarea|form/i.test(event.target.tagName))) {
            continue;
          }

          if (event.type === 'click') {
            relatedTarget.clickEvent = event;
          }
        }

        context._completeHide(relatedTarget);
      }
    }
  }, {
    key: "getParentFromElement",
    value: function getParentFromElement(element) {
      return (0, _index.getElementFromSelector)(element) || element.parentNode;
    }
  }, {
    key: "dataApiKeydownHandler",
    value: function dataApiKeydownHandler(event) {
      // If not input/textarea:
      //  - And not a key in REGEXP_KEYDOWN => not a dropdown command
      // If input/textarea:
      //  - If space key => not a dropdown command
      //  - If key is other than escape
      //    - If key is not up or down => not a dropdown command
      //    - If trigger inside the menu => not a dropdown command
      if (/input|textarea/i.test(event.target.tagName) ? event.key === SPACE_KEY || event.key !== ESCAPE_KEY && (event.key !== ARROW_DOWN_KEY && event.key !== ARROW_UP_KEY || event.target.closest(SELECTOR_MENU)) : !REGEXP_KEYDOWN.test(event.key)) {
        return;
      }

      var isActive = this.classList.contains(CLASS_NAME_SHOW);

      if (!isActive && event.key === ESCAPE_KEY) {
        return;
      }

      event.preventDefault();
      event.stopPropagation();

      if ((0, _index.isDisabled)(this)) {
        return;
      }

      var getToggleButton = this.matches(SELECTOR_DATA_TOGGLE) ? this : _selectorEngine["default"].prev(this, SELECTOR_DATA_TOGGLE)[0];
      var instance = Dropdown.getOrCreateInstance(getToggleButton);

      if (event.key === ESCAPE_KEY) {
        instance.hide();
        return;
      }

      if (event.key === ARROW_UP_KEY || event.key === ARROW_DOWN_KEY) {
        if (!isActive) {
          instance.show();
        }

        instance._selectMenuItem(event);

        return;
      }

      if (!isActive || event.key === SPACE_KEY) {
        Dropdown.clearMenus();
      }
    }
  }]);

  return Dropdown;
}(_baseComponent["default"]);
/**
 * ------------------------------------------------------------------------
 * Data Api implementation
 * ------------------------------------------------------------------------
 */


_eventHandler["default"].on(document, EVENT_KEYDOWN_DATA_API, SELECTOR_DATA_TOGGLE, Dropdown.dataApiKeydownHandler);

_eventHandler["default"].on(document, EVENT_KEYDOWN_DATA_API, SELECTOR_MENU, Dropdown.dataApiKeydownHandler);

_eventHandler["default"].on(document, EVENT_CLICK_DATA_API, Dropdown.clearMenus);

_eventHandler["default"].on(document, EVENT_KEYUP_DATA_API, Dropdown.clearMenus);

_eventHandler["default"].on(document, EVENT_CLICK_DATA_API, SELECTOR_DATA_TOGGLE, function (event) {
  event.preventDefault();
  Dropdown.getOrCreateInstance(this).toggle();
});
/**
 * ------------------------------------------------------------------------
 * jQuery
 * ------------------------------------------------------------------------
 * add .Dropdown to jQuery only if jQuery is present
 */


(0, _index.defineJQueryPlugin)(Dropdown);
var _default = Dropdown;
exports["default"] = _default;
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _index = require("./util/index");

var _eventHandler = _interopRequireDefault(require("./dom/event-handler"));

var _manipulator = _interopRequireDefault(require("./dom/manipulator"));

var _selectorEngine = _interopRequireDefault(require("./dom/selector-engine"));

var _scrollbar = _interopRequireDefault(require("./util/scrollbar"));

var _baseComponent = _interopRequireDefault(require("./base-component"));

var _backdrop = _interopRequireDefault(require("./util/backdrop"));

var _focustrap = _interopRequireDefault(require("./util/focustrap"));

var _componentFunctions = require("./util/component-functions");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * ------------------------------------------------------------------------
 * Constants
 * ------------------------------------------------------------------------
 */
var NAME = 'modal';
var DATA_KEY = 'bs.modal';
var EVENT_KEY = ".".concat(DATA_KEY);
var DATA_API_KEY = '.data-api';
var ESCAPE_KEY = 'Escape';
var Default = {
  backdrop: true,
  keyboard: true,
  focus: true
};
var DefaultType = {
  backdrop: '(boolean|string)',
  keyboard: 'boolean',
  focus: 'boolean'
};
var EVENT_HIDE = "hide".concat(EVENT_KEY);
var EVENT_HIDE_PREVENTED = "hidePrevented".concat(EVENT_KEY);
var EVENT_HIDDEN = "hidden".concat(EVENT_KEY);
var EVENT_SHOW = "show".concat(EVENT_KEY);
var EVENT_SHOWN = "shown".concat(EVENT_KEY);
var EVENT_RESIZE = "resize".concat(EVENT_KEY);
var EVENT_CLICK_DISMISS = "click.dismiss".concat(EVENT_KEY);
var EVENT_KEYDOWN_DISMISS = "keydown.dismiss".concat(EVENT_KEY);
var EVENT_MOUSEUP_DISMISS = "mouseup.dismiss".concat(EVENT_KEY);
var EVENT_MOUSEDOWN_DISMISS = "mousedown.dismiss".concat(EVENT_KEY);
var EVENT_CLICK_DATA_API = "click".concat(EVENT_KEY).concat(DATA_API_KEY);
var CLASS_NAME_OPEN = 'modal-open';
var CLASS_NAME_FADE = 'fade';
var CLASS_NAME_SHOW = 'show';
var CLASS_NAME_STATIC = 'modal-static';
var OPEN_SELECTOR = '.modal.show';
var SELECTOR_DIALOG = '.modal-dialog';
var SELECTOR_MODAL_BODY = '.modal-body';
var SELECTOR_DATA_TOGGLE = '[data-bs-toggle="modal"]';
/**
 * ------------------------------------------------------------------------
 * Class Definition
 * ------------------------------------------------------------------------
 */

var Modal = /*#__PURE__*/function (_BaseComponent) {
  _inherits(Modal, _BaseComponent);

  var _super = _createSuper(Modal);

  function Modal(element, config) {
    var _this;

    _classCallCheck(this, Modal);

    _this = _super.call(this, element);
    _this._config = _this._getConfig(config);
    _this._dialog = _selectorEngine["default"].findOne(SELECTOR_DIALOG, _this._element);
    _this._backdrop = _this._initializeBackDrop();
    _this._focustrap = _this._initializeFocusTrap();
    _this._isShown = false;
    _this._ignoreBackdropClick = false;
    _this._isTransitioning = false;
    _this._scrollBar = new _scrollbar["default"]();
    return _this;
  } // Getters


  _createClass(Modal, [{
    key: "toggle",
    value: // Public
    function toggle(relatedTarget) {
      return this._isShown ? this.hide() : this.show(relatedTarget);
    }
  }, {
    key: "show",
    value: function show(relatedTarget) {
      var _this2 = this;

      if (this._isShown || this._isTransitioning) {
        return;
      }

      var showEvent = _eventHandler["default"].trigger(this._element, EVENT_SHOW, {
        relatedTarget: relatedTarget
      });

      if (showEvent.defaultPrevented) {
        return;
      }

      this._isShown = true;

      if (this._isAnimated()) {
        this._isTransitioning = true;
      }

      this._scrollBar.hide();

      document.body.classList.add(CLASS_NAME_OPEN);

      this._adjustDialog();

      this._setEscapeEvent();

      this._setResizeEvent();

      _eventHandler["default"].on(this._dialog, EVENT_MOUSEDOWN_DISMISS, function () {
        _eventHandler["default"].one(_this2._element, EVENT_MOUSEUP_DISMISS, function (event) {
          if (event.target === _this2._element) {
            _this2._ignoreBackdropClick = true;
          }
        });
      });

      this._showBackdrop(function () {
        return _this2._showElement(relatedTarget);
      });
    }
  }, {
    key: "hide",
    value: function hide() {
      var _this3 = this;

      if (!this._isShown || this._isTransitioning) {
        return;
      }

      var hideEvent = _eventHandler["default"].trigger(this._element, EVENT_HIDE);

      if (hideEvent.defaultPrevented) {
        return;
      }

      this._isShown = false;

      var isAnimated = this._isAnimated();

      if (isAnimated) {
        this._isTransitioning = true;
      }

      this._setEscapeEvent();

      this._setResizeEvent();

      this._focustrap.deactivate();

      this._element.classList.remove(CLASS_NAME_SHOW);

      _eventHandler["default"].off(this._element, EVENT_CLICK_DISMISS);

      _eventHandler["default"].off(this._dialog, EVENT_MOUSEDOWN_DISMISS);

      this._queueCallback(function () {
        return _this3._hideModal();
      }, this._element, isAnimated);
    }
  }, {
    key: "dispose",
    value: function dispose() {
      [window, this._dialog].forEach(function (htmlElement) {
        return _eventHandler["default"].off(htmlElement, EVENT_KEY);
      });

      this._backdrop.dispose();

      this._focustrap.deactivate();

      _get(_getPrototypeOf(Modal.prototype), "dispose", this).call(this);
    }
  }, {
    key: "handleUpdate",
    value: function handleUpdate() {
      this._adjustDialog();
    } // Private

  }, {
    key: "_initializeBackDrop",
    value: function _initializeBackDrop() {
      return new _backdrop["default"]({
        isVisible: Boolean(this._config.backdrop),
        // 'static' option will be translated to true, and booleans will keep their value
        isAnimated: this._isAnimated()
      });
    }
  }, {
    key: "_initializeFocusTrap",
    value: function _initializeFocusTrap() {
      return new _focustrap["default"]({
        trapElement: this._element
      });
    }
  }, {
    key: "_getConfig",
    value: function _getConfig(config) {
      config = _objectSpread(_objectSpread(_objectSpread({}, Default), _manipulator["default"].getDataAttributes(this._element)), _typeof(config) === 'object' ? config : {});
      (0, _index.typeCheckConfig)(NAME, config, DefaultType);
      return config;
    }
  }, {
    key: "_showElement",
    value: function _showElement(relatedTarget) {
      var _this4 = this;

      var isAnimated = this._isAnimated();

      var modalBody = _selectorEngine["default"].findOne(SELECTOR_MODAL_BODY, this._dialog);

      if (!this._element.parentNode || this._element.parentNode.nodeType !== Node.ELEMENT_NODE) {
        // Don't move modal's DOM position
        document.body.append(this._element);
      }

      this._element.style.display = 'block';

      this._element.removeAttribute('aria-hidden');

      this._element.setAttribute('aria-modal', true);

      this._element.setAttribute('role', 'dialog');

      this._element.scrollTop = 0;

      if (modalBody) {
        modalBody.scrollTop = 0;
      }

      if (isAnimated) {
        (0, _index.reflow)(this._element);
      }

      this._element.classList.add(CLASS_NAME_SHOW);

      var transitionComplete = function transitionComplete() {
        if (_this4._config.focus) {
          _this4._focustrap.activate();
        }

        _this4._isTransitioning = false;

        _eventHandler["default"].trigger(_this4._element, EVENT_SHOWN, {
          relatedTarget: relatedTarget
        });
      };

      this._queueCallback(transitionComplete, this._dialog, isAnimated);
    }
  }, {
    key: "_setEscapeEvent",
    value: function _setEscapeEvent() {
      var _this5 = this;

      if (this._isShown) {
        _eventHandler["default"].on(this._element, EVENT_KEYDOWN_DISMISS, function (event) {
          if (_this5._config.keyboard && event.key === ESCAPE_KEY) {
            event.preventDefault();

            _this5.hide();
          } else if (!_this5._config.keyboard && event.key === ESCAPE_KEY) {
            _this5._triggerBackdropTransition();
          }
        });
      } else {
        _eventHandler["default"].off(this._element, EVENT_KEYDOWN_DISMISS);
      }
    }
  }, {
    key: "_setResizeEvent",
    value: function _setResizeEvent() {
      var _this6 = this;

      if (this._isShown) {
        _eventHandler["default"].on(window, EVENT_RESIZE, function () {
          return _this6._adjustDialog();
        });
      } else {
        _eventHandler["default"].off(window, EVENT_RESIZE);
      }
    }
  }, {
    key: "_hideModal",
    value: function _hideModal() {
      var _this7 = this;

      this._element.style.display = 'none';

      this._element.setAttribute('aria-hidden', true);

      this._element.removeAttribute('aria-modal');

      this._element.removeAttribute('role');

      this._isTransitioning = false;

      this._backdrop.hide(function () {
        document.body.classList.remove(CLASS_NAME_OPEN);

        _this7._resetAdjustments();

        _this7._scrollBar.reset();

        _eventHandler["default"].trigger(_this7._element, EVENT_HIDDEN);
      });
    }
  }, {
    key: "_showBackdrop",
    value: function _showBackdrop(callback) {
      var _this8 = this;

      _eventHandler["default"].on(this._element, EVENT_CLICK_DISMISS, function (event) {
        if (_this8._ignoreBackdropClick) {
          _this8._ignoreBackdropClick = false;
          return;
        }

        if (event.target !== event.currentTarget) {
          return;
        }

        if (_this8._config.backdrop === true) {
          _this8.hide();
        } else if (_this8._config.backdrop === 'static') {
          _this8._triggerBackdropTransition();
        }
      });

      this._backdrop.show(callback);
    }
  }, {
    key: "_isAnimated",
    value: function _isAnimated() {
      return this._element.classList.contains(CLASS_NAME_FADE);
    }
  }, {
    key: "_triggerBackdropTransition",
    value: function _triggerBackdropTransition() {
      var _this9 = this;

      var hideEvent = _eventHandler["default"].trigger(this._element, EVENT_HIDE_PREVENTED);

      if (hideEvent.defaultPrevented) {
        return;
      }

      var _this$_element = this._element,
          classList = _this$_element.classList,
          scrollHeight = _this$_element.scrollHeight,
          style = _this$_element.style;
      var isModalOverflowing = scrollHeight > document.documentElement.clientHeight; // return if the following background transition hasn't yet completed

      if (!isModalOverflowing && style.overflowY === 'hidden' || classList.contains(CLASS_NAME_STATIC)) {
        return;
      }

      if (!isModalOverflowing) {
        style.overflowY = 'hidden';
      }

      classList.add(CLASS_NAME_STATIC);

      this._queueCallback(function () {
        classList.remove(CLASS_NAME_STATIC);

        if (!isModalOverflowing) {
          _this9._queueCallback(function () {
            style.overflowY = '';
          }, _this9._dialog);
        }
      }, this._dialog);

      this._element.focus();
    } // ----------------------------------------------------------------------
    // the following methods are used to handle overflowing modals
    // ----------------------------------------------------------------------

  }, {
    key: "_adjustDialog",
    value: function _adjustDialog() {
      var isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;

      var scrollbarWidth = this._scrollBar.getWidth();

      var isBodyOverflowing = scrollbarWidth > 0;

      if (!isBodyOverflowing && isModalOverflowing && !(0, _index.isRTL)() || isBodyOverflowing && !isModalOverflowing && (0, _index.isRTL)()) {
        this._element.style.paddingLeft = "".concat(scrollbarWidth, "px");
      }

      if (isBodyOverflowing && !isModalOverflowing && !(0, _index.isRTL)() || !isBodyOverflowing && isModalOverflowing && (0, _index.isRTL)()) {
        this._element.style.paddingRight = "".concat(scrollbarWidth, "px");
      }
    }
  }, {
    key: "_resetAdjustments",
    value: function _resetAdjustments() {
      this._element.style.paddingLeft = '';
      this._element.style.paddingRight = '';
    } // Static

  }], [{
    key: "Default",
    get: function get() {
      return Default;
    }
  }, {
    key: "NAME",
    get: function get() {
      return NAME;
    }
  }, {
    key: "jQueryInterface",
    value: function jQueryInterface(config, relatedTarget) {
      return this.each(function () {
        var data = Modal.getOrCreateInstance(this, config);

        if (typeof config !== 'string') {
          return;
        }

        if (typeof data[config] === 'undefined') {
          throw new TypeError("No method named \"".concat(config, "\""));
        }

        data[config](relatedTarget);
      });
    }
  }]);

  return Modal;
}(_baseComponent["default"]);
/**
 * ------------------------------------------------------------------------
 * Data Api implementation
 * ------------------------------------------------------------------------
 */


_eventHandler["default"].on(document, EVENT_CLICK_DATA_API, SELECTOR_DATA_TOGGLE, function (event) {
  var _this10 = this;

  var target = (0, _index.getElementFromSelector)(this);

  if (['A', 'AREA'].includes(this.tagName)) {
    event.preventDefault();
  }

  _eventHandler["default"].one(target, EVENT_SHOW, function (showEvent) {
    if (showEvent.defaultPrevented) {
      // only register focus restorer if modal will actually get shown
      return;
    }

    _eventHandler["default"].one(target, EVENT_HIDDEN, function () {
      if ((0, _index.isVisible)(_this10)) {
        _this10.focus();
      }
    });
  }); // avoid conflict when clicking moddal toggler while another one is open


  var allReadyOpen = _selectorEngine["default"].findOne(OPEN_SELECTOR);

  if (allReadyOpen) {
    Modal.getInstance(allReadyOpen).hide();
  }

  var data = Modal.getOrCreateInstance(target);
  data.toggle(this);
});

(0, _componentFunctions.enableDismissTrigger)(Modal);
/**
 * ------------------------------------------------------------------------
 * jQuery
 * ------------------------------------------------------------------------
 * add .Modal to jQuery only if jQuery is present
 */

(0, _index.defineJQueryPlugin)(Modal);
var _default = Modal;
exports["default"] = _default;
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _index = require("./util/index");

var _scrollbar = _interopRequireDefault(require("./util/scrollbar"));

var _eventHandler = _interopRequireDefault(require("./dom/event-handler"));

var _baseComponent = _interopRequireDefault(require("./base-component"));

var _selectorEngine = _interopRequireDefault(require("./dom/selector-engine"));

var _manipulator = _interopRequireDefault(require("./dom/manipulator"));

var _backdrop = _interopRequireDefault(require("./util/backdrop"));

var _focustrap = _interopRequireDefault(require("./util/focustrap"));

var _componentFunctions = require("./util/component-functions");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * ------------------------------------------------------------------------
 * Constants
 * ------------------------------------------------------------------------
 */
var NAME = 'offcanvas';
var DATA_KEY = 'bs.offcanvas';
var EVENT_KEY = ".".concat(DATA_KEY);
var DATA_API_KEY = '.data-api';
var EVENT_LOAD_DATA_API = "load".concat(EVENT_KEY).concat(DATA_API_KEY);
var ESCAPE_KEY = 'Escape';
var Default = {
  backdrop: true,
  keyboard: true,
  scroll: false
};
var DefaultType = {
  backdrop: 'boolean',
  keyboard: 'boolean',
  scroll: 'boolean'
};
var CLASS_NAME_SHOW = 'show';
var CLASS_NAME_BACKDROP = 'offcanvas-backdrop';
var OPEN_SELECTOR = '.offcanvas.show';
var EVENT_SHOW = "show".concat(EVENT_KEY);
var EVENT_SHOWN = "shown".concat(EVENT_KEY);
var EVENT_HIDE = "hide".concat(EVENT_KEY);
var EVENT_HIDDEN = "hidden".concat(EVENT_KEY);
var EVENT_CLICK_DATA_API = "click".concat(EVENT_KEY).concat(DATA_API_KEY);
var EVENT_KEYDOWN_DISMISS = "keydown.dismiss".concat(EVENT_KEY);
var SELECTOR_DATA_TOGGLE = '[data-bs-toggle="offcanvas"]';
/**
 * ------------------------------------------------------------------------
 * Class Definition
 * ------------------------------------------------------------------------
 */

var Offcanvas = /*#__PURE__*/function (_BaseComponent) {
  _inherits(Offcanvas, _BaseComponent);

  var _super = _createSuper(Offcanvas);

  function Offcanvas(element, config) {
    var _this;

    _classCallCheck(this, Offcanvas);

    _this = _super.call(this, element);
    _this._config = _this._getConfig(config);
    _this._isShown = false;
    _this._backdrop = _this._initializeBackDrop();
    _this._focustrap = _this._initializeFocusTrap();

    _this._addEventListeners();

    return _this;
  } // Getters


  _createClass(Offcanvas, [{
    key: "toggle",
    value: // Public
    function toggle(relatedTarget) {
      return this._isShown ? this.hide() : this.show(relatedTarget);
    }
  }, {
    key: "show",
    value: function show(relatedTarget) {
      var _this2 = this;

      if (this._isShown) {
        return;
      }

      var showEvent = _eventHandler["default"].trigger(this._element, EVENT_SHOW, {
        relatedTarget: relatedTarget
      });

      if (showEvent.defaultPrevented) {
        return;
      }

      this._isShown = true;
      this._element.style.visibility = 'visible';

      this._backdrop.show();

      if (!this._config.scroll) {
        new _scrollbar["default"]().hide();
      }

      this._element.removeAttribute('aria-hidden');

      this._element.setAttribute('aria-modal', true);

      this._element.setAttribute('role', 'dialog');

      this._element.classList.add(CLASS_NAME_SHOW);

      var completeCallBack = function completeCallBack() {
        if (!_this2._config.scroll) {
          _this2._focustrap.activate();
        }

        _eventHandler["default"].trigger(_this2._element, EVENT_SHOWN, {
          relatedTarget: relatedTarget
        });
      };

      this._queueCallback(completeCallBack, this._element, true);
    }
  }, {
    key: "hide",
    value: function hide() {
      var _this3 = this;

      if (!this._isShown) {
        return;
      }

      var hideEvent = _eventHandler["default"].trigger(this._element, EVENT_HIDE);

      if (hideEvent.defaultPrevented) {
        return;
      }

      this._focustrap.deactivate();

      this._element.blur();

      this._isShown = false;

      this._element.classList.remove(CLASS_NAME_SHOW);

      this._backdrop.hide();

      var completeCallback = function completeCallback() {
        _this3._element.setAttribute('aria-hidden', true);

        _this3._element.removeAttribute('aria-modal');

        _this3._element.removeAttribute('role');

        _this3._element.style.visibility = 'hidden';

        if (!_this3._config.scroll) {
          new _scrollbar["default"]().reset();
        }

        _eventHandler["default"].trigger(_this3._element, EVENT_HIDDEN);
      };

      this._queueCallback(completeCallback, this._element, true);
    }
  }, {
    key: "dispose",
    value: function dispose() {
      this._backdrop.dispose();

      this._focustrap.deactivate();

      _get(_getPrototypeOf(Offcanvas.prototype), "dispose", this).call(this);
    } // Private

  }, {
    key: "_getConfig",
    value: function _getConfig(config) {
      config = _objectSpread(_objectSpread(_objectSpread({}, Default), _manipulator["default"].getDataAttributes(this._element)), _typeof(config) === 'object' ? config : {});
      (0, _index.typeCheckConfig)(NAME, config, DefaultType);
      return config;
    }
  }, {
    key: "_initializeBackDrop",
    value: function _initializeBackDrop() {
      var _this4 = this;

      return new _backdrop["default"]({
        className: CLASS_NAME_BACKDROP,
        isVisible: this._config.backdrop,
        isAnimated: true,
        rootElement: this._element.parentNode,
        clickCallback: function clickCallback() {
          return _this4.hide();
        }
      });
    }
  }, {
    key: "_initializeFocusTrap",
    value: function _initializeFocusTrap() {
      return new _focustrap["default"]({
        trapElement: this._element
      });
    }
  }, {
    key: "_addEventListeners",
    value: function _addEventListeners() {
      var _this5 = this;

      _eventHandler["default"].on(this._element, EVENT_KEYDOWN_DISMISS, function (event) {
        if (_this5._config.keyboard && event.key === ESCAPE_KEY) {
          _this5.hide();
        }
      });
    } // Static

  }], [{
    key: "NAME",
    get: function get() {
      return NAME;
    }
  }, {
    key: "Default",
    get: function get() {
      return Default;
    }
  }, {
    key: "jQueryInterface",
    value: function jQueryInterface(config) {
      return this.each(function () {
        var data = Offcanvas.getOrCreateInstance(this, config);

        if (typeof config !== 'string') {
          return;
        }

        if (data[config] === undefined || config.startsWith('_') || config === 'constructor') {
          throw new TypeError("No method named \"".concat(config, "\""));
        }

        data[config](this);
      });
    }
  }]);

  return Offcanvas;
}(_baseComponent["default"]);
/**
 * ------------------------------------------------------------------------
 * Data Api implementation
 * ------------------------------------------------------------------------
 */


_eventHandler["default"].on(document, EVENT_CLICK_DATA_API, SELECTOR_DATA_TOGGLE, function (event) {
  var _this6 = this;

  var target = (0, _index.getElementFromSelector)(this);

  if (['A', 'AREA'].includes(this.tagName)) {
    event.preventDefault();
  }

  if ((0, _index.isDisabled)(this)) {
    return;
  }

  _eventHandler["default"].one(target, EVENT_HIDDEN, function () {
    // focus on trigger when it is closed
    if ((0, _index.isVisible)(_this6)) {
      _this6.focus();
    }
  }); // avoid conflict when clicking a toggler of an offcanvas, while another is open


  var allReadyOpen = _selectorEngine["default"].findOne(OPEN_SELECTOR);

  if (allReadyOpen && allReadyOpen !== target) {
    Offcanvas.getInstance(allReadyOpen).hide();
  }

  var data = Offcanvas.getOrCreateInstance(target);
  data.toggle(this);
});

_eventHandler["default"].on(window, EVENT_LOAD_DATA_API, function () {
  return _selectorEngine["default"].find(OPEN_SELECTOR).forEach(function (el) {
    return Offcanvas.getOrCreateInstance(el).show();
  });
});

(0, _componentFunctions.enableDismissTrigger)(Offcanvas);
/**
 * ------------------------------------------------------------------------
 * jQuery
 * ------------------------------------------------------------------------
 */

(0, _index.defineJQueryPlugin)(Offcanvas);
var _default = Offcanvas;
exports["default"] = _default;
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _index = require("./util/index");

var _tooltip = _interopRequireDefault(require("./tooltip"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * ------------------------------------------------------------------------
 * Constants
 * ------------------------------------------------------------------------
 */
var NAME = 'popover';
var DATA_KEY = 'bs.popover';
var EVENT_KEY = ".".concat(DATA_KEY);
var CLASS_PREFIX = 'bs-popover';

var Default = _objectSpread(_objectSpread({}, _tooltip["default"].Default), {}, {
  placement: 'right',
  offset: [0, 8],
  trigger: 'click',
  content: '',
  template: '<div class="popover" role="tooltip">' + '<div class="popover-arrow"></div>' + '<h3 class="popover-header"></h3>' + '<div class="popover-body"></div>' + '</div>'
});

var DefaultType = _objectSpread(_objectSpread({}, _tooltip["default"].DefaultType), {}, {
  content: '(string|element|function)'
});

var Event = {
  HIDE: "hide".concat(EVENT_KEY),
  HIDDEN: "hidden".concat(EVENT_KEY),
  SHOW: "show".concat(EVENT_KEY),
  SHOWN: "shown".concat(EVENT_KEY),
  INSERTED: "inserted".concat(EVENT_KEY),
  CLICK: "click".concat(EVENT_KEY),
  FOCUSIN: "focusin".concat(EVENT_KEY),
  FOCUSOUT: "focusout".concat(EVENT_KEY),
  MOUSEENTER: "mouseenter".concat(EVENT_KEY),
  MOUSELEAVE: "mouseleave".concat(EVENT_KEY)
};
var SELECTOR_TITLE = '.popover-header';
var SELECTOR_CONTENT = '.popover-body';
/**
 * ------------------------------------------------------------------------
 * Class Definition
 * ------------------------------------------------------------------------
 */

var Popover = /*#__PURE__*/function (_Tooltip) {
  _inherits(Popover, _Tooltip);

  var _super = _createSuper(Popover);

  function Popover() {
    _classCallCheck(this, Popover);

    return _super.apply(this, arguments);
  }

  _createClass(Popover, [{
    key: "isWithContent",
    value: // Overrides
    function isWithContent() {
      return this.getTitle() || this._getContent();
    }
  }, {
    key: "setContent",
    value: function setContent(tip) {
      this._sanitizeAndSetContent(tip, this.getTitle(), SELECTOR_TITLE);

      this._sanitizeAndSetContent(tip, this._getContent(), SELECTOR_CONTENT);
    } // Private

  }, {
    key: "_getContent",
    value: function _getContent() {
      return this._resolvePossibleFunction(this._config.content);
    }
  }, {
    key: "_getBasicClassPrefix",
    value: function _getBasicClassPrefix() {
      return CLASS_PREFIX;
    } // Static

  }], [{
    key: "Default",
    get: // Getters
    function get() {
      return Default;
    }
  }, {
    key: "NAME",
    get: function get() {
      return NAME;
    }
  }, {
    key: "Event",
    get: function get() {
      return Event;
    }
  }, {
    key: "DefaultType",
    get: function get() {
      return DefaultType;
    }
  }, {
    key: "jQueryInterface",
    value: function jQueryInterface(config) {
      return this.each(function () {
        var data = Popover.getOrCreateInstance(this, config);

        if (typeof config === 'string') {
          if (typeof data[config] === 'undefined') {
            throw new TypeError("No method named \"".concat(config, "\""));
          }

          data[config]();
        }
      });
    }
  }]);

  return Popover;
}(_tooltip["default"]);
/**
 * ------------------------------------------------------------------------
 * jQuery
 * ------------------------------------------------------------------------
 * add .Popover to jQuery only if jQuery is present
 */


(0, _index.defineJQueryPlugin)(Popover);
var _default = Popover;
exports["default"] = _default;
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _index = require("./util/index");

var _eventHandler = _interopRequireDefault(require("./dom/event-handler"));

var _manipulator = _interopRequireDefault(require("./dom/manipulator"));

var _selectorEngine = _interopRequireDefault(require("./dom/selector-engine"));

var _baseComponent = _interopRequireDefault(require("./base-component"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * ------------------------------------------------------------------------
 * Constants
 * ------------------------------------------------------------------------
 */
var NAME = 'scrollspy';
var DATA_KEY = 'bs.scrollspy';
var EVENT_KEY = ".".concat(DATA_KEY);
var DATA_API_KEY = '.data-api';
var Default = {
  offset: 10,
  method: 'auto',
  target: ''
};
var DefaultType = {
  offset: 'number',
  method: 'string',
  target: '(string|element)'
};
var EVENT_ACTIVATE = "activate".concat(EVENT_KEY);
var EVENT_SCROLL = "scroll".concat(EVENT_KEY);
var EVENT_LOAD_DATA_API = "load".concat(EVENT_KEY).concat(DATA_API_KEY);
var CLASS_NAME_DROPDOWN_ITEM = 'dropdown-item';
var CLASS_NAME_ACTIVE = 'active';
var SELECTOR_DATA_SPY = '[data-bs-spy="scroll"]';
var SELECTOR_NAV_LIST_GROUP = '.nav, .list-group';
var SELECTOR_NAV_LINKS = '.nav-link';
var SELECTOR_NAV_ITEMS = '.nav-item';
var SELECTOR_LIST_ITEMS = '.list-group-item';
var SELECTOR_LINK_ITEMS = "".concat(SELECTOR_NAV_LINKS, ", ").concat(SELECTOR_LIST_ITEMS, ", .").concat(CLASS_NAME_DROPDOWN_ITEM);
var SELECTOR_DROPDOWN = '.dropdown';
var SELECTOR_DROPDOWN_TOGGLE = '.dropdown-toggle';
var METHOD_OFFSET = 'offset';
var METHOD_POSITION = 'position';
/**
 * ------------------------------------------------------------------------
 * Class Definition
 * ------------------------------------------------------------------------
 */

var ScrollSpy = /*#__PURE__*/function (_BaseComponent) {
  _inherits(ScrollSpy, _BaseComponent);

  var _super = _createSuper(ScrollSpy);

  function ScrollSpy(element, config) {
    var _this;

    _classCallCheck(this, ScrollSpy);

    _this = _super.call(this, element);
    _this._scrollElement = _this._element.tagName === 'BODY' ? window : _this._element;
    _this._config = _this._getConfig(config);
    _this._offsets = [];
    _this._targets = [];
    _this._activeTarget = null;
    _this._scrollHeight = 0;

    _eventHandler["default"].on(_this._scrollElement, EVENT_SCROLL, function () {
      return _this._process();
    });

    _this.refresh();

    _this._process();

    return _this;
  } // Getters


  _createClass(ScrollSpy, [{
    key: "refresh",
    value: // Public
    function refresh() {
      var _this2 = this;

      var autoMethod = this._scrollElement === this._scrollElement.window ? METHOD_OFFSET : METHOD_POSITION;
      var offsetMethod = this._config.method === 'auto' ? autoMethod : this._config.method;
      var offsetBase = offsetMethod === METHOD_POSITION ? this._getScrollTop() : 0;
      this._offsets = [];
      this._targets = [];
      this._scrollHeight = this._getScrollHeight();

      var targets = _selectorEngine["default"].find(SELECTOR_LINK_ITEMS, this._config.target);

      targets.map(function (element) {
        var targetSelector = (0, _index.getSelectorFromElement)(element);
        var target = targetSelector ? _selectorEngine["default"].findOne(targetSelector) : null;

        if (target) {
          var targetBCR = target.getBoundingClientRect();

          if (targetBCR.width || targetBCR.height) {
            return [_manipulator["default"][offsetMethod](target).top + offsetBase, targetSelector];
          }
        }

        return null;
      }).filter(function (item) {
        return item;
      }).sort(function (a, b) {
        return a[0] - b[0];
      }).forEach(function (item) {
        _this2._offsets.push(item[0]);

        _this2._targets.push(item[1]);
      });
    }
  }, {
    key: "dispose",
    value: function dispose() {
      _eventHandler["default"].off(this._scrollElement, EVENT_KEY);

      _get(_getPrototypeOf(ScrollSpy.prototype), "dispose", this).call(this);
    } // Private

  }, {
    key: "_getConfig",
    value: function _getConfig(config) {
      config = _objectSpread(_objectSpread(_objectSpread({}, Default), _manipulator["default"].getDataAttributes(this._element)), _typeof(config) === 'object' && config ? config : {});
      config.target = (0, _index.getElement)(config.target) || document.documentElement;
      (0, _index.typeCheckConfig)(NAME, config, DefaultType);
      return config;
    }
  }, {
    key: "_getScrollTop",
    value: function _getScrollTop() {
      return this._scrollElement === window ? this._scrollElement.pageYOffset : this._scrollElement.scrollTop;
    }
  }, {
    key: "_getScrollHeight",
    value: function _getScrollHeight() {
      return this._scrollElement.scrollHeight || Math.max(document.body.scrollHeight, document.documentElement.scrollHeight);
    }
  }, {
    key: "_getOffsetHeight",
    value: function _getOffsetHeight() {
      return this._scrollElement === window ? window.innerHeight : this._scrollElement.getBoundingClientRect().height;
    }
  }, {
    key: "_process",
    value: function _process() {
      var scrollTop = this._getScrollTop() + this._config.offset;

      var scrollHeight = this._getScrollHeight();

      var maxScroll = this._config.offset + scrollHeight - this._getOffsetHeight();

      if (this._scrollHeight !== scrollHeight) {
        this.refresh();
      }

      if (scrollTop >= maxScroll) {
        var target = this._targets[this._targets.length - 1];

        if (this._activeTarget !== target) {
          this._activate(target);
        }

        return;
      }

      if (this._activeTarget && scrollTop < this._offsets[0] && this._offsets[0] > 0) {
        this._activeTarget = null;

        this._clear();

        return;
      }

      for (var i = this._offsets.length; i--;) {
        var isActiveTarget = this._activeTarget !== this._targets[i] && scrollTop >= this._offsets[i] && (typeof this._offsets[i + 1] === 'undefined' || scrollTop < this._offsets[i + 1]);

        if (isActiveTarget) {
          this._activate(this._targets[i]);
        }
      }
    }
  }, {
    key: "_activate",
    value: function _activate(target) {
      this._activeTarget = target;

      this._clear();

      var queries = SELECTOR_LINK_ITEMS.split(',').map(function (selector) {
        return "".concat(selector, "[data-bs-target=\"").concat(target, "\"],").concat(selector, "[href=\"").concat(target, "\"]");
      });

      var link = _selectorEngine["default"].findOne(queries.join(','), this._config.target);

      link.classList.add(CLASS_NAME_ACTIVE);

      if (link.classList.contains(CLASS_NAME_DROPDOWN_ITEM)) {
        _selectorEngine["default"].findOne(SELECTOR_DROPDOWN_TOGGLE, link.closest(SELECTOR_DROPDOWN)).classList.add(CLASS_NAME_ACTIVE);
      } else {
        _selectorEngine["default"].parents(link, SELECTOR_NAV_LIST_GROUP).forEach(function (listGroup) {
          // Set triggered links parents as active
          // With both <ul> and <nav> markup a parent is the previous sibling of any nav ancestor
          _selectorEngine["default"].prev(listGroup, "".concat(SELECTOR_NAV_LINKS, ", ").concat(SELECTOR_LIST_ITEMS)).forEach(function (item) {
            return item.classList.add(CLASS_NAME_ACTIVE);
          }); // Handle special case when .nav-link is inside .nav-item


          _selectorEngine["default"].prev(listGroup, SELECTOR_NAV_ITEMS).forEach(function (navItem) {
            _selectorEngine["default"].children(navItem, SELECTOR_NAV_LINKS).forEach(function (item) {
              return item.classList.add(CLASS_NAME_ACTIVE);
            });
          });
        });
      }

      _eventHandler["default"].trigger(this._scrollElement, EVENT_ACTIVATE, {
        relatedTarget: target
      });
    }
  }, {
    key: "_clear",
    value: function _clear() {
      _selectorEngine["default"].find(SELECTOR_LINK_ITEMS, this._config.target).filter(function (node) {
        return node.classList.contains(CLASS_NAME_ACTIVE);
      }).forEach(function (node) {
        return node.classList.remove(CLASS_NAME_ACTIVE);
      });
    } // Static

  }], [{
    key: "Default",
    get: function get() {
      return Default;
    }
  }, {
    key: "NAME",
    get: function get() {
      return NAME;
    }
  }, {
    key: "jQueryInterface",
    value: function jQueryInterface(config) {
      return this.each(function () {
        var data = ScrollSpy.getOrCreateInstance(this, config);

        if (typeof config !== 'string') {
          return;
        }

        if (typeof data[config] === 'undefined') {
          throw new TypeError("No method named \"".concat(config, "\""));
        }

        data[config]();
      });
    }
  }]);

  return ScrollSpy;
}(_baseComponent["default"]);
/**
 * ------------------------------------------------------------------------
 * Data Api implementation
 * ------------------------------------------------------------------------
 */


_eventHandler["default"].on(window, EVENT_LOAD_DATA_API, function () {
  _selectorEngine["default"].find(SELECTOR_DATA_SPY).forEach(function (spy) {
    return new ScrollSpy(spy);
  });
});
/**
 * ------------------------------------------------------------------------
 * jQuery
 * ------------------------------------------------------------------------
 * add .ScrollSpy to jQuery only if jQuery is present
 */


(0, _index.defineJQueryPlugin)(ScrollSpy);
var _default = ScrollSpy;
exports["default"] = _default;
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _index = require("./util/index");

var _eventHandler = _interopRequireDefault(require("./dom/event-handler"));

var _selectorEngine = _interopRequireDefault(require("./dom/selector-engine"));

var _baseComponent = _interopRequireDefault(require("./base-component"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * ------------------------------------------------------------------------
 * Constants
 * ------------------------------------------------------------------------
 */
var NAME = 'tab';
var DATA_KEY = 'bs.tab';
var EVENT_KEY = ".".concat(DATA_KEY);
var DATA_API_KEY = '.data-api';
var EVENT_HIDE = "hide".concat(EVENT_KEY);
var EVENT_HIDDEN = "hidden".concat(EVENT_KEY);
var EVENT_SHOW = "show".concat(EVENT_KEY);
var EVENT_SHOWN = "shown".concat(EVENT_KEY);
var EVENT_CLICK_DATA_API = "click".concat(EVENT_KEY).concat(DATA_API_KEY);
var CLASS_NAME_DROPDOWN_MENU = 'dropdown-menu';
var CLASS_NAME_ACTIVE = 'active';
var CLASS_NAME_FADE = 'fade';
var CLASS_NAME_SHOW = 'show';
var SELECTOR_DROPDOWN = '.dropdown';
var SELECTOR_NAV_LIST_GROUP = '.nav, .list-group';
var SELECTOR_ACTIVE = '.active';
var SELECTOR_ACTIVE_UL = ':scope > li > .active';
var SELECTOR_DATA_TOGGLE = '[data-bs-toggle="tab"], [data-bs-toggle="pill"], [data-bs-toggle="list"]';
var SELECTOR_DROPDOWN_TOGGLE = '.dropdown-toggle';
var SELECTOR_DROPDOWN_ACTIVE_CHILD = ':scope > .dropdown-menu .active';
/**
 * ------------------------------------------------------------------------
 * Class Definition
 * ------------------------------------------------------------------------
 */

var Tab = /*#__PURE__*/function (_BaseComponent) {
  _inherits(Tab, _BaseComponent);

  var _super = _createSuper(Tab);

  function Tab() {
    _classCallCheck(this, Tab);

    return _super.apply(this, arguments);
  }

  _createClass(Tab, [{
    key: "show",
    value: // Public
    function show() {
      var _this = this;

      if (this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE && this._element.classList.contains(CLASS_NAME_ACTIVE)) {
        return;
      }

      var previous;
      var target = (0, _index.getElementFromSelector)(this._element);

      var listElement = this._element.closest(SELECTOR_NAV_LIST_GROUP);

      if (listElement) {
        var itemSelector = listElement.nodeName === 'UL' || listElement.nodeName === 'OL' ? SELECTOR_ACTIVE_UL : SELECTOR_ACTIVE;
        previous = _selectorEngine["default"].find(itemSelector, listElement);
        previous = previous[previous.length - 1];
      }

      var hideEvent = previous ? _eventHandler["default"].trigger(previous, EVENT_HIDE, {
        relatedTarget: this._element
      }) : null;

      var showEvent = _eventHandler["default"].trigger(this._element, EVENT_SHOW, {
        relatedTarget: previous
      });

      if (showEvent.defaultPrevented || hideEvent !== null && hideEvent.defaultPrevented) {
        return;
      }

      this._activate(this._element, listElement);

      var complete = function complete() {
        _eventHandler["default"].trigger(previous, EVENT_HIDDEN, {
          relatedTarget: _this._element
        });

        _eventHandler["default"].trigger(_this._element, EVENT_SHOWN, {
          relatedTarget: previous
        });
      };

      if (target) {
        this._activate(target, target.parentNode, complete);
      } else {
        complete();
      }
    } // Private

  }, {
    key: "_activate",
    value: function _activate(element, container, callback) {
      var _this2 = this;

      var activeElements = container && (container.nodeName === 'UL' || container.nodeName === 'OL') ? _selectorEngine["default"].find(SELECTOR_ACTIVE_UL, container) : _selectorEngine["default"].children(container, SELECTOR_ACTIVE);
      var active = activeElements[0];
      var isTransitioning = callback && active && active.classList.contains(CLASS_NAME_FADE);

      var complete = function complete() {
        return _this2._transitionComplete(element, active, callback);
      };

      if (active && isTransitioning) {
        active.classList.remove(CLASS_NAME_SHOW);

        this._queueCallback(complete, element, true);
      } else {
        complete();
      }
    }
  }, {
    key: "_transitionComplete",
    value: function _transitionComplete(element, active, callback) {
      if (active) {
        active.classList.remove(CLASS_NAME_ACTIVE);

        var dropdownChild = _selectorEngine["default"].findOne(SELECTOR_DROPDOWN_ACTIVE_CHILD, active.parentNode);

        if (dropdownChild) {
          dropdownChild.classList.remove(CLASS_NAME_ACTIVE);
        }

        if (active.getAttribute('role') === 'tab') {
          active.setAttribute('aria-selected', false);
        }
      }

      element.classList.add(CLASS_NAME_ACTIVE);

      if (element.getAttribute('role') === 'tab') {
        element.setAttribute('aria-selected', true);
      }

      (0, _index.reflow)(element);

      if (element.classList.contains(CLASS_NAME_FADE)) {
        element.classList.add(CLASS_NAME_SHOW);
      }

      var parent = element.parentNode;

      if (parent && parent.nodeName === 'LI') {
        parent = parent.parentNode;
      }

      if (parent && parent.classList.contains(CLASS_NAME_DROPDOWN_MENU)) {
        var dropdownElement = element.closest(SELECTOR_DROPDOWN);

        if (dropdownElement) {
          _selectorEngine["default"].find(SELECTOR_DROPDOWN_TOGGLE, dropdownElement).forEach(function (dropdown) {
            return dropdown.classList.add(CLASS_NAME_ACTIVE);
          });
        }

        element.setAttribute('aria-expanded', true);
      }

      if (callback) {
        callback();
      }
    } // Static

  }], [{
    key: "NAME",
    get: // Getters
    function get() {
      return NAME;
    }
  }, {
    key: "jQueryInterface",
    value: function jQueryInterface(config) {
      return this.each(function () {
        var data = Tab.getOrCreateInstance(this);

        if (typeof config === 'string') {
          if (typeof data[config] === 'undefined') {
            throw new TypeError("No method named \"".concat(config, "\""));
          }

          data[config]();
        }
      });
    }
  }]);

  return Tab;
}(_baseComponent["default"]);
/**
 * ------------------------------------------------------------------------
 * Data Api implementation
 * ------------------------------------------------------------------------
 */


_eventHandler["default"].on(document, EVENT_CLICK_DATA_API, SELECTOR_DATA_TOGGLE, function (event) {
  if (['A', 'AREA'].includes(this.tagName)) {
    event.preventDefault();
  }

  if ((0, _index.isDisabled)(this)) {
    return;
  }

  var data = Tab.getOrCreateInstance(this);
  data.show();
});
/**
 * ------------------------------------------------------------------------
 * jQuery
 * ------------------------------------------------------------------------
 * add .Tab to jQuery only if jQuery is present
 */


(0, _index.defineJQueryPlugin)(Tab);
var _default = Tab;
exports["default"] = _default;
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _index = require("./util/index");

var _eventHandler = _interopRequireDefault(require("./dom/event-handler"));

var _manipulator = _interopRequireDefault(require("./dom/manipulator"));

var _baseComponent = _interopRequireDefault(require("./base-component"));

var _componentFunctions = require("./util/component-functions");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * ------------------------------------------------------------------------
 * Constants
 * ------------------------------------------------------------------------
 */
var NAME = 'toast';
var DATA_KEY = 'bs.toast';
var EVENT_KEY = ".".concat(DATA_KEY);
var EVENT_MOUSEOVER = "mouseover".concat(EVENT_KEY);
var EVENT_MOUSEOUT = "mouseout".concat(EVENT_KEY);
var EVENT_FOCUSIN = "focusin".concat(EVENT_KEY);
var EVENT_FOCUSOUT = "focusout".concat(EVENT_KEY);
var EVENT_HIDE = "hide".concat(EVENT_KEY);
var EVENT_HIDDEN = "hidden".concat(EVENT_KEY);
var EVENT_SHOW = "show".concat(EVENT_KEY);
var EVENT_SHOWN = "shown".concat(EVENT_KEY);
var CLASS_NAME_FADE = 'fade';
var CLASS_NAME_HIDE = 'hide'; // @deprecated - kept here only for backwards compatibility

var CLASS_NAME_SHOW = 'show';
var CLASS_NAME_SHOWING = 'showing';
var DefaultType = {
  animation: 'boolean',
  autohide: 'boolean',
  delay: 'number'
};
var Default = {
  animation: true,
  autohide: true,
  delay: 5000
};
/**
 * ------------------------------------------------------------------------
 * Class Definition
 * ------------------------------------------------------------------------
 */

var Toast = /*#__PURE__*/function (_BaseComponent) {
  _inherits(Toast, _BaseComponent);

  var _super = _createSuper(Toast);

  function Toast(element, config) {
    var _this;

    _classCallCheck(this, Toast);

    _this = _super.call(this, element);
    _this._config = _this._getConfig(config);
    _this._timeout = null;
    _this._hasMouseInteraction = false;
    _this._hasKeyboardInteraction = false;

    _this._setListeners();

    return _this;
  } // Getters


  _createClass(Toast, [{
    key: "show",
    value: // Public
    function show() {
      var _this2 = this;

      var showEvent = _eventHandler["default"].trigger(this._element, EVENT_SHOW);

      if (showEvent.defaultPrevented) {
        return;
      }

      this._clearTimeout();

      if (this._config.animation) {
        this._element.classList.add(CLASS_NAME_FADE);
      }

      var complete = function complete() {
        _this2._element.classList.remove(CLASS_NAME_SHOWING);

        _eventHandler["default"].trigger(_this2._element, EVENT_SHOWN);

        _this2._maybeScheduleHide();
      };

      this._element.classList.remove(CLASS_NAME_HIDE); // @deprecated


      (0, _index.reflow)(this._element);

      this._element.classList.add(CLASS_NAME_SHOW);

      this._element.classList.add(CLASS_NAME_SHOWING);

      this._queueCallback(complete, this._element, this._config.animation);
    }
  }, {
    key: "hide",
    value: function hide() {
      var _this3 = this;

      if (!this._element.classList.contains(CLASS_NAME_SHOW)) {
        return;
      }

      var hideEvent = _eventHandler["default"].trigger(this._element, EVENT_HIDE);

      if (hideEvent.defaultPrevented) {
        return;
      }

      var complete = function complete() {
        _this3._element.classList.add(CLASS_NAME_HIDE); // @deprecated


        _this3._element.classList.remove(CLASS_NAME_SHOWING);

        _this3._element.classList.remove(CLASS_NAME_SHOW);

        _eventHandler["default"].trigger(_this3._element, EVENT_HIDDEN);
      };

      this._element.classList.add(CLASS_NAME_SHOWING);

      this._queueCallback(complete, this._element, this._config.animation);
    }
  }, {
    key: "dispose",
    value: function dispose() {
      this._clearTimeout();

      if (this._element.classList.contains(CLASS_NAME_SHOW)) {
        this._element.classList.remove(CLASS_NAME_SHOW);
      }

      _get(_getPrototypeOf(Toast.prototype), "dispose", this).call(this);
    } // Private

  }, {
    key: "_getConfig",
    value: function _getConfig(config) {
      config = _objectSpread(_objectSpread(_objectSpread({}, Default), _manipulator["default"].getDataAttributes(this._element)), _typeof(config) === 'object' && config ? config : {});
      (0, _index.typeCheckConfig)(NAME, config, this.constructor.DefaultType);
      return config;
    }
  }, {
    key: "_maybeScheduleHide",
    value: function _maybeScheduleHide() {
      var _this4 = this;

      if (!this._config.autohide) {
        return;
      }

      if (this._hasMouseInteraction || this._hasKeyboardInteraction) {
        return;
      }

      this._timeout = setTimeout(function () {
        _this4.hide();
      }, this._config.delay);
    }
  }, {
    key: "_onInteraction",
    value: function _onInteraction(event, isInteracting) {
      switch (event.type) {
        case 'mouseover':
        case 'mouseout':
          this._hasMouseInteraction = isInteracting;
          break;

        case 'focusin':
        case 'focusout':
          this._hasKeyboardInteraction = isInteracting;
          break;

        default:
          break;
      }

      if (isInteracting) {
        this._clearTimeout();

        return;
      }

      var nextElement = event.relatedTarget;

      if (this._element === nextElement || this._element.contains(nextElement)) {
        return;
      }

      this._maybeScheduleHide();
    }
  }, {
    key: "_setListeners",
    value: function _setListeners() {
      var _this5 = this;

      _eventHandler["default"].on(this._element, EVENT_MOUSEOVER, function (event) {
        return _this5._onInteraction(event, true);
      });

      _eventHandler["default"].on(this._element, EVENT_MOUSEOUT, function (event) {
        return _this5._onInteraction(event, false);
      });

      _eventHandler["default"].on(this._element, EVENT_FOCUSIN, function (event) {
        return _this5._onInteraction(event, true);
      });

      _eventHandler["default"].on(this._element, EVENT_FOCUSOUT, function (event) {
        return _this5._onInteraction(event, false);
      });
    }
  }, {
    key: "_clearTimeout",
    value: function _clearTimeout() {
      clearTimeout(this._timeout);
      this._timeout = null;
    } // Static

  }], [{
    key: "DefaultType",
    get: function get() {
      return DefaultType;
    }
  }, {
    key: "Default",
    get: function get() {
      return Default;
    }
  }, {
    key: "NAME",
    get: function get() {
      return NAME;
    }
  }, {
    key: "jQueryInterface",
    value: function jQueryInterface(config) {
      return this.each(function () {
        var data = Toast.getOrCreateInstance(this, config);

        if (typeof config === 'string') {
          if (typeof data[config] === 'undefined') {
            throw new TypeError("No method named \"".concat(config, "\""));
          }

          data[config](this);
        }
      });
    }
  }]);

  return Toast;
}(_baseComponent["default"]);

(0, _componentFunctions.enableDismissTrigger)(Toast);
/**
 * ------------------------------------------------------------------------
 * jQuery
 * ------------------------------------------------------------------------
 * add .Toast to jQuery only if jQuery is present
 */

(0, _index.defineJQueryPlugin)(Toast);
var _default = Toast;
exports["default"] = _default;
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var Popper = _interopRequireWildcard(require("@popperjs/core"));

var _index = require("./util/index");

var _sanitizer = require("./util/sanitizer");

var _data = _interopRequireDefault(require("./dom/data"));

var _eventHandler = _interopRequireDefault(require("./dom/event-handler"));

var _manipulator = _interopRequireDefault(require("./dom/manipulator"));

var _selectorEngine = _interopRequireDefault(require("./dom/selector-engine"));

var _baseComponent = _interopRequireDefault(require("./base-component"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * ------------------------------------------------------------------------
 * Constants
 * ------------------------------------------------------------------------
 */
var NAME = 'tooltip';
var DATA_KEY = 'bs.tooltip';
var EVENT_KEY = ".".concat(DATA_KEY);
var CLASS_PREFIX = 'bs-tooltip';
var DISALLOWED_ATTRIBUTES = new Set(['sanitize', 'allowList', 'sanitizeFn']);
var DefaultType = {
  animation: 'boolean',
  template: 'string',
  title: '(string|element|function)',
  trigger: 'string',
  delay: '(number|object)',
  html: 'boolean',
  selector: '(string|boolean)',
  placement: '(string|function)',
  offset: '(array|string|function)',
  container: '(string|element|boolean)',
  fallbackPlacements: 'array',
  boundary: '(string|element)',
  customClass: '(string|function)',
  sanitize: 'boolean',
  sanitizeFn: '(null|function)',
  allowList: 'object',
  popperConfig: '(null|object|function)'
};
var AttachmentMap = {
  AUTO: 'auto',
  TOP: 'top',
  RIGHT: (0, _index.isRTL)() ? 'left' : 'right',
  BOTTOM: 'bottom',
  LEFT: (0, _index.isRTL)() ? 'right' : 'left'
};
var Default = {
  animation: true,
  template: '<div class="tooltip" role="tooltip">' + '<div class="tooltip-arrow"></div>' + '<div class="tooltip-inner"></div>' + '</div>',
  trigger: 'hover focus',
  title: '',
  delay: 0,
  html: false,
  selector: false,
  placement: 'top',
  offset: [0, 0],
  container: false,
  fallbackPlacements: ['top', 'right', 'bottom', 'left'],
  boundary: 'clippingParents',
  customClass: '',
  sanitize: true,
  sanitizeFn: null,
  allowList: _sanitizer.DefaultAllowlist,
  popperConfig: null
};
var Event = {
  HIDE: "hide".concat(EVENT_KEY),
  HIDDEN: "hidden".concat(EVENT_KEY),
  SHOW: "show".concat(EVENT_KEY),
  SHOWN: "shown".concat(EVENT_KEY),
  INSERTED: "inserted".concat(EVENT_KEY),
  CLICK: "click".concat(EVENT_KEY),
  FOCUSIN: "focusin".concat(EVENT_KEY),
  FOCUSOUT: "focusout".concat(EVENT_KEY),
  MOUSEENTER: "mouseenter".concat(EVENT_KEY),
  MOUSELEAVE: "mouseleave".concat(EVENT_KEY)
};
var CLASS_NAME_FADE = 'fade';
var CLASS_NAME_MODAL = 'modal';
var CLASS_NAME_SHOW = 'show';
var HOVER_STATE_SHOW = 'show';
var HOVER_STATE_OUT = 'out';
var SELECTOR_TOOLTIP_INNER = '.tooltip-inner';
var SELECTOR_MODAL = ".".concat(CLASS_NAME_MODAL);
var EVENT_MODAL_HIDE = 'hide.bs.modal';
var TRIGGER_HOVER = 'hover';
var TRIGGER_FOCUS = 'focus';
var TRIGGER_CLICK = 'click';
var TRIGGER_MANUAL = 'manual';
/**
 * ------------------------------------------------------------------------
 * Class Definition
 * ------------------------------------------------------------------------
 */

var Tooltip = /*#__PURE__*/function (_BaseComponent) {
  _inherits(Tooltip, _BaseComponent);

  var _super = _createSuper(Tooltip);

  function Tooltip(element, config) {
    var _this;

    _classCallCheck(this, Tooltip);

    if (typeof Popper === 'undefined') {
      throw new TypeError('Bootstrap\'s tooltips require Popper (https://popper.js.org)');
    }

    _this = _super.call(this, element); // private

    _this._isEnabled = true;
    _this._timeout = 0;
    _this._hoverState = '';
    _this._activeTrigger = {};
    _this._popper = null; // Protected

    _this._config = _this._getConfig(config);
    _this.tip = null;

    _this._setListeners();

    return _this;
  } // Getters


  _createClass(Tooltip, [{
    key: "enable",
    value: // Public
    function enable() {
      this._isEnabled = true;
    }
  }, {
    key: "disable",
    value: function disable() {
      this._isEnabled = false;
    }
  }, {
    key: "toggleEnabled",
    value: function toggleEnabled() {
      this._isEnabled = !this._isEnabled;
    }
  }, {
    key: "toggle",
    value: function toggle(event) {
      if (!this._isEnabled) {
        return;
      }

      if (event) {
        var context = this._initializeOnDelegatedTarget(event);

        context._activeTrigger.click = !context._activeTrigger.click;

        if (context._isWithActiveTrigger()) {
          context._enter(null, context);
        } else {
          context._leave(null, context);
        }
      } else {
        if (this.getTipElement().classList.contains(CLASS_NAME_SHOW)) {
          this._leave(null, this);

          return;
        }

        this._enter(null, this);
      }
    }
  }, {
    key: "dispose",
    value: function dispose() {
      clearTimeout(this._timeout);

      _eventHandler["default"].off(this._element.closest(SELECTOR_MODAL), EVENT_MODAL_HIDE, this._hideModalHandler);

      if (this.tip) {
        this.tip.remove();
      }

      this._disposePopper();

      _get(_getPrototypeOf(Tooltip.prototype), "dispose", this).call(this);
    }
  }, {
    key: "show",
    value: function show() {
      var _this2 = this;

      if (this._element.style.display === 'none') {
        throw new Error('Please use show on visible elements');
      }

      if (!(this.isWithContent() && this._isEnabled)) {
        return;
      }

      var showEvent = _eventHandler["default"].trigger(this._element, this.constructor.Event.SHOW);

      var shadowRoot = (0, _index.findShadowRoot)(this._element);
      var isInTheDom = shadowRoot === null ? this._element.ownerDocument.documentElement.contains(this._element) : shadowRoot.contains(this._element);

      if (showEvent.defaultPrevented || !isInTheDom) {
        return;
      } // A trick to recreate a tooltip in case a new title is given by using the NOT documented `data-bs-original-title`
      // This will be removed later in favor of a `setContent` method


      if (this.constructor.NAME === 'tooltip' && this.tip && this.getTitle() !== this.tip.querySelector(SELECTOR_TOOLTIP_INNER).innerHTML) {
        this._disposePopper();

        this.tip.remove();
        this.tip = null;
      }

      var tip = this.getTipElement();
      var tipId = (0, _index.getUID)(this.constructor.NAME);
      tip.setAttribute('id', tipId);

      this._element.setAttribute('aria-describedby', tipId);

      if (this._config.animation) {
        tip.classList.add(CLASS_NAME_FADE);
      }

      var placement = typeof this._config.placement === 'function' ? this._config.placement.call(this, tip, this._element) : this._config.placement;

      var attachment = this._getAttachment(placement);

      this._addAttachmentClass(attachment);

      var container = this._config.container;

      _data["default"].set(tip, this.constructor.DATA_KEY, this);

      if (!this._element.ownerDocument.documentElement.contains(this.tip)) {
        container.append(tip);

        _eventHandler["default"].trigger(this._element, this.constructor.Event.INSERTED);
      }

      if (this._popper) {
        this._popper.update();
      } else {
        this._popper = Popper.createPopper(this._element, tip, this._getPopperConfig(attachment));
      }

      tip.classList.add(CLASS_NAME_SHOW);

      var customClass = this._resolvePossibleFunction(this._config.customClass);

      if (customClass) {
        var _tip$classList;

        (_tip$classList = tip.classList).add.apply(_tip$classList, _toConsumableArray(customClass.split(' ')));
      } // If this is a touch-enabled device we add extra
      // empty mouseover listeners to the body's immediate children;
      // only needed because of broken event delegation on iOS
      // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html


      if ('ontouchstart' in document.documentElement) {
        var _ref;

        (_ref = []).concat.apply(_ref, _toConsumableArray(document.body.children)).forEach(function (element) {
          _eventHandler["default"].on(element, 'mouseover', _index.noop);
        });
      }

      var complete = function complete() {
        var prevHoverState = _this2._hoverState;
        _this2._hoverState = null;

        _eventHandler["default"].trigger(_this2._element, _this2.constructor.Event.SHOWN);

        if (prevHoverState === HOVER_STATE_OUT) {
          _this2._leave(null, _this2);
        }
      };

      var isAnimated = this.tip.classList.contains(CLASS_NAME_FADE);

      this._queueCallback(complete, this.tip, isAnimated);
    }
  }, {
    key: "hide",
    value: function hide() {
      var _this3 = this;

      if (!this._popper) {
        return;
      }

      var tip = this.getTipElement();

      var complete = function complete() {
        if (_this3._isWithActiveTrigger()) {
          return;
        }

        if (_this3._hoverState !== HOVER_STATE_SHOW) {
          tip.remove();
        }

        _this3._cleanTipClass();

        _this3._element.removeAttribute('aria-describedby');

        _eventHandler["default"].trigger(_this3._element, _this3.constructor.Event.HIDDEN);

        _this3._disposePopper();
      };

      var hideEvent = _eventHandler["default"].trigger(this._element, this.constructor.Event.HIDE);

      if (hideEvent.defaultPrevented) {
        return;
      }

      tip.classList.remove(CLASS_NAME_SHOW); // If this is a touch-enabled device we remove the extra
      // empty mouseover listeners we added for iOS support

      if ('ontouchstart' in document.documentElement) {
        var _ref2;

        (_ref2 = []).concat.apply(_ref2, _toConsumableArray(document.body.children)).forEach(function (element) {
          return _eventHandler["default"].off(element, 'mouseover', _index.noop);
        });
      }

      this._activeTrigger[TRIGGER_CLICK] = false;
      this._activeTrigger[TRIGGER_FOCUS] = false;
      this._activeTrigger[TRIGGER_HOVER] = false;
      var isAnimated = this.tip.classList.contains(CLASS_NAME_FADE);

      this._queueCallback(complete, this.tip, isAnimated);

      this._hoverState = '';
    }
  }, {
    key: "update",
    value: function update() {
      if (this._popper !== null) {
        this._popper.update();
      }
    } // Protected

  }, {
    key: "isWithContent",
    value: function isWithContent() {
      return Boolean(this.getTitle());
    }
  }, {
    key: "getTipElement",
    value: function getTipElement() {
      if (this.tip) {
        return this.tip;
      }

      var element = document.createElement('div');
      element.innerHTML = this._config.template;
      var tip = element.children[0];
      this.setContent(tip);
      tip.classList.remove(CLASS_NAME_FADE, CLASS_NAME_SHOW);
      this.tip = tip;
      return this.tip;
    }
  }, {
    key: "setContent",
    value: function setContent(tip) {
      this._sanitizeAndSetContent(tip, this.getTitle(), SELECTOR_TOOLTIP_INNER);
    }
  }, {
    key: "_sanitizeAndSetContent",
    value: function _sanitizeAndSetContent(template, content, selector) {
      var templateElement = _selectorEngine["default"].findOne(selector, template);

      if (!content && templateElement) {
        templateElement.remove();
        return;
      } // we use append for html objects to maintain js events


      this.setElementContent(templateElement, content);
    }
  }, {
    key: "setElementContent",
    value: function setElementContent(element, content) {
      if (element === null) {
        return;
      }

      if ((0, _index.isElement)(content)) {
        content = (0, _index.getElement)(content); // content is a DOM node or a jQuery

        if (this._config.html) {
          if (content.parentNode !== element) {
            element.innerHTML = '';
            element.append(content);
          }
        } else {
          element.textContent = content.textContent;
        }

        return;
      }

      if (this._config.html) {
        if (this._config.sanitize) {
          content = (0, _sanitizer.sanitizeHtml)(content, this._config.allowList, this._config.sanitizeFn);
        }

        element.innerHTML = content;
      } else {
        element.textContent = content;
      }
    }
  }, {
    key: "getTitle",
    value: function getTitle() {
      var title = this._element.getAttribute('data-bs-original-title') || this._config.title;

      return this._resolvePossibleFunction(title);
    }
  }, {
    key: "updateAttachment",
    value: function updateAttachment(attachment) {
      if (attachment === 'right') {
        return 'end';
      }

      if (attachment === 'left') {
        return 'start';
      }

      return attachment;
    } // Private

  }, {
    key: "_initializeOnDelegatedTarget",
    value: function _initializeOnDelegatedTarget(event, context) {
      return context || this.constructor.getOrCreateInstance(event.delegateTarget, this._getDelegateConfig());
    }
  }, {
    key: "_getOffset",
    value: function _getOffset() {
      var _this4 = this;

      var offset = this._config.offset;

      if (typeof offset === 'string') {
        return offset.split(',').map(function (val) {
          return Number.parseInt(val, 10);
        });
      }

      if (typeof offset === 'function') {
        return function (popperData) {
          return offset(popperData, _this4._element);
        };
      }

      return offset;
    }
  }, {
    key: "_resolvePossibleFunction",
    value: function _resolvePossibleFunction(content) {
      return typeof content === 'function' ? content.call(this._element) : content;
    }
  }, {
    key: "_getPopperConfig",
    value: function _getPopperConfig(attachment) {
      var _this5 = this;

      var defaultBsPopperConfig = {
        placement: attachment,
        modifiers: [{
          name: 'flip',
          options: {
            fallbackPlacements: this._config.fallbackPlacements
          }
        }, {
          name: 'offset',
          options: {
            offset: this._getOffset()
          }
        }, {
          name: 'preventOverflow',
          options: {
            boundary: this._config.boundary
          }
        }, {
          name: 'arrow',
          options: {
            element: ".".concat(this.constructor.NAME, "-arrow")
          }
        }, {
          name: 'onChange',
          enabled: true,
          phase: 'afterWrite',
          fn: function fn(data) {
            return _this5._handlePopperPlacementChange(data);
          }
        }],
        onFirstUpdate: function onFirstUpdate(data) {
          if (data.options.placement !== data.placement) {
            _this5._handlePopperPlacementChange(data);
          }
        }
      };
      return _objectSpread(_objectSpread({}, defaultBsPopperConfig), typeof this._config.popperConfig === 'function' ? this._config.popperConfig(defaultBsPopperConfig) : this._config.popperConfig);
    }
  }, {
    key: "_addAttachmentClass",
    value: function _addAttachmentClass(attachment) {
      this.getTipElement().classList.add("".concat(this._getBasicClassPrefix(), "-").concat(this.updateAttachment(attachment)));
    }
  }, {
    key: "_getAttachment",
    value: function _getAttachment(placement) {
      return AttachmentMap[placement.toUpperCase()];
    }
  }, {
    key: "_setListeners",
    value: function _setListeners() {
      var _this6 = this;

      var triggers = this._config.trigger.split(' ');

      triggers.forEach(function (trigger) {
        if (trigger === 'click') {
          _eventHandler["default"].on(_this6._element, _this6.constructor.Event.CLICK, _this6._config.selector, function (event) {
            return _this6.toggle(event);
          });
        } else if (trigger !== TRIGGER_MANUAL) {
          var eventIn = trigger === TRIGGER_HOVER ? _this6.constructor.Event.MOUSEENTER : _this6.constructor.Event.FOCUSIN;
          var eventOut = trigger === TRIGGER_HOVER ? _this6.constructor.Event.MOUSELEAVE : _this6.constructor.Event.FOCUSOUT;

          _eventHandler["default"].on(_this6._element, eventIn, _this6._config.selector, function (event) {
            return _this6._enter(event);
          });

          _eventHandler["default"].on(_this6._element, eventOut, _this6._config.selector, function (event) {
            return _this6._leave(event);
          });
        }
      });

      this._hideModalHandler = function () {
        if (_this6._element) {
          _this6.hide();
        }
      };

      _eventHandler["default"].on(this._element.closest(SELECTOR_MODAL), EVENT_MODAL_HIDE, this._hideModalHandler);

      if (this._config.selector) {
        this._config = _objectSpread(_objectSpread({}, this._config), {}, {
          trigger: 'manual',
          selector: ''
        });
      } else {
        this._fixTitle();
      }
    }
  }, {
    key: "_fixTitle",
    value: function _fixTitle() {
      var title = this._element.getAttribute('title');

      var originalTitleType = _typeof(this._element.getAttribute('data-bs-original-title'));

      if (title || originalTitleType !== 'string') {
        this._element.setAttribute('data-bs-original-title', title || '');

        if (title && !this._element.getAttribute('aria-label') && !this._element.textContent) {
          this._element.setAttribute('aria-label', title);
        }

        this._element.setAttribute('title', '');
      }
    }
  }, {
    key: "_enter",
    value: function _enter(event, context) {
      context = this._initializeOnDelegatedTarget(event, context);

      if (event) {
        context._activeTrigger[event.type === 'focusin' ? TRIGGER_FOCUS : TRIGGER_HOVER] = true;
      }

      if (context.getTipElement().classList.contains(CLASS_NAME_SHOW) || context._hoverState === HOVER_STATE_SHOW) {
        context._hoverState = HOVER_STATE_SHOW;
        return;
      }

      clearTimeout(context._timeout);
      context._hoverState = HOVER_STATE_SHOW;

      if (!context._config.delay || !context._config.delay.show) {
        context.show();
        return;
      }

      context._timeout = setTimeout(function () {
        if (context._hoverState === HOVER_STATE_SHOW) {
          context.show();
        }
      }, context._config.delay.show);
    }
  }, {
    key: "_leave",
    value: function _leave(event, context) {
      context = this._initializeOnDelegatedTarget(event, context);

      if (event) {
        context._activeTrigger[event.type === 'focusout' ? TRIGGER_FOCUS : TRIGGER_HOVER] = context._element.contains(event.relatedTarget);
      }

      if (context._isWithActiveTrigger()) {
        return;
      }

      clearTimeout(context._timeout);
      context._hoverState = HOVER_STATE_OUT;

      if (!context._config.delay || !context._config.delay.hide) {
        context.hide();
        return;
      }

      context._timeout = setTimeout(function () {
        if (context._hoverState === HOVER_STATE_OUT) {
          context.hide();
        }
      }, context._config.delay.hide);
    }
  }, {
    key: "_isWithActiveTrigger",
    value: function _isWithActiveTrigger() {
      for (var trigger in this._activeTrigger) {
        if (this._activeTrigger[trigger]) {
          return true;
        }
      }

      return false;
    }
  }, {
    key: "_getConfig",
    value: function _getConfig(config) {
      var dataAttributes = _manipulator["default"].getDataAttributes(this._element);

      Object.keys(dataAttributes).forEach(function (dataAttr) {
        if (DISALLOWED_ATTRIBUTES.has(dataAttr)) {
          delete dataAttributes[dataAttr];
        }
      });
      config = _objectSpread(_objectSpread(_objectSpread({}, this.constructor.Default), dataAttributes), _typeof(config) === 'object' && config ? config : {});
      config.container = config.container === false ? document.body : (0, _index.getElement)(config.container);

      if (typeof config.delay === 'number') {
        config.delay = {
          show: config.delay,
          hide: config.delay
        };
      }

      if (typeof config.title === 'number') {
        config.title = config.title.toString();
      }

      if (typeof config.content === 'number') {
        config.content = config.content.toString();
      }

      (0, _index.typeCheckConfig)(NAME, config, this.constructor.DefaultType);

      if (config.sanitize) {
        config.template = (0, _sanitizer.sanitizeHtml)(config.template, config.allowList, config.sanitizeFn);
      }

      return config;
    }
  }, {
    key: "_getDelegateConfig",
    value: function _getDelegateConfig() {
      var config = {};

      for (var key in this._config) {
        if (this.constructor.Default[key] !== this._config[key]) {
          config[key] = this._config[key];
        }
      } // In the future can be replaced with:
      // const keysWithDifferentValues = Object.entries(this._config).filter(entry => this.constructor.Default[entry[0]] !== this._config[entry[0]])
      // `Object.fromEntries(keysWithDifferentValues)`


      return config;
    }
  }, {
    key: "_cleanTipClass",
    value: function _cleanTipClass() {
      var tip = this.getTipElement();
      var basicClassPrefixRegex = new RegExp("(^|\\s)".concat(this._getBasicClassPrefix(), "\\S+"), 'g');
      var tabClass = tip.getAttribute('class').match(basicClassPrefixRegex);

      if (tabClass !== null && tabClass.length > 0) {
        tabClass.map(function (token) {
          return token.trim();
        }).forEach(function (tClass) {
          return tip.classList.remove(tClass);
        });
      }
    }
  }, {
    key: "_getBasicClassPrefix",
    value: function _getBasicClassPrefix() {
      return CLASS_PREFIX;
    }
  }, {
    key: "_handlePopperPlacementChange",
    value: function _handlePopperPlacementChange(popperData) {
      var state = popperData.state;

      if (!state) {
        return;
      }

      this.tip = state.elements.popper;

      this._cleanTipClass();

      this._addAttachmentClass(this._getAttachment(state.placement));
    }
  }, {
    key: "_disposePopper",
    value: function _disposePopper() {
      if (this._popper) {
        this._popper.destroy();

        this._popper = null;
      }
    } // Static

  }], [{
    key: "Default",
    get: function get() {
      return Default;
    }
  }, {
    key: "NAME",
    get: function get() {
      return NAME;
    }
  }, {
    key: "Event",
    get: function get() {
      return Event;
    }
  }, {
    key: "DefaultType",
    get: function get() {
      return DefaultType;
    }
  }, {
    key: "jQueryInterface",
    value: function jQueryInterface(config) {
      return this.each(function () {
        var data = Tooltip.getOrCreateInstance(this, config);

        if (typeof config === 'string') {
          if (typeof data[config] === 'undefined') {
            throw new TypeError("No method named \"".concat(config, "\""));
          }

          data[config]();
        }
      });
    }
  }]);

  return Tooltip;
}(_baseComponent["default"]);
/**
 * ------------------------------------------------------------------------
 * jQuery
 * ------------------------------------------------------------------------
 * add .Tooltip to jQuery only if jQuery is present
 */


(0, _index.defineJQueryPlugin)(Tooltip);
var _default = Tooltip;
exports["default"] = _default;
"use strict";

/* eslint-env node */

/* eslint-disable camelcase */
var browsers = {
  safariMac: {
    base: 'BrowserStack',
    os: 'OS X',
    os_version: 'Catalina',
    browser: 'Safari',
    browser_version: 'latest'
  },
  chromeMac: {
    base: 'BrowserStack',
    os: 'OS X',
    os_version: 'Catalina',
    browser: 'Chrome',
    browser_version: 'latest'
  },
  firefoxMac: {
    base: 'BrowserStack',
    os: 'OS X',
    os_version: 'Catalina',
    browser: 'Firefox',
    browser_version: 'latest'
  },
  chromeWin10: {
    base: 'BrowserStack',
    os: 'Windows',
    os_version: '10',
    browser: 'Chrome',
    browser_version: '60'
  },
  firefoxWin10: {
    base: 'BrowserStack',
    os: 'Windows',
    os_version: '10',
    browser: 'Firefox',
    browser_version: '60'
  },
  chromeWin10Latest: {
    base: 'BrowserStack',
    os: 'Windows',
    os_version: '10',
    browser: 'Chrome',
    browser_version: 'latest'
  },
  firefoxWin10Latest: {
    base: 'BrowserStack',
    os: 'Windows',
    os_version: '10',
    browser: 'Firefox',
    browser_version: 'latest'
  },
  iphone7: {
    base: 'BrowserStack',
    os: 'ios',
    os_version: '12.0',
    device: 'iPhone 7',
    real_mobile: true
  },
  iphone12: {
    base: 'BrowserStack',
    os: 'ios',
    os_version: '14.0',
    device: 'iPhone 12',
    real_mobile: true
  },
  pixel2: {
    base: 'BrowserStack',
    os: 'android',
    os_version: '8.0',
    device: 'Google Pixel 2',
    real_mobile: true
  }
};
var browsersKeys = Object.keys(browsers);
module.exports = {
  browsers: browsers,
  browsersKeys: browsersKeys
};
/* eslint-env node */
'use strict';

var path = require('path');

var ip = require('ip');

var _require = require('@rollup/plugin-babel'),
    babel = _require.babel;

var istanbul = require('rollup-plugin-istanbul');

var _require2 = require('@rollup/plugin-node-resolve'),
    nodeResolve = _require2.nodeResolve;

var replace = require('@rollup/plugin-replace');

var _require3 = require('./browsers'),
    browsers = _require3.browsers,
    browsersKeys = _require3.browsersKeys;

var ENV = process.env;
var BROWSERSTACK = Boolean(ENV.BROWSERSTACK);
var DEBUG = Boolean(ENV.DEBUG);
var JQUERY_TEST = Boolean(ENV.JQUERY);
var frameworks = ['jasmine'];
var plugins = ['karma-jasmine', 'karma-rollup-preprocessor'];
var reporters = ['dots'];
var detectBrowsers = {
  usePhantomJS: false,
  postDetection: function postDetection(availableBrowser) {
    // On CI just use Chrome
    if (ENV.CI === true) {
      return ['ChromeHeadless'];
    }

    if (availableBrowser.includes('Chrome')) {
      return DEBUG ? ['Chrome'] : ['ChromeHeadless'];
    }

    if (availableBrowser.includes('Chromium')) {
      return DEBUG ? ['Chromium'] : ['ChromiumHeadless'];
    }

    if (availableBrowser.includes('Firefox')) {
      return DEBUG ? ['Firefox'] : ['FirefoxHeadless'];
    }

    throw new Error('Please install Chrome, Chromium or Firefox');
  }
};
var conf = {
  basePath: '../..',
  port: 9876,
  colors: true,
  autoWatch: false,
  singleRun: true,
  concurrency: Number.POSITIVE_INFINITY,
  client: {
    clearContext: false
  },
  files: ['node_modules/hammer-simulator/index.js', {
    pattern: 'js/tests/unit/**/!(jquery).spec.js',
    watched: !BROWSERSTACK
  }],
  preprocessors: {
    'js/tests/unit/**/*.spec.js': ['rollup']
  },
  rollupPreprocessor: {
    plugins: [replace({
      'process.env.NODE_ENV': '"dev"',
      preventAssignment: true
    }), istanbul({
      exclude: ['node_modules/**', 'js/tests/unit/**/*.spec.js', 'js/tests/helpers/**/*.js']
    }), babel({
      // Only transpile our source code
      exclude: 'node_modules/**',
      // Inline the required helpers in each file
      babelHelpers: 'inline'
    }), nodeResolve()],
    output: {
      format: 'iife',
      name: 'bootstrapTest',
      sourcemap: 'inline',
      generatedCode: 'es2015'
    }
  }
};

if (BROWSERSTACK) {
  conf.hostname = ip.address();
  conf.browserStack = {
    username: ENV.BROWSER_STACK_USERNAME,
    accessKey: ENV.BROWSER_STACK_ACCESS_KEY,
    build: "bootstrap-".concat(ENV.GITHUB_SHA ? ENV.GITHUB_SHA.slice(0, 7) + '-' : '').concat(new Date().toISOString()),
    project: 'Bootstrap',
    retryLimit: 2
  };
  plugins.push('karma-browserstack-launcher', 'karma-jasmine-html-reporter');
  conf.customLaunchers = browsers;
  conf.browsers = browsersKeys;
  reporters.push('BrowserStack', 'kjhtml');
} else if (JQUERY_TEST) {
  frameworks.push('detectBrowsers');
  plugins.push('karma-chrome-launcher', 'karma-firefox-launcher', 'karma-detect-browsers');
  conf.detectBrowsers = detectBrowsers;
  conf.files = ['node_modules/jquery/dist/jquery.slim.min.js', {
    pattern: 'js/tests/unit/jquery.spec.js',
    watched: false
  }];
} else {
  frameworks.push('detectBrowsers');
  plugins.push('karma-chrome-launcher', 'karma-firefox-launcher', 'karma-detect-browsers', 'karma-coverage-istanbul-reporter');
  reporters.push('coverage-istanbul');
  conf.detectBrowsers = detectBrowsers;
  conf.coverageIstanbulReporter = {
    dir: path.resolve(__dirname, '../coverage/'),
    reports: ['lcov', 'text-summary'],
    thresholds: {
      emitWarning: false,
      global: {
        statements: 90,
        branches: 89,
        functions: 90,
        lines: 90
      }
    }
  };

  if (DEBUG) {
    conf.hostname = ip.address();
    plugins.push('karma-jasmine-html-reporter');
    reporters.push('kjhtml');
    conf.singleRun = false;
    conf.autoWatch = true;
  }
}

conf.frameworks = frameworks;
conf.plugins = plugins;
conf.reporters = reporters;

module.exports = function (karmaConfig) {
  conf.logLevel = karmaConfig.LOG_ERROR;
  karmaConfig.set(conf);
};
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/*!
  * Bootstrap data.js v5.1.3 (https://getbootstrap.com/)
  * Copyright 2011-2021 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
  */
(function (global, factory) {
  (typeof exports === "undefined" ? "undefined" : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.Data = factory());
})(void 0, function () {
  'use strict';
  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v5.1.3): dom/data.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */

  /**
   * ------------------------------------------------------------------------
   * Constants
   * ------------------------------------------------------------------------
   */

  var elementMap = new Map();
  var data = {
    set: function set(element, key, instance) {
      if (!elementMap.has(element)) {
        elementMap.set(element, new Map());
      }

      var instanceMap = elementMap.get(element); // make it clear we only want one instance per element
      // can be removed later when multiple key/instances are fine to be used

      if (!instanceMap.has(key) && instanceMap.size !== 0) {
        // eslint-disable-next-line no-console
        console.error("Bootstrap doesn't allow more than one instance per element. Bound instance: ".concat(Array.from(instanceMap.keys())[0], "."));
        return;
      }

      instanceMap.set(key, instance);
    },
    get: function get(element, key) {
      if (elementMap.has(element)) {
        return elementMap.get(element).get(key) || null;
      }

      return null;
    },
    remove: function remove(element, key) {
      if (!elementMap.has(element)) {
        return;
      }

      var instanceMap = elementMap.get(element);
      instanceMap["delete"](key); // free up element references if there are no instances left for an element

      if (instanceMap.size === 0) {
        elementMap["delete"](element);
      }
    }
  };
  return data;
});
"use strict";

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/*!
  * Bootstrap event-handler.js v5.1.3 (https://getbootstrap.com/)
  * Copyright 2011-2021 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
  */
(function (global, factory) {
  (typeof exports === "undefined" ? "undefined" : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.EventHandler = factory());
})(void 0, function () {
  'use strict';
  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v5.1.3): util/index.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */

  var getjQuery = function getjQuery() {
    var _window = window,
        jQuery = _window.jQuery;

    if (jQuery && !document.body.hasAttribute('data-bs-no-jquery')) {
      return jQuery;
    }

    return null;
  };
  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v5.1.3): dom/event-handler.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */

  /**
   * ------------------------------------------------------------------------
   * Constants
   * ------------------------------------------------------------------------
   */


  var namespaceRegex = /[^.]*(?=\..*)\.|.*/;
  var stripNameRegex = /\..*/;
  var stripUidRegex = /::\d+$/;
  var eventRegistry = {}; // Events storage

  var uidEvent = 1;
  var customEvents = {
    mouseenter: 'mouseover',
    mouseleave: 'mouseout'
  };
  var customEventsRegex = /^(mouseenter|mouseleave)/i;
  var nativeEvents = new Set(['click', 'dblclick', 'mouseup', 'mousedown', 'contextmenu', 'mousewheel', 'DOMMouseScroll', 'mouseover', 'mouseout', 'mousemove', 'selectstart', 'selectend', 'keydown', 'keypress', 'keyup', 'orientationchange', 'touchstart', 'touchmove', 'touchend', 'touchcancel', 'pointerdown', 'pointermove', 'pointerup', 'pointerleave', 'pointercancel', 'gesturestart', 'gesturechange', 'gestureend', 'focus', 'blur', 'change', 'reset', 'select', 'submit', 'focusin', 'focusout', 'load', 'unload', 'beforeunload', 'resize', 'move', 'DOMContentLoaded', 'readystatechange', 'error', 'abort', 'scroll']);
  /**
   * ------------------------------------------------------------------------
   * Private methods
   * ------------------------------------------------------------------------
   */

  function getUidEvent(element, uid) {
    return uid && "".concat(uid, "::").concat(uidEvent++) || element.uidEvent || uidEvent++;
  }

  function getEvent(element) {
    var uid = getUidEvent(element);
    element.uidEvent = uid;
    eventRegistry[uid] = eventRegistry[uid] || {};
    return eventRegistry[uid];
  }

  function bootstrapHandler(element, fn) {
    return function handler(event) {
      event.delegateTarget = element;

      if (handler.oneOff) {
        EventHandler.off(element, event.type, fn);
      }

      return fn.apply(element, [event]);
    };
  }

  function bootstrapDelegationHandler(element, selector, fn) {
    return function handler(event) {
      var domElements = element.querySelectorAll(selector);

      for (var target = event.target; target && target !== this; target = target.parentNode) {
        for (var i = domElements.length; i--;) {
          if (domElements[i] === target) {
            event.delegateTarget = target;

            if (handler.oneOff) {
              EventHandler.off(element, event.type, selector, fn);
            }

            return fn.apply(target, [event]);
          }
        }
      } // To please ESLint


      return null;
    };
  }

  function findHandler(events, handler) {
    var delegationSelector = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var uidEventList = Object.keys(events);

    for (var i = 0, len = uidEventList.length; i < len; i++) {
      var event = events[uidEventList[i]];

      if (event.originalHandler === handler && event.delegationSelector === delegationSelector) {
        return event;
      }
    }

    return null;
  }

  function normalizeParams(originalTypeEvent, handler, delegationFn) {
    var delegation = typeof handler === 'string';
    var originalHandler = delegation ? delegationFn : handler;
    var typeEvent = getTypeEvent(originalTypeEvent);
    var isNative = nativeEvents.has(typeEvent);

    if (!isNative) {
      typeEvent = originalTypeEvent;
    }

    return [delegation, originalHandler, typeEvent];
  }

  function addHandler(element, originalTypeEvent, handler, delegationFn, oneOff) {
    if (typeof originalTypeEvent !== 'string' || !element) {
      return;
    }

    if (!handler) {
      handler = delegationFn;
      delegationFn = null;
    } // in case of mouseenter or mouseleave wrap the handler within a function that checks for its DOM position
    // this prevents the handler from being dispatched the same way as mouseover or mouseout does


    if (customEventsRegex.test(originalTypeEvent)) {
      var wrapFn = function wrapFn(fn) {
        return function (event) {
          if (!event.relatedTarget || event.relatedTarget !== event.delegateTarget && !event.delegateTarget.contains(event.relatedTarget)) {
            return fn.call(this, event);
          }
        };
      };

      if (delegationFn) {
        delegationFn = wrapFn(delegationFn);
      } else {
        handler = wrapFn(handler);
      }
    }

    var _normalizeParams = normalizeParams(originalTypeEvent, handler, delegationFn),
        _normalizeParams2 = _slicedToArray(_normalizeParams, 3),
        delegation = _normalizeParams2[0],
        originalHandler = _normalizeParams2[1],
        typeEvent = _normalizeParams2[2];

    var events = getEvent(element);
    var handlers = events[typeEvent] || (events[typeEvent] = {});
    var previousFn = findHandler(handlers, originalHandler, delegation ? handler : null);

    if (previousFn) {
      previousFn.oneOff = previousFn.oneOff && oneOff;
      return;
    }

    var uid = getUidEvent(originalHandler, originalTypeEvent.replace(namespaceRegex, ''));
    var fn = delegation ? bootstrapDelegationHandler(element, handler, delegationFn) : bootstrapHandler(element, handler);
    fn.delegationSelector = delegation ? handler : null;
    fn.originalHandler = originalHandler;
    fn.oneOff = oneOff;
    fn.uidEvent = uid;
    handlers[uid] = fn;
    element.addEventListener(typeEvent, fn, delegation);
  }

  function removeHandler(element, events, typeEvent, handler, delegationSelector) {
    var fn = findHandler(events[typeEvent], handler, delegationSelector);

    if (!fn) {
      return;
    }

    element.removeEventListener(typeEvent, fn, Boolean(delegationSelector));
    delete events[typeEvent][fn.uidEvent];
  }

  function removeNamespacedHandlers(element, events, typeEvent, namespace) {
    var storeElementEvent = events[typeEvent] || {};
    Object.keys(storeElementEvent).forEach(function (handlerKey) {
      if (handlerKey.includes(namespace)) {
        var event = storeElementEvent[handlerKey];
        removeHandler(element, events, typeEvent, event.originalHandler, event.delegationSelector);
      }
    });
  }

  function getTypeEvent(event) {
    // allow to get the native events from namespaced events ('click.bs.button' --> 'click')
    event = event.replace(stripNameRegex, '');
    return customEvents[event] || event;
  }

  var EventHandler = {
    on: function on(element, event, handler, delegationFn) {
      addHandler(element, event, handler, delegationFn, false);
    },
    one: function one(element, event, handler, delegationFn) {
      addHandler(element, event, handler, delegationFn, true);
    },
    off: function off(element, originalTypeEvent, handler, delegationFn) {
      if (typeof originalTypeEvent !== 'string' || !element) {
        return;
      }

      var _normalizeParams3 = normalizeParams(originalTypeEvent, handler, delegationFn),
          _normalizeParams4 = _slicedToArray(_normalizeParams3, 3),
          delegation = _normalizeParams4[0],
          originalHandler = _normalizeParams4[1],
          typeEvent = _normalizeParams4[2];

      var inNamespace = typeEvent !== originalTypeEvent;
      var events = getEvent(element);
      var isNamespace = originalTypeEvent.startsWith('.');

      if (typeof originalHandler !== 'undefined') {
        // Simplest case: handler is passed, remove that listener ONLY.
        if (!events || !events[typeEvent]) {
          return;
        }

        removeHandler(element, events, typeEvent, originalHandler, delegation ? handler : null);
        return;
      }

      if (isNamespace) {
        Object.keys(events).forEach(function (elementEvent) {
          removeNamespacedHandlers(element, events, elementEvent, originalTypeEvent.slice(1));
        });
      }

      var storeElementEvent = events[typeEvent] || {};
      Object.keys(storeElementEvent).forEach(function (keyHandlers) {
        var handlerKey = keyHandlers.replace(stripUidRegex, '');

        if (!inNamespace || originalTypeEvent.includes(handlerKey)) {
          var event = storeElementEvent[keyHandlers];
          removeHandler(element, events, typeEvent, event.originalHandler, event.delegationSelector);
        }
      });
    },
    trigger: function trigger(element, event, args) {
      if (typeof event !== 'string' || !element) {
        return null;
      }

      var $ = getjQuery();
      var typeEvent = getTypeEvent(event);
      var inNamespace = event !== typeEvent;
      var isNative = nativeEvents.has(typeEvent);
      var jQueryEvent;
      var bubbles = true;
      var nativeDispatch = true;
      var defaultPrevented = false;
      var evt = null;

      if (inNamespace && $) {
        jQueryEvent = $.Event(event, args);
        $(element).trigger(jQueryEvent);
        bubbles = !jQueryEvent.isPropagationStopped();
        nativeDispatch = !jQueryEvent.isImmediatePropagationStopped();
        defaultPrevented = jQueryEvent.isDefaultPrevented();
      }

      if (isNative) {
        evt = document.createEvent('HTMLEvents');
        evt.initEvent(typeEvent, bubbles, true);
      } else {
        evt = new CustomEvent(event, {
          bubbles: bubbles,
          cancelable: true
        });
      } // merge custom information in our event


      if (typeof args !== 'undefined') {
        Object.keys(args).forEach(function (key) {
          Object.defineProperty(evt, key, {
            get: function get() {
              return args[key];
            }
          });
        });
      }

      if (defaultPrevented) {
        evt.preventDefault();
      }

      if (nativeDispatch) {
        element.dispatchEvent(evt);
      }

      if (evt.defaultPrevented && typeof jQueryEvent !== 'undefined') {
        jQueryEvent.preventDefault();
      }

      return evt;
    }
  };
  return EventHandler;
});
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/*!
  * Bootstrap manipulator.js v5.1.3 (https://getbootstrap.com/)
  * Copyright 2011-2021 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
  */
(function (global, factory) {
  (typeof exports === "undefined" ? "undefined" : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.Manipulator = factory());
})(void 0, function () {
  'use strict';
  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v5.1.3): dom/manipulator.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */

  function normalizeData(val) {
    if (val === 'true') {
      return true;
    }

    if (val === 'false') {
      return false;
    }

    if (val === Number(val).toString()) {
      return Number(val);
    }

    if (val === '' || val === 'null') {
      return null;
    }

    return val;
  }

  function normalizeDataKey(key) {
    return key.replace(/[A-Z]/g, function (chr) {
      return "-".concat(chr.toLowerCase());
    });
  }

  var Manipulator = {
    setDataAttribute: function setDataAttribute(element, key, value) {
      element.setAttribute("data-bs-".concat(normalizeDataKey(key)), value);
    },
    removeDataAttribute: function removeDataAttribute(element, key) {
      element.removeAttribute("data-bs-".concat(normalizeDataKey(key)));
    },
    getDataAttributes: function getDataAttributes(element) {
      if (!element) {
        return {};
      }

      var attributes = {};
      Object.keys(element.dataset).filter(function (key) {
        return key.startsWith('bs');
      }).forEach(function (key) {
        var pureKey = key.replace(/^bs/, '');
        pureKey = pureKey.charAt(0).toLowerCase() + pureKey.slice(1, pureKey.length);
        attributes[pureKey] = normalizeData(element.dataset[key]);
      });
      return attributes;
    },
    getDataAttribute: function getDataAttribute(element, key) {
      return normalizeData(element.getAttribute("data-bs-".concat(normalizeDataKey(key))));
    },
    offset: function offset(element) {
      var rect = element.getBoundingClientRect();
      return {
        top: rect.top + window.pageYOffset,
        left: rect.left + window.pageXOffset
      };
    },
    position: function position(element) {
      return {
        top: element.offsetTop,
        left: element.offsetLeft
      };
    }
  };
  return Manipulator;
});
"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/*!
  * Bootstrap selector-engine.js v5.1.3 (https://getbootstrap.com/)
  * Copyright 2011-2021 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
  */
(function (global, factory) {
  (typeof exports === "undefined" ? "undefined" : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.SelectorEngine = factory());
})(void 0, function () {
  'use strict';
  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v5.1.3): util/index.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */

  var isElement = function isElement(obj) {
    if (!obj || _typeof(obj) !== 'object') {
      return false;
    }

    if (typeof obj.jquery !== 'undefined') {
      obj = obj[0];
    }

    return typeof obj.nodeType !== 'undefined';
  };

  var isVisible = function isVisible(element) {
    if (!isElement(element) || element.getClientRects().length === 0) {
      return false;
    }

    return getComputedStyle(element).getPropertyValue('visibility') === 'visible';
  };

  var isDisabled = function isDisabled(element) {
    if (!element || element.nodeType !== Node.ELEMENT_NODE) {
      return true;
    }

    if (element.classList.contains('disabled')) {
      return true;
    }

    if (typeof element.disabled !== 'undefined') {
      return element.disabled;
    }

    return element.hasAttribute('disabled') && element.getAttribute('disabled') !== 'false';
  };
  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v5.1.3): dom/selector-engine.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */


  var NODE_TEXT = 3;
  var SelectorEngine = {
    find: function find(selector) {
      var _ref;

      var element = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : document.documentElement;
      return (_ref = []).concat.apply(_ref, _toConsumableArray(Element.prototype.querySelectorAll.call(element, selector)));
    },
    findOne: function findOne(selector) {
      var element = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : document.documentElement;
      return Element.prototype.querySelector.call(element, selector);
    },
    children: function children(element, selector) {
      var _ref2;

      return (_ref2 = []).concat.apply(_ref2, _toConsumableArray(element.children)).filter(function (child) {
        return child.matches(selector);
      });
    },
    parents: function parents(element, selector) {
      var parents = [];
      var ancestor = element.parentNode;

      while (ancestor && ancestor.nodeType === Node.ELEMENT_NODE && ancestor.nodeType !== NODE_TEXT) {
        if (ancestor.matches(selector)) {
          parents.push(ancestor);
        }

        ancestor = ancestor.parentNode;
      }

      return parents;
    },
    prev: function prev(element, selector) {
      var previous = element.previousElementSibling;

      while (previous) {
        if (previous.matches(selector)) {
          return [previous];
        }

        previous = previous.previousElementSibling;
      }

      return [];
    },
    next: function next(element, selector) {
      var next = element.nextElementSibling;

      while (next) {
        if (next.matches(selector)) {
          return [next];
        }

        next = next.nextElementSibling;
      }

      return [];
    },
    focusableChildren: function focusableChildren(element) {
      var focusables = ['a', 'button', 'input', 'textarea', 'select', 'details', '[tabindex]', '[contenteditable="true"]'].map(function (selector) {
        return "".concat(selector, ":not([tabindex^=\"-\"])");
      }).join(', ');
      return this.find(focusables, element).filter(function (el) {
        return !isDisabled(el) && isVisible(el);
      });
    }
  };
  return SelectorEngine;
});
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

/**
 * --------------------------------------------------------------------------
 * Bootstrap (v5.1.3): dom/data.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */

/**
 * ------------------------------------------------------------------------
 * Constants
 * ------------------------------------------------------------------------
 */
var elementMap = new Map();
var _default = {
  set: function set(element, key, instance) {
    if (!elementMap.has(element)) {
      elementMap.set(element, new Map());
    }

    var instanceMap = elementMap.get(element); // make it clear we only want one instance per element
    // can be removed later when multiple key/instances are fine to be used

    if (!instanceMap.has(key) && instanceMap.size !== 0) {
      // eslint-disable-next-line no-console
      console.error("Bootstrap doesn't allow more than one instance per element. Bound instance: ".concat(Array.from(instanceMap.keys())[0], "."));
      return;
    }

    instanceMap.set(key, instance);
  },
  get: function get(element, key) {
    if (elementMap.has(element)) {
      return elementMap.get(element).get(key) || null;
    }

    return null;
  },
  remove: function remove(element, key) {
    if (!elementMap.has(element)) {
      return;
    }

    var instanceMap = elementMap.get(element);
    instanceMap["delete"](key); // free up element references if there are no instances left for an element

    if (instanceMap.size === 0) {
      elementMap["delete"](element);
    }
  }
};
exports["default"] = _default;
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _index = require("../util/index");

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

/**
 * ------------------------------------------------------------------------
 * Constants
 * ------------------------------------------------------------------------
 */
var namespaceRegex = /[^.]*(?=\..*)\.|.*/;
var stripNameRegex = /\..*/;
var stripUidRegex = /::\d+$/;
var eventRegistry = {}; // Events storage

var uidEvent = 1;
var customEvents = {
  mouseenter: 'mouseover',
  mouseleave: 'mouseout'
};
var customEventsRegex = /^(mouseenter|mouseleave)/i;
var nativeEvents = new Set(['click', 'dblclick', 'mouseup', 'mousedown', 'contextmenu', 'mousewheel', 'DOMMouseScroll', 'mouseover', 'mouseout', 'mousemove', 'selectstart', 'selectend', 'keydown', 'keypress', 'keyup', 'orientationchange', 'touchstart', 'touchmove', 'touchend', 'touchcancel', 'pointerdown', 'pointermove', 'pointerup', 'pointerleave', 'pointercancel', 'gesturestart', 'gesturechange', 'gestureend', 'focus', 'blur', 'change', 'reset', 'select', 'submit', 'focusin', 'focusout', 'load', 'unload', 'beforeunload', 'resize', 'move', 'DOMContentLoaded', 'readystatechange', 'error', 'abort', 'scroll']);
/**
 * ------------------------------------------------------------------------
 * Private methods
 * ------------------------------------------------------------------------
 */

function getUidEvent(element, uid) {
  return uid && "".concat(uid, "::").concat(uidEvent++) || element.uidEvent || uidEvent++;
}

function getEvent(element) {
  var uid = getUidEvent(element);
  element.uidEvent = uid;
  eventRegistry[uid] = eventRegistry[uid] || {};
  return eventRegistry[uid];
}

function bootstrapHandler(element, fn) {
  return function handler(event) {
    event.delegateTarget = element;

    if (handler.oneOff) {
      EventHandler.off(element, event.type, fn);
    }

    return fn.apply(element, [event]);
  };
}

function bootstrapDelegationHandler(element, selector, fn) {
  return function handler(event) {
    var domElements = element.querySelectorAll(selector);

    for (var target = event.target; target && target !== this; target = target.parentNode) {
      for (var i = domElements.length; i--;) {
        if (domElements[i] === target) {
          event.delegateTarget = target;

          if (handler.oneOff) {
            EventHandler.off(element, event.type, selector, fn);
          }

          return fn.apply(target, [event]);
        }
      }
    } // To please ESLint


    return null;
  };
}

function findHandler(events, handler) {
  var delegationSelector = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  var uidEventList = Object.keys(events);

  for (var i = 0, len = uidEventList.length; i < len; i++) {
    var event = events[uidEventList[i]];

    if (event.originalHandler === handler && event.delegationSelector === delegationSelector) {
      return event;
    }
  }

  return null;
}

function normalizeParams(originalTypeEvent, handler, delegationFn) {
  var delegation = typeof handler === 'string';
  var originalHandler = delegation ? delegationFn : handler;
  var typeEvent = getTypeEvent(originalTypeEvent);
  var isNative = nativeEvents.has(typeEvent);

  if (!isNative) {
    typeEvent = originalTypeEvent;
  }

  return [delegation, originalHandler, typeEvent];
}

function addHandler(element, originalTypeEvent, handler, delegationFn, oneOff) {
  if (typeof originalTypeEvent !== 'string' || !element) {
    return;
  }

  if (!handler) {
    handler = delegationFn;
    delegationFn = null;
  } // in case of mouseenter or mouseleave wrap the handler within a function that checks for its DOM position
  // this prevents the handler from being dispatched the same way as mouseover or mouseout does


  if (customEventsRegex.test(originalTypeEvent)) {
    var wrapFn = function wrapFn(fn) {
      return function (event) {
        if (!event.relatedTarget || event.relatedTarget !== event.delegateTarget && !event.delegateTarget.contains(event.relatedTarget)) {
          return fn.call(this, event);
        }
      };
    };

    if (delegationFn) {
      delegationFn = wrapFn(delegationFn);
    } else {
      handler = wrapFn(handler);
    }
  }

  var _normalizeParams = normalizeParams(originalTypeEvent, handler, delegationFn),
      _normalizeParams2 = _slicedToArray(_normalizeParams, 3),
      delegation = _normalizeParams2[0],
      originalHandler = _normalizeParams2[1],
      typeEvent = _normalizeParams2[2];

  var events = getEvent(element);
  var handlers = events[typeEvent] || (events[typeEvent] = {});
  var previousFn = findHandler(handlers, originalHandler, delegation ? handler : null);

  if (previousFn) {
    previousFn.oneOff = previousFn.oneOff && oneOff;
    return;
  }

  var uid = getUidEvent(originalHandler, originalTypeEvent.replace(namespaceRegex, ''));
  var fn = delegation ? bootstrapDelegationHandler(element, handler, delegationFn) : bootstrapHandler(element, handler);
  fn.delegationSelector = delegation ? handler : null;
  fn.originalHandler = originalHandler;
  fn.oneOff = oneOff;
  fn.uidEvent = uid;
  handlers[uid] = fn;
  element.addEventListener(typeEvent, fn, delegation);
}

function removeHandler(element, events, typeEvent, handler, delegationSelector) {
  var fn = findHandler(events[typeEvent], handler, delegationSelector);

  if (!fn) {
    return;
  }

  element.removeEventListener(typeEvent, fn, Boolean(delegationSelector));
  delete events[typeEvent][fn.uidEvent];
}

function removeNamespacedHandlers(element, events, typeEvent, namespace) {
  var storeElementEvent = events[typeEvent] || {};
  Object.keys(storeElementEvent).forEach(function (handlerKey) {
    if (handlerKey.includes(namespace)) {
      var event = storeElementEvent[handlerKey];
      removeHandler(element, events, typeEvent, event.originalHandler, event.delegationSelector);
    }
  });
}

function getTypeEvent(event) {
  // allow to get the native events from namespaced events ('click.bs.button' --> 'click')
  event = event.replace(stripNameRegex, '');
  return customEvents[event] || event;
}

var EventHandler = {
  on: function on(element, event, handler, delegationFn) {
    addHandler(element, event, handler, delegationFn, false);
  },
  one: function one(element, event, handler, delegationFn) {
    addHandler(element, event, handler, delegationFn, true);
  },
  off: function off(element, originalTypeEvent, handler, delegationFn) {
    if (typeof originalTypeEvent !== 'string' || !element) {
      return;
    }

    var _normalizeParams3 = normalizeParams(originalTypeEvent, handler, delegationFn),
        _normalizeParams4 = _slicedToArray(_normalizeParams3, 3),
        delegation = _normalizeParams4[0],
        originalHandler = _normalizeParams4[1],
        typeEvent = _normalizeParams4[2];

    var inNamespace = typeEvent !== originalTypeEvent;
    var events = getEvent(element);
    var isNamespace = originalTypeEvent.startsWith('.');

    if (typeof originalHandler !== 'undefined') {
      // Simplest case: handler is passed, remove that listener ONLY.
      if (!events || !events[typeEvent]) {
        return;
      }

      removeHandler(element, events, typeEvent, originalHandler, delegation ? handler : null);
      return;
    }

    if (isNamespace) {
      Object.keys(events).forEach(function (elementEvent) {
        removeNamespacedHandlers(element, events, elementEvent, originalTypeEvent.slice(1));
      });
    }

    var storeElementEvent = events[typeEvent] || {};
    Object.keys(storeElementEvent).forEach(function (keyHandlers) {
      var handlerKey = keyHandlers.replace(stripUidRegex, '');

      if (!inNamespace || originalTypeEvent.includes(handlerKey)) {
        var event = storeElementEvent[keyHandlers];
        removeHandler(element, events, typeEvent, event.originalHandler, event.delegationSelector);
      }
    });
  },
  trigger: function trigger(element, event, args) {
    if (typeof event !== 'string' || !element) {
      return null;
    }

    var $ = (0, _index.getjQuery)();
    var typeEvent = getTypeEvent(event);
    var inNamespace = event !== typeEvent;
    var isNative = nativeEvents.has(typeEvent);
    var jQueryEvent;
    var bubbles = true;
    var nativeDispatch = true;
    var defaultPrevented = false;
    var evt = null;

    if (inNamespace && $) {
      jQueryEvent = $.Event(event, args);
      $(element).trigger(jQueryEvent);
      bubbles = !jQueryEvent.isPropagationStopped();
      nativeDispatch = !jQueryEvent.isImmediatePropagationStopped();
      defaultPrevented = jQueryEvent.isDefaultPrevented();
    }

    if (isNative) {
      evt = document.createEvent('HTMLEvents');
      evt.initEvent(typeEvent, bubbles, true);
    } else {
      evt = new CustomEvent(event, {
        bubbles: bubbles,
        cancelable: true
      });
    } // merge custom information in our event


    if (typeof args !== 'undefined') {
      Object.keys(args).forEach(function (key) {
        Object.defineProperty(evt, key, {
          get: function get() {
            return args[key];
          }
        });
      });
    }

    if (defaultPrevented) {
      evt.preventDefault();
    }

    if (nativeDispatch) {
      element.dispatchEvent(evt);
    }

    if (evt.defaultPrevented && typeof jQueryEvent !== 'undefined') {
      jQueryEvent.preventDefault();
    }

    return evt;
  }
};
var _default = EventHandler;
exports["default"] = _default;
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

/**
 * --------------------------------------------------------------------------
 * Bootstrap (v5.1.3): dom/manipulator.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */
function normalizeData(val) {
  if (val === 'true') {
    return true;
  }

  if (val === 'false') {
    return false;
  }

  if (val === Number(val).toString()) {
    return Number(val);
  }

  if (val === '' || val === 'null') {
    return null;
  }

  return val;
}

function normalizeDataKey(key) {
  return key.replace(/[A-Z]/g, function (chr) {
    return "-".concat(chr.toLowerCase());
  });
}

var Manipulator = {
  setDataAttribute: function setDataAttribute(element, key, value) {
    element.setAttribute("data-bs-".concat(normalizeDataKey(key)), value);
  },
  removeDataAttribute: function removeDataAttribute(element, key) {
    element.removeAttribute("data-bs-".concat(normalizeDataKey(key)));
  },
  getDataAttributes: function getDataAttributes(element) {
    if (!element) {
      return {};
    }

    var attributes = {};
    Object.keys(element.dataset).filter(function (key) {
      return key.startsWith('bs');
    }).forEach(function (key) {
      var pureKey = key.replace(/^bs/, '');
      pureKey = pureKey.charAt(0).toLowerCase() + pureKey.slice(1, pureKey.length);
      attributes[pureKey] = normalizeData(element.dataset[key]);
    });
    return attributes;
  },
  getDataAttribute: function getDataAttribute(element, key) {
    return normalizeData(element.getAttribute("data-bs-".concat(normalizeDataKey(key))));
  },
  offset: function offset(element) {
    var rect = element.getBoundingClientRect();
    return {
      top: rect.top + window.pageYOffset,
      left: rect.left + window.pageXOffset
    };
  },
  position: function position(element) {
    return {
      top: element.offsetTop,
      left: element.offsetLeft
    };
  }
};
var _default = Manipulator;
exports["default"] = _default;
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _index = require("../util/index");

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var NODE_TEXT = 3;
var SelectorEngine = {
  find: function find(selector) {
    var _ref;

    var element = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : document.documentElement;
    return (_ref = []).concat.apply(_ref, _toConsumableArray(Element.prototype.querySelectorAll.call(element, selector)));
  },
  findOne: function findOne(selector) {
    var element = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : document.documentElement;
    return Element.prototype.querySelector.call(element, selector);
  },
  children: function children(element, selector) {
    var _ref2;

    return (_ref2 = []).concat.apply(_ref2, _toConsumableArray(element.children)).filter(function (child) {
      return child.matches(selector);
    });
  },
  parents: function parents(element, selector) {
    var parents = [];
    var ancestor = element.parentNode;

    while (ancestor && ancestor.nodeType === Node.ELEMENT_NODE && ancestor.nodeType !== NODE_TEXT) {
      if (ancestor.matches(selector)) {
        parents.push(ancestor);
      }

      ancestor = ancestor.parentNode;
    }

    return parents;
  },
  prev: function prev(element, selector) {
    var previous = element.previousElementSibling;

    while (previous) {
      if (previous.matches(selector)) {
        return [previous];
      }

      previous = previous.previousElementSibling;
    }

    return [];
  },
  next: function next(element, selector) {
    var next = element.nextElementSibling;

    while (next) {
      if (next.matches(selector)) {
        return [next];
      }

      next = next.nextElementSibling;
    }

    return [];
  },
  focusableChildren: function focusableChildren(element) {
    var focusables = ['a', 'button', 'input', 'textarea', 'select', 'details', '[tabindex]', '[contenteditable="true"]'].map(function (selector) {
      return "".concat(selector, ":not([tabindex^=\"-\"])");
    }).join(', ');
    return this.find(focusables, element).filter(function (el) {
      return !(0, _index.isDisabled)(el) && (0, _index.isVisible)(el);
    });
  }
};
var _default = SelectorEngine;
exports["default"] = _default;
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _eventHandler = _interopRequireDefault(require("../dom/event-handler"));

var _index = require("./index");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Default = {
  className: 'modal-backdrop',
  isVisible: true,
  // if false, we use the backdrop helper without adding any element to the dom
  isAnimated: false,
  rootElement: 'body',
  // give the choice to place backdrop under different elements
  clickCallback: null
};
var DefaultType = {
  className: 'string',
  isVisible: 'boolean',
  isAnimated: 'boolean',
  rootElement: '(element|string)',
  clickCallback: '(function|null)'
};
var NAME = 'backdrop';
var CLASS_NAME_FADE = 'fade';
var CLASS_NAME_SHOW = 'show';
var EVENT_MOUSEDOWN = "mousedown.bs.".concat(NAME);

var Backdrop = /*#__PURE__*/function () {
  function Backdrop(config) {
    _classCallCheck(this, Backdrop);

    this._config = this._getConfig(config);
    this._isAppended = false;
    this._element = null;
  }

  _createClass(Backdrop, [{
    key: "show",
    value: function show(callback) {
      if (!this._config.isVisible) {
        (0, _index.execute)(callback);
        return;
      }

      this._append();

      if (this._config.isAnimated) {
        (0, _index.reflow)(this._getElement());
      }

      this._getElement().classList.add(CLASS_NAME_SHOW);

      this._emulateAnimation(function () {
        (0, _index.execute)(callback);
      });
    }
  }, {
    key: "hide",
    value: function hide(callback) {
      var _this = this;

      if (!this._config.isVisible) {
        (0, _index.execute)(callback);
        return;
      }

      this._getElement().classList.remove(CLASS_NAME_SHOW);

      this._emulateAnimation(function () {
        _this.dispose();

        (0, _index.execute)(callback);
      });
    } // Private

  }, {
    key: "_getElement",
    value: function _getElement() {
      if (!this._element) {
        var backdrop = document.createElement('div');
        backdrop.className = this._config.className;

        if (this._config.isAnimated) {
          backdrop.classList.add(CLASS_NAME_FADE);
        }

        this._element = backdrop;
      }

      return this._element;
    }
  }, {
    key: "_getConfig",
    value: function _getConfig(config) {
      config = _objectSpread(_objectSpread({}, Default), _typeof(config) === 'object' ? config : {}); // use getElement() with the default "body" to get a fresh Element on each instantiation

      config.rootElement = (0, _index.getElement)(config.rootElement);
      (0, _index.typeCheckConfig)(NAME, config, DefaultType);
      return config;
    }
  }, {
    key: "_append",
    value: function _append() {
      var _this2 = this;

      if (this._isAppended) {
        return;
      }

      this._config.rootElement.append(this._getElement());

      _eventHandler["default"].on(this._getElement(), EVENT_MOUSEDOWN, function () {
        (0, _index.execute)(_this2._config.clickCallback);
      });

      this._isAppended = true;
    }
  }, {
    key: "dispose",
    value: function dispose() {
      if (!this._isAppended) {
        return;
      }

      _eventHandler["default"].off(this._element, EVENT_MOUSEDOWN);

      this._element.remove();

      this._isAppended = false;
    }
  }, {
    key: "_emulateAnimation",
    value: function _emulateAnimation(callback) {
      (0, _index.executeAfterTransition)(callback, this._getElement(), this._config.isAnimated);
    }
  }]);

  return Backdrop;
}();

var _default = Backdrop;
exports["default"] = _default;
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.enableDismissTrigger = void 0;

var _eventHandler = _interopRequireDefault(require("../dom/event-handler"));

var _index = require("./index");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/**
 * --------------------------------------------------------------------------
 * Bootstrap (v5.1.3): util/component-functions.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */
var enableDismissTrigger = function enableDismissTrigger(component) {
  var method = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'hide';
  var clickEvent = "click.dismiss".concat(component.EVENT_KEY);
  var name = component.NAME;

  _eventHandler["default"].on(document, clickEvent, "[data-bs-dismiss=\"".concat(name, "\"]"), function (event) {
    if (['A', 'AREA'].includes(this.tagName)) {
      event.preventDefault();
    }

    if ((0, _index.isDisabled)(this)) {
      return;
    }

    var target = (0, _index.getElementFromSelector)(this) || this.closest(".".concat(name));
    var instance = component.getOrCreateInstance(target); // Method argument is left, for Alert and only, as it doesn't implement the 'hide' method

    instance[method]();
  });
};

exports.enableDismissTrigger = enableDismissTrigger;
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _eventHandler = _interopRequireDefault(require("../dom/event-handler"));

var _selectorEngine = _interopRequireDefault(require("../dom/selector-engine"));

var _index = require("./index");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Default = {
  trapElement: null,
  // The element to trap focus inside of
  autofocus: true
};
var DefaultType = {
  trapElement: 'element',
  autofocus: 'boolean'
};
var NAME = 'focustrap';
var DATA_KEY = 'bs.focustrap';
var EVENT_KEY = ".".concat(DATA_KEY);
var EVENT_FOCUSIN = "focusin".concat(EVENT_KEY);
var EVENT_KEYDOWN_TAB = "keydown.tab".concat(EVENT_KEY);
var TAB_KEY = 'Tab';
var TAB_NAV_FORWARD = 'forward';
var TAB_NAV_BACKWARD = 'backward';

var FocusTrap = /*#__PURE__*/function () {
  function FocusTrap(config) {
    _classCallCheck(this, FocusTrap);

    this._config = this._getConfig(config);
    this._isActive = false;
    this._lastTabNavDirection = null;
  }

  _createClass(FocusTrap, [{
    key: "activate",
    value: function activate() {
      var _this = this;

      var _this$_config = this._config,
          trapElement = _this$_config.trapElement,
          autofocus = _this$_config.autofocus;

      if (this._isActive) {
        return;
      }

      if (autofocus) {
        trapElement.focus();
      }

      _eventHandler["default"].off(document, EVENT_KEY); // guard against infinite focus loop


      _eventHandler["default"].on(document, EVENT_FOCUSIN, function (event) {
        return _this._handleFocusin(event);
      });

      _eventHandler["default"].on(document, EVENT_KEYDOWN_TAB, function (event) {
        return _this._handleKeydown(event);
      });

      this._isActive = true;
    }
  }, {
    key: "deactivate",
    value: function deactivate() {
      if (!this._isActive) {
        return;
      }

      this._isActive = false;

      _eventHandler["default"].off(document, EVENT_KEY);
    } // Private

  }, {
    key: "_handleFocusin",
    value: function _handleFocusin(event) {
      var target = event.target;
      var trapElement = this._config.trapElement;

      if (target === document || target === trapElement || trapElement.contains(target)) {
        return;
      }

      var elements = _selectorEngine["default"].focusableChildren(trapElement);

      if (elements.length === 0) {
        trapElement.focus();
      } else if (this._lastTabNavDirection === TAB_NAV_BACKWARD) {
        elements[elements.length - 1].focus();
      } else {
        elements[0].focus();
      }
    }
  }, {
    key: "_handleKeydown",
    value: function _handleKeydown(event) {
      if (event.key !== TAB_KEY) {
        return;
      }

      this._lastTabNavDirection = event.shiftKey ? TAB_NAV_BACKWARD : TAB_NAV_FORWARD;
    }
  }, {
    key: "_getConfig",
    value: function _getConfig(config) {
      config = _objectSpread(_objectSpread({}, Default), _typeof(config) === 'object' ? config : {});
      (0, _index.typeCheckConfig)(NAME, config, DefaultType);
      return config;
    }
  }]);

  return FocusTrap;
}();

var _default = FocusTrap;
exports["default"] = _default;
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.executeAfterTransition = exports.execute = exports.defineJQueryPlugin = exports.isRTL = exports.onDOMContentLoaded = exports.getjQuery = exports.reflow = exports.getNextActiveElement = exports.noop = exports.findShadowRoot = exports.isDisabled = exports.isVisible = exports.typeCheckConfig = exports.isElement = exports.triggerTransitionEnd = exports.getTransitionDurationFromElement = exports.getElementFromSelector = exports.getSelectorFromElement = exports.getUID = exports.getElement = void 0;

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
 * --------------------------------------------------------------------------
 * Bootstrap (v5.1.3): util/index.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */
var MAX_UID = 1000000;
var MILLISECONDS_MULTIPLIER = 1000;
var TRANSITION_END = 'transitionend'; // Shoutout AngusCroll (https://goo.gl/pxwQGp)

var toType = function toType(obj) {
  if (obj === null || obj === undefined) {
    return "".concat(obj);
  }

  return {}.toString.call(obj).match(/\s([a-z]+)/i)[1].toLowerCase();
};
/**
 * --------------------------------------------------------------------------
 * Public Util Api
 * --------------------------------------------------------------------------
 */


var getUID = function getUID(prefix) {
  do {
    prefix += Math.floor(Math.random() * MAX_UID);
  } while (document.getElementById(prefix));

  return prefix;
};

exports.getUID = getUID;

var getSelector = function getSelector(element) {
  var selector = element.getAttribute('data-bs-target');

  if (!selector || selector === '#') {
    var hrefAttr = element.getAttribute('href'); // The only valid content that could double as a selector are IDs or classes,
    // so everything starting with `#` or `.`. If a "real" URL is used as the selector,
    // `document.querySelector` will rightfully complain it is invalid.
    // See https://github.com/twbs/bootstrap/issues/32273

    if (!hrefAttr || !hrefAttr.includes('#') && !hrefAttr.startsWith('.')) {
      return null;
    } // Just in case some CMS puts out a full URL with the anchor appended


    if (hrefAttr.includes('#') && !hrefAttr.startsWith('#')) {
      hrefAttr = "#".concat(hrefAttr.split('#')[1]);
    }

    selector = hrefAttr && hrefAttr !== '#' ? hrefAttr.trim() : null;
  }

  return selector;
};

var getSelectorFromElement = function getSelectorFromElement(element) {
  var selector = getSelector(element);

  if (selector) {
    return document.querySelector(selector) ? selector : null;
  }

  return null;
};

exports.getSelectorFromElement = getSelectorFromElement;

var getElementFromSelector = function getElementFromSelector(element) {
  var selector = getSelector(element);
  return selector ? document.querySelector(selector) : null;
};

exports.getElementFromSelector = getElementFromSelector;

var getTransitionDurationFromElement = function getTransitionDurationFromElement(element) {
  if (!element) {
    return 0;
  } // Get transition-duration of the element


  var _window$getComputedSt = window.getComputedStyle(element),
      transitionDuration = _window$getComputedSt.transitionDuration,
      transitionDelay = _window$getComputedSt.transitionDelay;

  var floatTransitionDuration = Number.parseFloat(transitionDuration);
  var floatTransitionDelay = Number.parseFloat(transitionDelay); // Return 0 if element or transition duration is not found

  if (!floatTransitionDuration && !floatTransitionDelay) {
    return 0;
  } // If multiple durations are defined, take the first


  transitionDuration = transitionDuration.split(',')[0];
  transitionDelay = transitionDelay.split(',')[0];
  return (Number.parseFloat(transitionDuration) + Number.parseFloat(transitionDelay)) * MILLISECONDS_MULTIPLIER;
};

exports.getTransitionDurationFromElement = getTransitionDurationFromElement;

var triggerTransitionEnd = function triggerTransitionEnd(element) {
  element.dispatchEvent(new Event(TRANSITION_END));
};

exports.triggerTransitionEnd = triggerTransitionEnd;

var isElement = function isElement(obj) {
  if (!obj || _typeof(obj) !== 'object') {
    return false;
  }

  if (typeof obj.jquery !== 'undefined') {
    obj = obj[0];
  }

  return typeof obj.nodeType !== 'undefined';
};

exports.isElement = isElement;

var getElement = function getElement(obj) {
  if (isElement(obj)) {
    // it's a jQuery object or a node element
    return obj.jquery ? obj[0] : obj;
  }

  if (typeof obj === 'string' && obj.length > 0) {
    return document.querySelector(obj);
  }

  return null;
};

exports.getElement = getElement;

var typeCheckConfig = function typeCheckConfig(componentName, config, configTypes) {
  Object.keys(configTypes).forEach(function (property) {
    var expectedTypes = configTypes[property];
    var value = config[property];
    var valueType = value && isElement(value) ? 'element' : toType(value);

    if (!new RegExp(expectedTypes).test(valueType)) {
      throw new TypeError("".concat(componentName.toUpperCase(), ": Option \"").concat(property, "\" provided type \"").concat(valueType, "\" but expected type \"").concat(expectedTypes, "\"."));
    }
  });
};

exports.typeCheckConfig = typeCheckConfig;

var isVisible = function isVisible(element) {
  if (!isElement(element) || element.getClientRects().length === 0) {
    return false;
  }

  return getComputedStyle(element).getPropertyValue('visibility') === 'visible';
};

exports.isVisible = isVisible;

var isDisabled = function isDisabled(element) {
  if (!element || element.nodeType !== Node.ELEMENT_NODE) {
    return true;
  }

  if (element.classList.contains('disabled')) {
    return true;
  }

  if (typeof element.disabled !== 'undefined') {
    return element.disabled;
  }

  return element.hasAttribute('disabled') && element.getAttribute('disabled') !== 'false';
};

exports.isDisabled = isDisabled;

var findShadowRoot = function findShadowRoot(element) {
  if (!document.documentElement.attachShadow) {
    return null;
  } // Can find the shadow root otherwise it'll return the document


  if (typeof element.getRootNode === 'function') {
    var root = element.getRootNode();
    return root instanceof ShadowRoot ? root : null;
  }

  if (element instanceof ShadowRoot) {
    return element;
  } // when we don't find a shadow root


  if (!element.parentNode) {
    return null;
  }

  return findShadowRoot(element.parentNode);
};

exports.findShadowRoot = findShadowRoot;

var noop = function noop() {};
/**
 * Trick to restart an element's animation
 *
 * @param {HTMLElement} element
 * @return void
 *
 * @see https://www.charistheo.io/blog/2021/02/restart-a-css-animation-with-javascript/#restarting-a-css-animation
 */


exports.noop = noop;

var reflow = function reflow(element) {
  // eslint-disable-next-line no-unused-expressions
  element.offsetHeight;
};

exports.reflow = reflow;

var getjQuery = function getjQuery() {
  var _window = window,
      jQuery = _window.jQuery;

  if (jQuery && !document.body.hasAttribute('data-bs-no-jquery')) {
    return jQuery;
  }

  return null;
};

exports.getjQuery = getjQuery;
var DOMContentLoadedCallbacks = [];

var onDOMContentLoaded = function onDOMContentLoaded(callback) {
  if (document.readyState === 'loading') {
    // add listener on the first call when the document is in loading state
    if (!DOMContentLoadedCallbacks.length) {
      document.addEventListener('DOMContentLoaded', function () {
        DOMContentLoadedCallbacks.forEach(function (callback) {
          return callback();
        });
      });
    }

    DOMContentLoadedCallbacks.push(callback);
  } else {
    callback();
  }
};

exports.onDOMContentLoaded = onDOMContentLoaded;

var isRTL = function isRTL() {
  return document.documentElement.dir === 'rtl';
};

exports.isRTL = isRTL;

var defineJQueryPlugin = function defineJQueryPlugin(plugin) {
  onDOMContentLoaded(function () {
    var $ = getjQuery();
    /* istanbul ignore if */

    if ($) {
      var name = plugin.NAME;
      var JQUERY_NO_CONFLICT = $.fn[name];
      $.fn[name] = plugin.jQueryInterface;
      $.fn[name].Constructor = plugin;

      $.fn[name].noConflict = function () {
        $.fn[name] = JQUERY_NO_CONFLICT;
        return plugin.jQueryInterface;
      };
    }
  });
};

exports.defineJQueryPlugin = defineJQueryPlugin;

var execute = function execute(callback) {
  if (typeof callback === 'function') {
    callback();
  }
};

exports.execute = execute;

var executeAfterTransition = function executeAfterTransition(callback, transitionElement) {
  var waitForTransition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

  if (!waitForTransition) {
    execute(callback);
    return;
  }

  var durationPadding = 5;
  var emulatedDuration = getTransitionDurationFromElement(transitionElement) + durationPadding;
  var called = false;

  var handler = function handler(_ref) {
    var target = _ref.target;

    if (target !== transitionElement) {
      return;
    }

    called = true;
    transitionElement.removeEventListener(TRANSITION_END, handler);
    execute(callback);
  };

  transitionElement.addEventListener(TRANSITION_END, handler);
  setTimeout(function () {
    if (!called) {
      triggerTransitionEnd(transitionElement);
    }
  }, emulatedDuration);
};
/**
 * Return the previous/next element of a list.
 *
 * @param {array} list    The list of elements
 * @param activeElement   The active element
 * @param shouldGetNext   Choose to get next or previous element
 * @param isCycleAllowed
 * @return {Element|elem} The proper element
 */


exports.executeAfterTransition = executeAfterTransition;

var getNextActiveElement = function getNextActiveElement(list, activeElement, shouldGetNext, isCycleAllowed) {
  var index = list.indexOf(activeElement); // if the element does not exist in the list return an element depending on the direction and if cycle is allowed

  if (index === -1) {
    return list[!shouldGetNext && isCycleAllowed ? list.length - 1 : 0];
  }

  var listLength = list.length;
  index += shouldGetNext ? 1 : -1;

  if (isCycleAllowed) {
    index = (index + listLength) % listLength;
  }

  return list[Math.max(0, Math.min(index, listLength - 1))];
};

exports.getNextActiveElement = getNextActiveElement;
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.sanitizeHtml = sanitizeHtml;
exports.DefaultAllowlist = void 0;

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

/**
 * --------------------------------------------------------------------------
 * Bootstrap (v5.1.3): util/sanitizer.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */
var uriAttributes = new Set(['background', 'cite', 'href', 'itemtype', 'longdesc', 'poster', 'src', 'xlink:href']);
var ARIA_ATTRIBUTE_PATTERN = /^aria-[\w-]*$/i;
/**
 * A pattern that recognizes a commonly useful subset of URLs that are safe.
 *
 * Shoutout to Angular https://github.com/angular/angular/blob/12.2.x/packages/core/src/sanitization/url_sanitizer.ts
 */

var SAFE_URL_PATTERN = /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^#&/:?]*(?:[#/?]|$))/i;
/**
 * A pattern that matches safe data URLs. Only matches image, video and audio types.
 *
 * Shoutout to Angular https://github.com/angular/angular/blob/12.2.x/packages/core/src/sanitization/url_sanitizer.ts
 */

var DATA_URL_PATTERN = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[\d+/a-z]+=*$/i;

var allowedAttribute = function allowedAttribute(attribute, allowedAttributeList) {
  var attributeName = attribute.nodeName.toLowerCase();

  if (allowedAttributeList.includes(attributeName)) {
    if (uriAttributes.has(attributeName)) {
      return Boolean(SAFE_URL_PATTERN.test(attribute.nodeValue) || DATA_URL_PATTERN.test(attribute.nodeValue));
    }

    return true;
  }

  var regExp = allowedAttributeList.filter(function (attributeRegex) {
    return attributeRegex instanceof RegExp;
  }); // Check if a regular expression validates the attribute.

  for (var i = 0, len = regExp.length; i < len; i++) {
    if (regExp[i].test(attributeName)) {
      return true;
    }
  }

  return false;
};

var DefaultAllowlist = {
  // Global attributes allowed on any supplied element below.
  '*': ['class', 'dir', 'id', 'lang', 'role', ARIA_ATTRIBUTE_PATTERN],
  a: ['target', 'href', 'title', 'rel'],
  area: [],
  b: [],
  br: [],
  col: [],
  code: [],
  div: [],
  em: [],
  hr: [],
  h1: [],
  h2: [],
  h3: [],
  h4: [],
  h5: [],
  h6: [],
  i: [],
  img: ['src', 'srcset', 'alt', 'title', 'width', 'height'],
  li: [],
  ol: [],
  p: [],
  pre: [],
  s: [],
  small: [],
  span: [],
  sub: [],
  sup: [],
  strong: [],
  u: [],
  ul: []
};
exports.DefaultAllowlist = DefaultAllowlist;

function sanitizeHtml(unsafeHtml, allowList, sanitizeFn) {
  var _ref;

  if (!unsafeHtml.length) {
    return unsafeHtml;
  }

  if (sanitizeFn && typeof sanitizeFn === 'function') {
    return sanitizeFn(unsafeHtml);
  }

  var domParser = new window.DOMParser();
  var createdDocument = domParser.parseFromString(unsafeHtml, 'text/html');

  var elements = (_ref = []).concat.apply(_ref, _toConsumableArray(createdDocument.body.querySelectorAll('*')));

  var _loop = function _loop(i, len) {
    var _ref2;

    var element = elements[i];
    var elementName = element.nodeName.toLowerCase();

    if (!Object.keys(allowList).includes(elementName)) {
      element.remove();
      return "continue";
    }

    var attributeList = (_ref2 = []).concat.apply(_ref2, _toConsumableArray(element.attributes));

    var allowedAttributes = [].concat(allowList['*'] || [], allowList[elementName] || []);
    attributeList.forEach(function (attribute) {
      if (!allowedAttribute(attribute, allowedAttributes)) {
        element.removeAttribute(attribute.nodeName);
      }
    });
  };

  for (var i = 0, len = elements.length; i < len; i++) {
    var _ret = _loop(i, len);

    if (_ret === "continue") continue;
  }

  return createdDocument.body.innerHTML;
}
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _selectorEngine = _interopRequireDefault(require("../dom/selector-engine"));

var _manipulator = _interopRequireDefault(require("../dom/manipulator"));

var _index = require("./index");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var SELECTOR_FIXED_CONTENT = '.fixed-top, .fixed-bottom, .is-fixed, .sticky-top';
var SELECTOR_STICKY_CONTENT = '.sticky-top';

var ScrollBarHelper = /*#__PURE__*/function () {
  function ScrollBarHelper() {
    _classCallCheck(this, ScrollBarHelper);

    this._element = document.body;
  }

  _createClass(ScrollBarHelper, [{
    key: "getWidth",
    value: function getWidth() {
      // https://developer.mozilla.org/en-US/docs/Web/API/Window/innerWidth#usage_notes
      var documentWidth = document.documentElement.clientWidth;
      return Math.abs(window.innerWidth - documentWidth);
    }
  }, {
    key: "hide",
    value: function hide() {
      var width = this.getWidth();

      this._disableOverFlow(); // give padding to element to balance the hidden scrollbar width


      this._setElementAttributes(this._element, 'paddingRight', function (calculatedValue) {
        return calculatedValue + width;
      }); // trick: We adjust positive paddingRight and negative marginRight to sticky-top elements to keep showing fullwidth


      this._setElementAttributes(SELECTOR_FIXED_CONTENT, 'paddingRight', function (calculatedValue) {
        return calculatedValue + width;
      });

      this._setElementAttributes(SELECTOR_STICKY_CONTENT, 'marginRight', function (calculatedValue) {
        return calculatedValue - width;
      });
    }
  }, {
    key: "_disableOverFlow",
    value: function _disableOverFlow() {
      this._saveInitialAttribute(this._element, 'overflow');

      this._element.style.overflow = 'hidden';
    }
  }, {
    key: "_setElementAttributes",
    value: function _setElementAttributes(selector, styleProp, callback) {
      var _this = this;

      var scrollbarWidth = this.getWidth();

      var manipulationCallBack = function manipulationCallBack(element) {
        if (element !== _this._element && window.innerWidth > element.clientWidth + scrollbarWidth) {
          return;
        }

        _this._saveInitialAttribute(element, styleProp);

        var calculatedValue = window.getComputedStyle(element)[styleProp];
        element.style[styleProp] = "".concat(callback(Number.parseFloat(calculatedValue)), "px");
      };

      this._applyManipulationCallback(selector, manipulationCallBack);
    }
  }, {
    key: "reset",
    value: function reset() {
      this._resetElementAttributes(this._element, 'overflow');

      this._resetElementAttributes(this._element, 'paddingRight');

      this._resetElementAttributes(SELECTOR_FIXED_CONTENT, 'paddingRight');

      this._resetElementAttributes(SELECTOR_STICKY_CONTENT, 'marginRight');
    }
  }, {
    key: "_saveInitialAttribute",
    value: function _saveInitialAttribute(element, styleProp) {
      var actualValue = element.style[styleProp];

      if (actualValue) {
        _manipulator["default"].setDataAttribute(element, styleProp, actualValue);
      }
    }
  }, {
    key: "_resetElementAttributes",
    value: function _resetElementAttributes(selector, styleProp) {
      var manipulationCallBack = function manipulationCallBack(element) {
        var value = _manipulator["default"].getDataAttribute(element, styleProp);

        if (typeof value === 'undefined') {
          element.style.removeProperty(styleProp);
        } else {
          _manipulator["default"].removeDataAttribute(element, styleProp);

          element.style[styleProp] = value;
        }
      };

      this._applyManipulationCallback(selector, manipulationCallBack);
    }
  }, {
    key: "_applyManipulationCallback",
    value: function _applyManipulationCallback(selector, callBack) {
      if ((0, _index.isElement)(selector)) {
        callBack(selector);
      } else {
        _selectorEngine["default"].find(selector, this._element).forEach(callBack);
      }
    }
  }, {
    key: "isOverflowing",
    value: function isOverflowing() {
      return this.getWidth() > 0;
    }
  }]);

  return ScrollBarHelper;
}();

var _default = ScrollBarHelper;
exports["default"] = _default;
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.clearBodyAndDocument = exports.jQueryMock = exports.createEvent = exports.clearFixture = exports.getFixture = void 0;
var fixtureId = 'fixture';

var getFixture = function getFixture() {
  var fixtureEl = document.getElementById(fixtureId);

  if (!fixtureEl) {
    fixtureEl = document.createElement('div');
    fixtureEl.setAttribute('id', fixtureId);
    fixtureEl.style.position = 'absolute';
    fixtureEl.style.top = '-10000px';
    fixtureEl.style.left = '-10000px';
    fixtureEl.style.width = '10000px';
    fixtureEl.style.height = '10000px';
    document.body.append(fixtureEl);
  }

  return fixtureEl;
};

exports.getFixture = getFixture;

var clearFixture = function clearFixture() {
  var fixtureEl = getFixture();
  fixtureEl.innerHTML = '';
};

exports.clearFixture = clearFixture;

var createEvent = function createEvent(eventName) {
  var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var event = document.createEvent('Event');
  event.initEvent(eventName, Boolean(params.bubbles), Boolean(params.cancelable));
  return event;
};

exports.createEvent = createEvent;
var jQueryMock = {
  elements: undefined,
  fn: {},
  each: function each(fn) {
    this.elements.forEach(function (el) {
      fn.call(el);
    });
  }
};
exports.jQueryMock = jQueryMock;

var clearBodyAndDocument = function clearBodyAndDocument() {
  var attributes = ['data-bs-padding-right', 'style'];
  attributes.forEach(function (attr) {
    document.documentElement.removeAttribute(attr);
    document.body.removeAttribute(attr);
  });
};

exports.clearBodyAndDocument = clearBodyAndDocument;
"use strict";

var _tooltip = _interopRequireDefault(require("../../dist/tooltip"));

require("../../dist/carousel");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

window.addEventListener('load', function () {
  var _ref;

  (_ref = []).concat.apply(_ref, _toConsumableArray(document.querySelectorAll('[data-bs-toggle="tooltip"]'))).map(function (tooltipNode) {
    return new _tooltip["default"](tooltipNode);
  });
});
"use strict";

var _bootstrapEsm = require("../../../dist/js/bootstrap.esm.js");

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

window.addEventListener('load', function () {
  var _ref;

  (_ref = []).concat.apply(_ref, _toConsumableArray(document.querySelectorAll('[data-bs-toggle="tooltip"]'))).map(function (tooltipNode) {
    return new _bootstrapEsm.Tooltip(tooltipNode);
  });
});
"use strict";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/* eslint-env node */
var commonjs = require('@rollup/plugin-commonjs');

var configRollup = require('./rollup.bundle');

var config = _objectSpread(_objectSpread({}, configRollup), {}, {
  input: 'js/tests/integration/bundle-modularity.js',
  output: {
    file: 'js/coverage/bundle-modularity.js',
    format: 'iife'
  }
});

config.plugins.unshift(commonjs());
module.exports = config;
"use strict";

/* eslint-env node */
var _require = require('@rollup/plugin-babel'),
    babel = _require.babel;

var _require2 = require('@rollup/plugin-node-resolve'),
    nodeResolve = _require2.nodeResolve;

var replace = require('@rollup/plugin-replace');

module.exports = {
  input: 'js/tests/integration/bundle.js',
  output: {
    file: 'js/coverage/bundle.js',
    format: 'iife'
  },
  plugins: [replace({
    'process.env.NODE_ENV': '"production"',
    preventAssignment: true
  }), nodeResolve(), babel({
    exclude: 'node_modules/**',
    babelHelpers: 'bundled'
  })]
};
"use strict";

var _alert = _interopRequireDefault(require("../../src/alert"));

var _index = require("../../src/util/index");

var _fixture = require("../helpers/fixture");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

describe('Alert', function () {
  var fixtureEl;
  beforeAll(function () {
    fixtureEl = (0, _fixture.getFixture)();
  });
  afterEach(function () {
    (0, _fixture.clearFixture)();
  });
  it('should take care of element either passed as a CSS selector or DOM element', function () {
    fixtureEl.innerHTML = '<div class="alert"></div>';
    var alertEl = fixtureEl.querySelector('.alert');
    var alertBySelector = new _alert["default"]('.alert');
    var alertByElement = new _alert["default"](alertEl);
    expect(alertBySelector._element).toEqual(alertEl);
    expect(alertByElement._element).toEqual(alertEl);
  });
  it('should return version', function () {
    expect(_typeof(_alert["default"].VERSION)).toEqual('string');
  });
  describe('DATA_KEY', function () {
    it('should return plugin data key', function () {
      expect(_alert["default"].DATA_KEY).toEqual('bs.alert');
    });
  });
  describe('data-api', function () {
    it('should close an alert without instantiating it manually', function () {
      fixtureEl.innerHTML = ['<div class="alert">', '  <button type="button" data-bs-dismiss="alert">x</button>', '</div>'].join('');
      var button = document.querySelector('button');
      button.click();
      expect(document.querySelectorAll('.alert').length).toEqual(0);
    });
    it('should close an alert without instantiating it manually with the parent selector', function () {
      fixtureEl.innerHTML = ['<div class="alert">', '  <button type="button" data-bs-target=".alert" data-bs-dismiss="alert">x</button>', '</div>'].join('');
      var button = document.querySelector('button');
      button.click();
      expect(document.querySelectorAll('.alert').length).toEqual(0);
    });
  });
  describe('close', function () {
    it('should close an alert', function (done) {
      var spy = jasmine.createSpy('spy', _index.getTransitionDurationFromElement);
      fixtureEl.innerHTML = '<div class="alert"></div>';
      var alertEl = document.querySelector('.alert');
      var alert = new _alert["default"](alertEl);
      alertEl.addEventListener('closed.bs.alert', function () {
        expect(document.querySelectorAll('.alert').length).toEqual(0);
        expect(spy).not.toHaveBeenCalled();
        done();
      });
      alert.close();
    });
    it('should close alert with fade class', function (done) {
      fixtureEl.innerHTML = '<div class="alert fade"></div>';
      var alertEl = document.querySelector('.alert');
      var alert = new _alert["default"](alertEl);
      alertEl.addEventListener('transitionend', function () {
        expect().nothing();
      });
      alertEl.addEventListener('closed.bs.alert', function () {
        expect(document.querySelectorAll('.alert').length).toEqual(0);
        done();
      });
      alert.close();
    });
    it('should not remove alert if close event is prevented', function (done) {
      fixtureEl.innerHTML = '<div class="alert"></div>';

      var getAlert = function getAlert() {
        return document.querySelector('.alert');
      };

      var alertEl = getAlert();
      var alert = new _alert["default"](alertEl);
      alertEl.addEventListener('close.bs.alert', function (event) {
        event.preventDefault();
        setTimeout(function () {
          expect(getAlert()).not.toBeNull();
          done();
        }, 10);
      });
      alertEl.addEventListener('closed.bs.alert', function () {
        throw new Error('should not fire closed event');
      });
      alert.close();
    });
  });
  describe('dispose', function () {
    it('should dispose an alert', function () {
      fixtureEl.innerHTML = '<div class="alert"></div>';
      var alertEl = document.querySelector('.alert');
      var alert = new _alert["default"](alertEl);
      expect(_alert["default"].getInstance(alertEl)).not.toBeNull();
      alert.dispose();
      expect(_alert["default"].getInstance(alertEl)).toBeNull();
    });
  });
  describe('jQueryInterface', function () {
    it('should handle config passed and toggle existing alert', function () {
      fixtureEl.innerHTML = '<div class="alert"></div>';
      var alertEl = fixtureEl.querySelector('.alert');
      var alert = new _alert["default"](alertEl);
      spyOn(alert, 'close');
      _fixture.jQueryMock.fn.alert = _alert["default"].jQueryInterface;
      _fixture.jQueryMock.elements = [alertEl];

      _fixture.jQueryMock.fn.alert.call(_fixture.jQueryMock, 'close');

      expect(alert.close).toHaveBeenCalled();
    });
    it('should create new alert instance and call close', function () {
      fixtureEl.innerHTML = '<div class="alert"></div>';
      var alertEl = fixtureEl.querySelector('.alert');
      _fixture.jQueryMock.fn.alert = _alert["default"].jQueryInterface;
      _fixture.jQueryMock.elements = [alertEl];
      expect(_alert["default"].getInstance(alertEl)).toBeNull();

      _fixture.jQueryMock.fn.alert.call(_fixture.jQueryMock, 'close');

      expect(fixtureEl.querySelector('.alert')).toBeNull();
    });
    it('should just create an alert instance without calling close', function () {
      fixtureEl.innerHTML = '<div class="alert"></div>';
      var alertEl = fixtureEl.querySelector('.alert');
      _fixture.jQueryMock.fn.alert = _alert["default"].jQueryInterface;
      _fixture.jQueryMock.elements = [alertEl];

      _fixture.jQueryMock.fn.alert.call(_fixture.jQueryMock);

      expect(_alert["default"].getInstance(alertEl)).not.toBeNull();
      expect(fixtureEl.querySelector('.alert')).not.toBeNull();
    });
  });
  describe('getInstance', function () {
    it('should return alert instance', function () {
      fixtureEl.innerHTML = '<div></div>';
      var div = fixtureEl.querySelector('div');
      var alert = new _alert["default"](div);
      expect(_alert["default"].getInstance(div)).toEqual(alert);
      expect(_alert["default"].getInstance(div)).toBeInstanceOf(_alert["default"]);
    });
    it('should return null when there is no alert instance', function () {
      fixtureEl.innerHTML = '<div></div>';
      var div = fixtureEl.querySelector('div');
      expect(_alert["default"].getInstance(div)).toEqual(null);
    });
  });
  describe('getOrCreateInstance', function () {
    it('should return alert instance', function () {
      fixtureEl.innerHTML = '<div></div>';
      var div = fixtureEl.querySelector('div');
      var alert = new _alert["default"](div);
      expect(_alert["default"].getOrCreateInstance(div)).toEqual(alert);
      expect(_alert["default"].getInstance(div)).toEqual(_alert["default"].getOrCreateInstance(div, {}));
      expect(_alert["default"].getOrCreateInstance(div)).toBeInstanceOf(_alert["default"]);
    });
    it('should return new instance when there is no alert instance', function () {
      fixtureEl.innerHTML = '<div></div>';
      var div = fixtureEl.querySelector('div');
      expect(_alert["default"].getInstance(div)).toEqual(null);
      expect(_alert["default"].getOrCreateInstance(div)).toBeInstanceOf(_alert["default"]);
    });
  });
});
"use strict";

var _baseComponent = _interopRequireDefault(require("../../src/base-component"));

var _fixture = require("../helpers/fixture");

var _eventHandler = _interopRequireDefault(require("../../src/dom/event-handler"));

var _util = require("../../src/util");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var DummyClass = /*#__PURE__*/function (_BaseComponent) {
  _inherits(DummyClass, _BaseComponent);

  var _super = _createSuper(DummyClass);

  function DummyClass(element) {
    var _this;

    _classCallCheck(this, DummyClass);

    _this = _super.call(this, element);

    _eventHandler["default"].on(_this._element, "click".concat(DummyClass.EVENT_KEY), _util.noop);

    return _this;
  }

  _createClass(DummyClass, null, [{
    key: "NAME",
    get: function get() {
      return 'dummy';
    }
  }]);

  return DummyClass;
}(_baseComponent["default"]);

describe('Base Component', function () {
  var fixtureEl;
  var name = 'dummy';
  var element;
  var instance;

  var createInstance = function createInstance() {
    fixtureEl.innerHTML = '<div id="foo"></div>';
    element = fixtureEl.querySelector('#foo');
    instance = new DummyClass(element);
  };

  beforeAll(function () {
    fixtureEl = (0, _fixture.getFixture)();
  });
  afterEach(function () {
    (0, _fixture.clearFixture)();
  });
  describe('Static Methods', function () {
    describe('VERSION', function () {
      it('should return version', function () {
        expect(_typeof(DummyClass.VERSION)).toEqual('string');
      });
    });
    describe('DATA_KEY', function () {
      it('should return plugin data key', function () {
        expect(DummyClass.DATA_KEY).toEqual("bs.".concat(name));
      });
    });
    describe('NAME', function () {
      it('should return plugin NAME', function () {
        expect(DummyClass.NAME).toEqual(name);
      });
    });
    describe('EVENT_KEY', function () {
      it('should return plugin event key', function () {
        expect(DummyClass.EVENT_KEY).toEqual(".bs.".concat(name));
      });
    });
  });
  describe('Public Methods', function () {
    describe('constructor', function () {
      it('should accept element, either passed as a CSS selector or DOM element', function () {
        fixtureEl.innerHTML = ['<div id="foo"></div>', '<div id="bar"></div>'].join('');
        var el = fixtureEl.querySelector('#foo');
        var elInstance = new DummyClass(el);
        var selectorInstance = new DummyClass('#bar');
        expect(elInstance._element).toEqual(el);
        expect(selectorInstance._element).toEqual(fixtureEl.querySelector('#bar'));
      });
    });
    describe('dispose', function () {
      it('should dispose an component', function () {
        createInstance();
        expect(DummyClass.getInstance(element)).not.toBeNull();
        instance.dispose();
        expect(DummyClass.getInstance(element)).toBeNull();
        expect(instance._element).toBeNull();
      });
      it('should de-register element event listeners', function () {
        createInstance();
        spyOn(_eventHandler["default"], 'off');
        instance.dispose();
        expect(_eventHandler["default"].off).toHaveBeenCalledWith(element, DummyClass.EVENT_KEY);
      });
    });
    describe('getInstance', function () {
      it('should return an instance', function () {
        createInstance();
        expect(DummyClass.getInstance(element)).toEqual(instance);
        expect(DummyClass.getInstance(element)).toBeInstanceOf(DummyClass);
      });
      it('should accept element, either passed as a CSS selector, jQuery element, or DOM element', function () {
        createInstance();
        expect(DummyClass.getInstance('#foo')).toEqual(instance);
        expect(DummyClass.getInstance(element)).toEqual(instance);
        var fakejQueryObject = {
          0: element,
          jquery: 'foo'
        };
        expect(DummyClass.getInstance(fakejQueryObject)).toEqual(instance);
      });
      it('should return null when there is no instance', function () {
        fixtureEl.innerHTML = '<div></div>';
        var div = fixtureEl.querySelector('div');
        expect(DummyClass.getInstance(div)).toEqual(null);
      });
    });
    describe('getOrCreateInstance', function () {
      it('should return an instance', function () {
        createInstance();
        expect(DummyClass.getOrCreateInstance(element)).toEqual(instance);
        expect(DummyClass.getInstance(element)).toEqual(DummyClass.getOrCreateInstance(element, {}));
        expect(DummyClass.getOrCreateInstance(element)).toBeInstanceOf(DummyClass);
      });
      it('should return new instance when there is no alert instance', function () {
        fixtureEl.innerHTML = '<div id="foo"></div>';
        element = fixtureEl.querySelector('#foo');
        expect(DummyClass.getInstance(element)).toEqual(null);
        expect(DummyClass.getOrCreateInstance(element)).toBeInstanceOf(DummyClass);
      });
    });
  });
});
"use strict";

var _button = _interopRequireDefault(require("../../src/button"));

var _fixture = require("../helpers/fixture");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/** Test helpers */
describe('Button', function () {
  var fixtureEl;
  beforeAll(function () {
    fixtureEl = (0, _fixture.getFixture)();
  });
  afterEach(function () {
    (0, _fixture.clearFixture)();
  });
  it('should take care of element either passed as a CSS selector or DOM element', function () {
    fixtureEl.innerHTML = '<button data-bs-toggle="button">Placeholder</button>';
    var buttonEl = fixtureEl.querySelector('[data-bs-toggle="button"]');
    var buttonBySelector = new _button["default"]('[data-bs-toggle="button"]');
    var buttonByElement = new _button["default"](buttonEl);
    expect(buttonBySelector._element).toEqual(buttonEl);
    expect(buttonByElement._element).toEqual(buttonEl);
  });
  describe('VERSION', function () {
    it('should return plugin version', function () {
      expect(_button["default"].VERSION).toEqual(jasmine.any(String));
    });
  });
  describe('DATA_KEY', function () {
    it('should return plugin data key', function () {
      expect(_button["default"].DATA_KEY).toEqual('bs.button');
    });
  });
  describe('data-api', function () {
    it('should toggle active class on click', function () {
      fixtureEl.innerHTML = ['<button class="btn" data-bs-toggle="button">btn</button>', '<button class="btn testParent" data-bs-toggle="button"><div class="test"></div></button>'].join('');
      var btn = fixtureEl.querySelector('.btn');
      var divTest = fixtureEl.querySelector('.test');
      var btnTestParent = fixtureEl.querySelector('.testParent');
      expect(btn.classList.contains('active')).toEqual(false);
      btn.click();
      expect(btn.classList.contains('active')).toEqual(true);
      btn.click();
      expect(btn.classList.contains('active')).toEqual(false);
      divTest.click();
      expect(btnTestParent.classList.contains('active')).toEqual(true);
    });
  });
  describe('toggle', function () {
    it('should toggle aria-pressed', function () {
      fixtureEl.innerHTML = '<button class="btn" data-bs-toggle="button" aria-pressed="false"></button>';
      var btnEl = fixtureEl.querySelector('.btn');
      var button = new _button["default"](btnEl);
      expect(btnEl.getAttribute('aria-pressed')).toEqual('false');
      expect(btnEl.classList.contains('active')).toEqual(false);
      button.toggle();
      expect(btnEl.getAttribute('aria-pressed')).toEqual('true');
      expect(btnEl.classList.contains('active')).toEqual(true);
    });
  });
  describe('dispose', function () {
    it('should dispose a button', function () {
      fixtureEl.innerHTML = '<button class="btn" data-bs-toggle="button"></button>';
      var btnEl = fixtureEl.querySelector('.btn');
      var button = new _button["default"](btnEl);
      expect(_button["default"].getInstance(btnEl)).not.toBeNull();
      button.dispose();
      expect(_button["default"].getInstance(btnEl)).toBeNull();
    });
  });
  describe('jQueryInterface', function () {
    it('should handle config passed and toggle existing button', function () {
      fixtureEl.innerHTML = '<button class="btn" data-bs-toggle="button"></button>';
      var btnEl = fixtureEl.querySelector('.btn');
      var button = new _button["default"](btnEl);
      spyOn(button, 'toggle');
      _fixture.jQueryMock.fn.button = _button["default"].jQueryInterface;
      _fixture.jQueryMock.elements = [btnEl];

      _fixture.jQueryMock.fn.button.call(_fixture.jQueryMock, 'toggle');

      expect(button.toggle).toHaveBeenCalled();
    });
    it('should create new button instance and call toggle', function () {
      fixtureEl.innerHTML = '<button class="btn" data-bs-toggle="button"></button>';
      var btnEl = fixtureEl.querySelector('.btn');
      _fixture.jQueryMock.fn.button = _button["default"].jQueryInterface;
      _fixture.jQueryMock.elements = [btnEl];

      _fixture.jQueryMock.fn.button.call(_fixture.jQueryMock, 'toggle');

      expect(_button["default"].getInstance(btnEl)).not.toBeNull();
      expect(btnEl.classList.contains('active')).toEqual(true);
    });
    it('should just create a button instance without calling toggle', function () {
      fixtureEl.innerHTML = '<button class="btn" data-bs-toggle="button"></button>';
      var btnEl = fixtureEl.querySelector('.btn');
      _fixture.jQueryMock.fn.button = _button["default"].jQueryInterface;
      _fixture.jQueryMock.elements = [btnEl];

      _fixture.jQueryMock.fn.button.call(_fixture.jQueryMock);

      expect(_button["default"].getInstance(btnEl)).not.toBeNull();
      expect(btnEl.classList.contains('active')).toEqual(false);
    });
  });
  describe('getInstance', function () {
    it('should return button instance', function () {
      fixtureEl.innerHTML = '<div></div>';
      var div = fixtureEl.querySelector('div');
      var button = new _button["default"](div);
      expect(_button["default"].getInstance(div)).toEqual(button);
      expect(_button["default"].getInstance(div)).toBeInstanceOf(_button["default"]);
    });
    it('should return null when there is no button instance', function () {
      fixtureEl.innerHTML = '<div></div>';
      var div = fixtureEl.querySelector('div');
      expect(_button["default"].getInstance(div)).toEqual(null);
    });
  });
  describe('getOrCreateInstance', function () {
    it('should return button instance', function () {
      fixtureEl.innerHTML = '<div></div>';
      var div = fixtureEl.querySelector('div');
      var button = new _button["default"](div);
      expect(_button["default"].getOrCreateInstance(div)).toEqual(button);
      expect(_button["default"].getInstance(div)).toEqual(_button["default"].getOrCreateInstance(div, {}));
      expect(_button["default"].getOrCreateInstance(div)).toBeInstanceOf(_button["default"]);
    });
    it('should return new instance when there is no button instance', function () {
      fixtureEl.innerHTML = '<div></div>';
      var div = fixtureEl.querySelector('div');
      expect(_button["default"].getInstance(div)).toEqual(null);
      expect(_button["default"].getOrCreateInstance(div)).toBeInstanceOf(_button["default"]);
    });
  });
});
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var _carousel = _interopRequireDefault(require("../../src/carousel"));

var _eventHandler = _interopRequireDefault(require("../../src/dom/event-handler"));

var _fixture = require("../helpers/fixture");

var util = _interopRequireWildcard(require("../../src/util"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

describe('Carousel', function () {
  var _window = window,
      Simulator = _window.Simulator,
      PointerEvent = _window.PointerEvent;
  var originWinPointerEvent = PointerEvent;
  var supportPointerEvent = Boolean(PointerEvent);
  var cssStyleCarousel = '.carousel.pointer-event { touch-action: none; }';
  var stylesCarousel = document.createElement('style');
  stylesCarousel.type = 'text/css';
  stylesCarousel.append(document.createTextNode(cssStyleCarousel));

  var clearPointerEvents = function clearPointerEvents() {
    window.PointerEvent = null;
  };

  var restorePointerEvents = function restorePointerEvents() {
    window.PointerEvent = originWinPointerEvent;
  };

  var fixtureEl;
  beforeAll(function () {
    fixtureEl = (0, _fixture.getFixture)();
  });
  afterEach(function () {
    (0, _fixture.clearFixture)();
  });
  describe('VERSION', function () {
    it('should return plugin version', function () {
      expect(_carousel["default"].VERSION).toEqual(jasmine.any(String));
    });
  });
  describe('Default', function () {
    it('should return plugin default config', function () {
      expect(_carousel["default"].Default).toEqual(jasmine.any(Object));
    });
  });
  describe('DATA_KEY', function () {
    it('should return plugin data key', function () {
      expect(_carousel["default"].DATA_KEY).toEqual('bs.carousel');
    });
  });
  describe('constructor', function () {
    it('should take care of element either passed as a CSS selector or DOM element', function () {
      fixtureEl.innerHTML = '<div id="myCarousel" class="carousel slide"></div>';
      var carouselEl = fixtureEl.querySelector('#myCarousel');
      var carouselBySelector = new _carousel["default"]('#myCarousel');
      var carouselByElement = new _carousel["default"](carouselEl);
      expect(carouselBySelector._element).toEqual(carouselEl);
      expect(carouselByElement._element).toEqual(carouselEl);
    });
    it('should go to next item if right arrow key is pressed', function (done) {
      fixtureEl.innerHTML = ['<div id="myCarousel" class="carousel slide">', '  <div class="carousel-inner">', '    <div class="carousel-item active">item 1</div>', '    <div id="item2" class="carousel-item">item 2</div>', '    <div class="carousel-item">item 3</div>', '  </div>', '</div>'].join('');
      var carouselEl = fixtureEl.querySelector('#myCarousel');
      var carousel = new _carousel["default"](carouselEl, {
        keyboard: true
      });
      spyOn(carousel, '_keydown').and.callThrough();
      carouselEl.addEventListener('slid.bs.carousel', function () {
        expect(fixtureEl.querySelector('.active')).toEqual(fixtureEl.querySelector('#item2'));
        expect(carousel._keydown).toHaveBeenCalled();
        done();
      });
      var keydown = (0, _fixture.createEvent)('keydown');
      keydown.key = 'ArrowRight';
      carouselEl.dispatchEvent(keydown);
    });
    it('should go to previous item if left arrow key is pressed', function (done) {
      fixtureEl.innerHTML = ['<div id="myCarousel" class="carousel slide">', '  <div class="carousel-inner">', '    <div id="item1" class="carousel-item">item 1</div>', '    <div class="carousel-item active">item 2</div>', '    <div class="carousel-item">item 3</div>', '  </div>', '</div>'].join('');
      var carouselEl = fixtureEl.querySelector('#myCarousel');
      var carousel = new _carousel["default"](carouselEl, {
        keyboard: true
      });
      spyOn(carousel, '_keydown').and.callThrough();
      carouselEl.addEventListener('slid.bs.carousel', function () {
        expect(fixtureEl.querySelector('.active')).toEqual(fixtureEl.querySelector('#item1'));
        expect(carousel._keydown).toHaveBeenCalled();
        done();
      });
      var keydown = (0, _fixture.createEvent)('keydown');
      keydown.key = 'ArrowLeft';
      carouselEl.dispatchEvent(keydown);
    });
    it('should not prevent keydown if key is not ARROW_LEFT or ARROW_RIGHT', function (done) {
      fixtureEl.innerHTML = ['<div id="myCarousel" class="carousel slide">', '  <div class="carousel-inner">', '    <div class="carousel-item active">item 1</div>', '    <div class="carousel-item">item 2</div>', '    <div class="carousel-item">item 3</div>', '  </div>', '</div>'].join('');
      var carouselEl = fixtureEl.querySelector('#myCarousel');
      var carousel = new _carousel["default"](carouselEl, {
        keyboard: true
      });
      spyOn(carousel, '_keydown').and.callThrough();
      carouselEl.addEventListener('keydown', function (event) {
        expect(carousel._keydown).toHaveBeenCalled();
        expect(event.defaultPrevented).toEqual(false);
        done();
      });
      var keydown = (0, _fixture.createEvent)('keydown');
      keydown.key = 'ArrowDown';
      carouselEl.dispatchEvent(keydown);
    });
    it('should ignore keyboard events within <input>s and <textarea>s', function () {
      fixtureEl.innerHTML = ['<div id="myCarousel" class="carousel slide">', '  <div class="carousel-inner">', '    <div class="carousel-item active">', '      <input type="text">', '      <textarea></textarea>', '    </div>', '    <div class="carousel-item"></div>', '    <div class="carousel-item">item 3</div>', '  </div>', '</div>'].join('');
      var carouselEl = fixtureEl.querySelector('#myCarousel');
      var input = fixtureEl.querySelector('input');
      var textarea = fixtureEl.querySelector('textarea');
      var carousel = new _carousel["default"](carouselEl, {
        keyboard: true
      });
      var spyKeydown = spyOn(carousel, '_keydown').and.callThrough();
      var spySlide = spyOn(carousel, '_slide');
      var keydown = (0, _fixture.createEvent)('keydown', {
        bubbles: true,
        cancelable: true
      });
      keydown.key = 'ArrowRight';
      Object.defineProperty(keydown, 'target', {
        value: input,
        writable: true,
        configurable: true
      });
      input.dispatchEvent(keydown);
      expect(spyKeydown).toHaveBeenCalled();
      expect(spySlide).not.toHaveBeenCalled();
      spyKeydown.calls.reset();
      spySlide.calls.reset();
      Object.defineProperty(keydown, 'target', {
        value: textarea
      });
      textarea.dispatchEvent(keydown);
      expect(spyKeydown).toHaveBeenCalled();
      expect(spySlide).not.toHaveBeenCalled();
    });
    it('should not slide if arrow key is pressed and carousel is sliding', function () {
      fixtureEl.innerHTML = '<div></div>';
      var carouselEl = fixtureEl.querySelector('div');
      var carousel = new _carousel["default"](carouselEl, {});
      spyOn(carousel, '_triggerSlideEvent');
      carousel._isSliding = true;
      ['ArrowLeft', 'ArrowRight'].forEach(function (key) {
        var keydown = (0, _fixture.createEvent)('keydown');
        keydown.key = key;
        carouselEl.dispatchEvent(keydown);
      });
      expect(carousel._triggerSlideEvent).not.toHaveBeenCalled();
    });
    it('should wrap around from end to start when wrap option is true', function (done) {
      fixtureEl.innerHTML = ['<div id="myCarousel" class="carousel slide">', '  <div class="carousel-inner">', '    <div id="one" class="carousel-item active"></div>', '    <div id="two" class="carousel-item"></div>', '    <div id="three" class="carousel-item">item 3</div>', '  </div>', '</div>'].join('');
      var carouselEl = fixtureEl.querySelector('#myCarousel');
      var carousel = new _carousel["default"](carouselEl, {
        wrap: true
      });

      var getActiveId = function getActiveId() {
        return carouselEl.querySelector('.carousel-item.active').getAttribute('id');
      };

      carouselEl.addEventListener('slid.bs.carousel', function (event) {
        var activeId = getActiveId();

        if (activeId === 'two') {
          carousel.next();
          return;
        }

        if (activeId === 'three') {
          carousel.next();
          return;
        }

        if (activeId === 'one') {
          // carousel wrapped around and slid from 3rd to 1st slide
          expect(activeId).toEqual('one');
          expect(event.from + 1).toEqual(3);
          done();
        }
      });
      carousel.next();
    });
    it('should stay at the start when the prev method is called and wrap is false', function (done) {
      fixtureEl.innerHTML = ['<div id="myCarousel" class="carousel slide">', '  <div class="carousel-inner">', '    <div id="one" class="carousel-item active"></div>', '    <div id="two" class="carousel-item"></div>', '    <div id="three" class="carousel-item">item 3</div>', '  </div>', '</div>'].join('');
      var carouselEl = fixtureEl.querySelector('#myCarousel');
      var firstElement = fixtureEl.querySelector('#one');
      var carousel = new _carousel["default"](carouselEl, {
        wrap: false
      });
      carouselEl.addEventListener('slid.bs.carousel', function () {
        throw new Error('carousel slid when it should not have slid');
      });
      carousel.prev();
      setTimeout(function () {
        expect(firstElement.classList.contains('active')).toEqual(true);
        done();
      }, 10);
    });
    it('should not add touch event listeners if touch = false', function () {
      fixtureEl.innerHTML = '<div></div>';
      var carouselEl = fixtureEl.querySelector('div');
      spyOn(_carousel["default"].prototype, '_addTouchEventListeners');
      var carousel = new _carousel["default"](carouselEl, {
        touch: false
      });
      expect(carousel._addTouchEventListeners).not.toHaveBeenCalled();
    });
    it('should not add touch event listeners if touch supported = false', function () {
      fixtureEl.innerHTML = '<div></div>';
      var carouselEl = fixtureEl.querySelector('div');
      var carousel = new _carousel["default"](carouselEl);

      _eventHandler["default"].off(carouselEl, '.bs-carousel');

      carousel._touchSupported = false;
      spyOn(carousel, '_addTouchEventListeners');

      carousel._addEventListeners();

      expect(carousel._addTouchEventListeners).not.toHaveBeenCalled();
    });
    it('should add touch event listeners by default', function () {
      fixtureEl.innerHTML = '<div></div>';
      var carouselEl = fixtureEl.querySelector('div');
      spyOn(_carousel["default"].prototype, '_addTouchEventListeners'); // Headless browser does not support touch events, so need to fake it
      // to test that touch events are add properly.

      document.documentElement.ontouchstart = function () {};

      var carousel = new _carousel["default"](carouselEl);
      expect(carousel._addTouchEventListeners).toHaveBeenCalled();
    });
    it('should allow swiperight and call _slide (prev) with pointer events', function (done) {
      if (!supportPointerEvent) {
        expect().nothing();
        done();
        return;
      }

      document.documentElement.ontouchstart = function () {};

      document.head.append(stylesCarousel);
      Simulator.setType('pointer');
      fixtureEl.innerHTML = ['<div class="carousel" data-bs-interval="false">', '  <div class="carousel-inner">', '    <div id="item" class="carousel-item">', '      <img alt="">', '    </div>', '    <div class="carousel-item active">', '      <img alt="">', '    </div>', '  </div>', '</div>'].join('');
      var carouselEl = fixtureEl.querySelector('.carousel');
      var item = fixtureEl.querySelector('#item');
      var carousel = new _carousel["default"](carouselEl);
      spyOn(carousel, '_slide').and.callThrough();
      carouselEl.addEventListener('slid.bs.carousel', function (event) {
        expect(item.classList.contains('active')).toEqual(true);
        expect(carousel._slide).toHaveBeenCalledWith('right');
        expect(event.direction).toEqual('right');
        stylesCarousel.remove();
        delete document.documentElement.ontouchstart;
        done();
      });
      Simulator.gestures.swipe(carouselEl, {
        deltaX: 300,
        deltaY: 0
      });
    });
    it('should allow swipeleft and call next with pointer events', function (done) {
      if (!supportPointerEvent) {
        expect().nothing();
        done();
        return;
      }

      document.documentElement.ontouchstart = function () {};

      document.head.append(stylesCarousel);
      Simulator.setType('pointer');
      fixtureEl.innerHTML = ['<div class="carousel" data-bs-interval="false">', '  <div class="carousel-inner">', '    <div id="item" class="carousel-item active">', '      <img alt="">', '    </div>', '    <div class="carousel-item">', '      <img alt="">', '    </div>', '  </div>', '</div>'].join('');
      var carouselEl = fixtureEl.querySelector('.carousel');
      var item = fixtureEl.querySelector('#item');
      var carousel = new _carousel["default"](carouselEl);
      spyOn(carousel, '_slide').and.callThrough();
      carouselEl.addEventListener('slid.bs.carousel', function (event) {
        expect(item.classList.contains('active')).toEqual(false);
        expect(carousel._slide).toHaveBeenCalledWith('left');
        expect(event.direction).toEqual('left');
        stylesCarousel.remove();
        delete document.documentElement.ontouchstart;
        done();
      });
      Simulator.gestures.swipe(carouselEl, {
        pos: [300, 10],
        deltaX: -300,
        deltaY: 0
      });
    });
    it('should allow swiperight and call _slide (prev) with touch events', function (done) {
      Simulator.setType('touch');
      clearPointerEvents();

      document.documentElement.ontouchstart = function () {};

      fixtureEl.innerHTML = ['<div class="carousel" data-bs-interval="false">', '  <div class="carousel-inner">', '    <div id="item" class="carousel-item">', '      <img alt="">', '    </div>', '    <div class="carousel-item active">', '      <img alt="">', '    </div>', '  </div>', '</div>'].join('');
      var carouselEl = fixtureEl.querySelector('.carousel');
      var item = fixtureEl.querySelector('#item');
      var carousel = new _carousel["default"](carouselEl);
      spyOn(carousel, '_slide').and.callThrough();
      carouselEl.addEventListener('slid.bs.carousel', function (event) {
        expect(item.classList.contains('active')).toEqual(true);
        expect(carousel._slide).toHaveBeenCalledWith('right');
        expect(event.direction).toEqual('right');
        delete document.documentElement.ontouchstart;
        restorePointerEvents();
        done();
      });
      Simulator.gestures.swipe(carouselEl, {
        deltaX: 300,
        deltaY: 0
      });
    });
    it('should allow swipeleft and call _slide (next) with touch events', function (done) {
      Simulator.setType('touch');
      clearPointerEvents();

      document.documentElement.ontouchstart = function () {};

      fixtureEl.innerHTML = ['<div class="carousel" data-bs-interval="false">', '  <div class="carousel-inner">', '    <div id="item" class="carousel-item active">', '      <img alt="">', '    </div>', '    <div class="carousel-item">', '      <img alt="">', '    </div>', '  </div>', '</div>'].join('');
      var carouselEl = fixtureEl.querySelector('.carousel');
      var item = fixtureEl.querySelector('#item');
      var carousel = new _carousel["default"](carouselEl);
      spyOn(carousel, '_slide').and.callThrough();
      carouselEl.addEventListener('slid.bs.carousel', function (event) {
        expect(item.classList.contains('active')).toEqual(false);
        expect(carousel._slide).toHaveBeenCalledWith('left');
        expect(event.direction).toEqual('left');
        delete document.documentElement.ontouchstart;
        restorePointerEvents();
        done();
      });
      Simulator.gestures.swipe(carouselEl, {
        pos: [300, 10],
        deltaX: -300,
        deltaY: 0
      });
    });
    it('should not slide when swiping and carousel is sliding', function (done) {
      Simulator.setType('touch');
      clearPointerEvents();

      document.documentElement.ontouchstart = function () {};

      fixtureEl.innerHTML = ['<div class="carousel" data-bs-interval="false">', '  <div class="carousel-inner">', '    <div id="item" class="carousel-item active">', '      <img alt="">', '    </div>', '    <div class="carousel-item">', '      <img alt="">', '    </div>', '  </div>', '</div>'].join('');
      var carouselEl = fixtureEl.querySelector('.carousel');
      var carousel = new _carousel["default"](carouselEl);
      carousel._isSliding = true;
      spyOn(carousel, '_triggerSlideEvent');
      Simulator.gestures.swipe(carouselEl, {
        deltaX: 300,
        deltaY: 0
      });
      Simulator.gestures.swipe(carouselEl, {
        pos: [300, 10],
        deltaX: -300,
        deltaY: 0
      });
      setTimeout(function () {
        expect(carousel._triggerSlideEvent).not.toHaveBeenCalled();
        delete document.documentElement.ontouchstart;
        restorePointerEvents();
        done();
      }, 300);
    });
    it('should not allow pinch with touch events', function (done) {
      Simulator.setType('touch');
      clearPointerEvents();

      document.documentElement.ontouchstart = function () {};

      fixtureEl.innerHTML = '<div class="carousel" data-bs-interval="false"></div>';
      var carouselEl = fixtureEl.querySelector('.carousel');
      var carousel = new _carousel["default"](carouselEl);
      Simulator.gestures.swipe(carouselEl, {
        pos: [300, 10],
        deltaX: -300,
        deltaY: 0,
        touches: 2
      }, function () {
        restorePointerEvents();
        delete document.documentElement.ontouchstart;
        expect(carousel.touchDeltaX).toEqual(0);
        done();
      });
    });
    it('should call pause method on mouse over with pause equal to hover', function (done) {
      fixtureEl.innerHTML = '<div class="carousel"></div>';
      var carouselEl = fixtureEl.querySelector('.carousel');
      var carousel = new _carousel["default"](carouselEl);
      spyOn(carousel, 'pause');
      var mouseOverEvent = (0, _fixture.createEvent)('mouseover');
      carouselEl.dispatchEvent(mouseOverEvent);
      setTimeout(function () {
        expect(carousel.pause).toHaveBeenCalled();
        done();
      }, 10);
    });
    it('should call cycle on mouse out with pause equal to hover', function (done) {
      fixtureEl.innerHTML = '<div class="carousel"></div>';
      var carouselEl = fixtureEl.querySelector('.carousel');
      var carousel = new _carousel["default"](carouselEl);
      spyOn(carousel, 'cycle');
      var mouseOutEvent = (0, _fixture.createEvent)('mouseout');
      carouselEl.dispatchEvent(mouseOutEvent);
      setTimeout(function () {
        expect(carousel.cycle).toHaveBeenCalled();
        done();
      }, 10);
    });
  });
  describe('next', function () {
    it('should not slide if the carousel is sliding', function () {
      fixtureEl.innerHTML = '<div></div>';
      var carouselEl = fixtureEl.querySelector('div');
      var carousel = new _carousel["default"](carouselEl, {});
      spyOn(carousel, '_triggerSlideEvent');
      carousel._isSliding = true;
      carousel.next();
      expect(carousel._triggerSlideEvent).not.toHaveBeenCalled();
    });
    it('should not fire slid when slide is prevented', function (done) {
      fixtureEl.innerHTML = '<div></div>';
      var carouselEl = fixtureEl.querySelector('div');
      var carousel = new _carousel["default"](carouselEl, {});
      var slidEvent = false;

      var doneTest = function doneTest() {
        setTimeout(function () {
          expect(slidEvent).toEqual(false);
          done();
        }, 20);
      };

      carouselEl.addEventListener('slide.bs.carousel', function (event) {
        event.preventDefault();
        doneTest();
      });
      carouselEl.addEventListener('slid.bs.carousel', function () {
        slidEvent = true;
      });
      carousel.next();
    });
    it('should fire slide event with: direction, relatedTarget, from and to', function (done) {
      fixtureEl.innerHTML = ['<div id="myCarousel" class="carousel slide">', '  <div class="carousel-inner">', '    <div class="carousel-item active">item 1</div>', '    <div class="carousel-item">item 2</div>', '    <div class="carousel-item">item 3</div>', '  </div>', '</div>'].join('');
      var carouselEl = fixtureEl.querySelector('#myCarousel');
      var carousel = new _carousel["default"](carouselEl, {});

      var onSlide = function onSlide(event) {
        expect(event.direction).toEqual('left');
        expect(event.relatedTarget.classList.contains('carousel-item')).toEqual(true);
        expect(event.from).toEqual(0);
        expect(event.to).toEqual(1);
        carouselEl.removeEventListener('slide.bs.carousel', onSlide);
        carouselEl.addEventListener('slide.bs.carousel', onSlide2);
        carousel.prev();
      };

      var onSlide2 = function onSlide2(event) {
        expect(event.direction).toEqual('right');
        done();
      };

      carouselEl.addEventListener('slide.bs.carousel', onSlide);
      carousel.next();
    });
    it('should fire slid event with: direction, relatedTarget, from and to', function (done) {
      fixtureEl.innerHTML = ['<div id="myCarousel" class="carousel slide">', '  <div class="carousel-inner">', '    <div class="carousel-item active">item 1</div>', '    <div class="carousel-item">item 2</div>', '    <div class="carousel-item">item 3</div>', '  </div>', '</div>'].join('');
      var carouselEl = fixtureEl.querySelector('#myCarousel');
      var carousel = new _carousel["default"](carouselEl, {});

      var onSlid = function onSlid(event) {
        expect(event.direction).toEqual('left');
        expect(event.relatedTarget.classList.contains('carousel-item')).toEqual(true);
        expect(event.from).toEqual(0);
        expect(event.to).toEqual(1);
        carouselEl.removeEventListener('slid.bs.carousel', onSlid);
        carouselEl.addEventListener('slid.bs.carousel', onSlid2);
        carousel.prev();
      };

      var onSlid2 = function onSlid2(event) {
        expect(event.direction).toEqual('right');
        done();
      };

      carouselEl.addEventListener('slid.bs.carousel', onSlid);
      carousel.next();
    });
    it('should update the active element to the next item before sliding', function () {
      fixtureEl.innerHTML = ['<div id="myCarousel" class="carousel slide">', '  <div class="carousel-inner">', '    <div class="carousel-item active">item 1</div>', '    <div id="secondItem" class="carousel-item">item 2</div>', '    <div class="carousel-item">item 3</div>', '  </div>', '</div>'].join('');
      var carouselEl = fixtureEl.querySelector('#myCarousel');
      var secondItemEl = fixtureEl.querySelector('#secondItem');
      var carousel = new _carousel["default"](carouselEl);
      carousel.next();
      expect(carousel._activeElement).toEqual(secondItemEl);
    });
    it('should update indicators if present', function (done) {
      fixtureEl.innerHTML = ['<div id="myCarousel" class="carousel slide">', '  <div class="carousel-indicators">', '    <button type="button" id="firstIndicator" data-bs-target="myCarousel" data-bs-slide-to="0" class="active" aria-current="true" aria-label="Slide 1"></button>', '    <button type="button" id="secondIndicator" data-bs-target="myCarousel" data-bs-slide-to="1" aria-label="Slide 2"></button>', '    <button type="button" data-bs-target="myCarousel" data-bs-slide-to="2" aria-label="Slide 3"></button>', '  </div>', '  <div class="carousel-inner">', '    <div class="carousel-item active">item 1</div>', '    <div class="carousel-item" data-bs-interval="7">item 2</div>', '    <div class="carousel-item">item 3</div>', '  </div>', '</div>'].join('');
      var carouselEl = fixtureEl.querySelector('#myCarousel');
      var firstIndicator = fixtureEl.querySelector('#firstIndicator');
      var secondIndicator = fixtureEl.querySelector('#secondIndicator');
      var carousel = new _carousel["default"](carouselEl);
      carouselEl.addEventListener('slid.bs.carousel', function () {
        expect(firstIndicator.classList.contains('active')).toEqual(false);
        expect(firstIndicator.hasAttribute('aria-current')).toEqual(false);
        expect(secondIndicator.classList.contains('active')).toEqual(true);
        expect(secondIndicator.getAttribute('aria-current')).toEqual('true');
        done();
      });
      carousel.next();
    });
    it('should call next()/prev() instance methods when clicking the respective direction buttons', function () {
      fixtureEl.innerHTML = ['<div id="carousel" class="carousel slide">', '  <div class="carousel-inner">', '    <div class="carousel-item active">item 1</div>', '    <div class="carousel-item">item 2</div>', '    <div class="carousel-item">item 3</div>', '  </div>', '  <button class="carousel-control-prev" type="button" data-bs-target="#carousel" data-bs-slide="prev"></button>', '  <button class="carousel-control-next" type="button" data-bs-target="#carousel" data-bs-slide="next"></button>', '</div>'].join('');
      var carouselEl = fixtureEl.querySelector('#carousel');
      var prevBtnEl = fixtureEl.querySelector('.carousel-control-prev');
      var nextBtnEl = fixtureEl.querySelector('.carousel-control-next');
      var carousel = new _carousel["default"](carouselEl);
      var nextSpy = spyOn(carousel, 'next');
      var prevSpy = spyOn(carousel, 'prev');
      nextBtnEl.click();
      prevBtnEl.click();
      expect(nextSpy).toHaveBeenCalled();
      expect(prevSpy).toHaveBeenCalled();
    });
  });
  describe('nextWhenVisible', function () {
    it('should not call next when the page is not visible', function () {
      fixtureEl.innerHTML = ['<div style="display: none;">', '  <div class="carousel" data-bs-interval="false"></div>', '</div>'].join('');
      var carouselEl = fixtureEl.querySelector('.carousel');
      var carousel = new _carousel["default"](carouselEl);
      spyOn(carousel, 'next');
      carousel.nextWhenVisible();
      expect(carousel.next).not.toHaveBeenCalled();
    });
  });
  describe('prev', function () {
    it('should not slide if the carousel is sliding', function () {
      fixtureEl.innerHTML = '<div></div>';
      var carouselEl = fixtureEl.querySelector('div');
      var carousel = new _carousel["default"](carouselEl, {});
      spyOn(carousel, '_triggerSlideEvent');
      carousel._isSliding = true;
      carousel.prev();
      expect(carousel._triggerSlideEvent).not.toHaveBeenCalled();
    });
  });
  describe('pause', function () {
    it('should call cycle if the carousel have carousel-item-next and carousel-item-prev class', function () {
      fixtureEl.innerHTML = ['<div id="myCarousel" class="carousel slide">', '  <div class="carousel-inner">', '    <div class="carousel-item active">item 1</div>', '    <div class="carousel-item carousel-item-next">item 2</div>', '    <div class="carousel-item">item 3</div>', '  </div>', '  <div class="carousel-control-prev"></div>', '  <div class="carousel-control-next"></div>', '</div>'].join('');
      var carouselEl = fixtureEl.querySelector('#myCarousel');
      var carousel = new _carousel["default"](carouselEl);
      spyOn(carousel, 'cycle');
      spyOn(window, 'clearInterval');
      carousel.pause();
      expect(carousel.cycle).toHaveBeenCalledWith(true);
      expect(window.clearInterval).toHaveBeenCalled();
      expect(carousel._isPaused).toEqual(true);
    });
    it('should not call cycle if nothing is in transition', function () {
      fixtureEl.innerHTML = ['<div id="myCarousel" class="carousel slide">', '  <div class="carousel-inner">', '    <div class="carousel-item active">item 1</div>', '    <div class="carousel-item">item 2</div>', '    <div class="carousel-item">item 3</div>', '  </div>', '  <div class="carousel-control-prev"></div>', '  <div class="carousel-control-next"></div>', '</div>'].join('');
      var carouselEl = fixtureEl.querySelector('#myCarousel');
      var carousel = new _carousel["default"](carouselEl);
      spyOn(carousel, 'cycle');
      spyOn(window, 'clearInterval');
      carousel.pause();
      expect(carousel.cycle).not.toHaveBeenCalled();
      expect(window.clearInterval).toHaveBeenCalled();
      expect(carousel._isPaused).toEqual(true);
    });
    it('should not set is paused at true if an event is passed', function () {
      fixtureEl.innerHTML = ['<div id="myCarousel" class="carousel slide">', '  <div class="carousel-inner">', '    <div class="carousel-item active">item 1</div>', '    <div class="carousel-item">item 2</div>', '    <div class="carousel-item">item 3</div>', '  </div>', '  <div class="carousel-control-prev"></div>', '  <div class="carousel-control-next"></div>', '</div>'].join('');
      var carouselEl = fixtureEl.querySelector('#myCarousel');
      var carousel = new _carousel["default"](carouselEl);
      var event = (0, _fixture.createEvent)('mouseenter');
      spyOn(window, 'clearInterval');
      carousel.pause(event);
      expect(window.clearInterval).toHaveBeenCalled();
      expect(carousel._isPaused).toEqual(false);
    });
  });
  describe('cycle', function () {
    it('should set an interval', function () {
      fixtureEl.innerHTML = ['<div id="myCarousel" class="carousel slide">', '  <div class="carousel-inner">', '    <div class="carousel-item active">item 1</div>', '    <div class="carousel-item">item 2</div>', '    <div class="carousel-item">item 3</div>', '  </div>', '  <div class="carousel-control-prev"></div>', '  <div class="carousel-control-next"></div>', '</div>'].join('');
      var carouselEl = fixtureEl.querySelector('#myCarousel');
      var carousel = new _carousel["default"](carouselEl);
      spyOn(window, 'setInterval').and.callThrough();
      carousel.cycle();
      expect(window.setInterval).toHaveBeenCalled();
    });
    it('should not set interval if the carousel is paused', function () {
      fixtureEl.innerHTML = ['<div id="myCarousel" class="carousel slide">', '  <div class="carousel-inner">', '    <div class="carousel-item active">item 1</div>', '    <div class="carousel-item">item 2</div>', '    <div class="carousel-item">item 3</div>', '  </div>', '  <div class="carousel-control-prev"></div>', '  <div class="carousel-control-next"></div>', '</div>'].join('');
      var carouselEl = fixtureEl.querySelector('#myCarousel');
      var carousel = new _carousel["default"](carouselEl);
      spyOn(window, 'setInterval').and.callThrough();
      carousel._isPaused = true;
      carousel.cycle(true);
      expect(window.setInterval).not.toHaveBeenCalled();
    });
    it('should clear interval if there is one', function () {
      fixtureEl.innerHTML = ['<div id="myCarousel" class="carousel slide">', '  <div class="carousel-inner">', '    <div class="carousel-item active">item 1</div>', '    <div class="carousel-item">item 2</div>', '    <div class="carousel-item">item 3</div>', '  </div>', '  <div class="carousel-control-prev"></div>', '  <div class="carousel-control-next"></div>', '</div>'].join('');
      var carouselEl = fixtureEl.querySelector('#myCarousel');
      var carousel = new _carousel["default"](carouselEl);
      carousel._interval = setInterval(function () {}, 10);
      spyOn(window, 'setInterval').and.callThrough();
      spyOn(window, 'clearInterval').and.callThrough();
      carousel.cycle();
      expect(window.setInterval).toHaveBeenCalled();
      expect(window.clearInterval).toHaveBeenCalled();
    });
    it('should get interval from data attribute on the active item element', function () {
      fixtureEl.innerHTML = ['<div id="myCarousel" class="carousel slide">', '  <div class="carousel-inner">', '    <div class="carousel-item active" data-bs-interval="7">item 1</div>', '    <div id="secondItem" class="carousel-item" data-bs-interval="9385">item 2</div>', '    <div class="carousel-item">item 3</div>', '  </div>', '</div>'].join('');
      var carouselEl = fixtureEl.querySelector('#myCarousel');
      var secondItemEl = fixtureEl.querySelector('#secondItem');
      var carousel = new _carousel["default"](carouselEl, {
        interval: 1814
      });
      expect(carousel._config.interval).toEqual(1814);
      carousel.cycle();
      expect(carousel._config.interval).toEqual(7);
      carousel._activeElement = secondItemEl;
      carousel.cycle();
      expect(carousel._config.interval).toEqual(9385);
    });
  });
  describe('to', function () {
    it('should go directly to the provided index', function (done) {
      fixtureEl.innerHTML = ['<div id="myCarousel" class="carousel slide">', '  <div class="carousel-inner">', '    <div id="item1" class="carousel-item active">item 1</div>', '    <div class="carousel-item">item 2</div>', '    <div id="item3" class="carousel-item">item 3</div>', '  </div>', '</div>'].join('');
      var carouselEl = fixtureEl.querySelector('#myCarousel');
      var carousel = new _carousel["default"](carouselEl, {});
      expect(fixtureEl.querySelector('.active')).toEqual(fixtureEl.querySelector('#item1'));
      carousel.to(2);
      carouselEl.addEventListener('slid.bs.carousel', function () {
        expect(fixtureEl.querySelector('.active')).toEqual(fixtureEl.querySelector('#item3'));
        done();
      });
    });
    it('should return to a previous slide if the provided index is lower than the current', function (done) {
      fixtureEl.innerHTML = ['<div id="myCarousel" class="carousel slide">', '  <div class="carousel-inner">', '    <div class="carousel-item">item 1</div>', '    <div id="item2" class="carousel-item">item 2</div>', '    <div id="item3" class="carousel-item active">item 3</div>', '  </div>', '</div>'].join('');
      var carouselEl = fixtureEl.querySelector('#myCarousel');
      var carousel = new _carousel["default"](carouselEl, {});
      expect(fixtureEl.querySelector('.active')).toEqual(fixtureEl.querySelector('#item3'));
      carousel.to(1);
      carouselEl.addEventListener('slid.bs.carousel', function () {
        expect(fixtureEl.querySelector('.active')).toEqual(fixtureEl.querySelector('#item2'));
        done();
      });
    });
    it('should do nothing if a wrong index is provided', function () {
      fixtureEl.innerHTML = ['<div id="myCarousel" class="carousel slide">', '  <div class="carousel-inner">', '    <div class="carousel-item active">item 1</div>', '    <div class="carousel-item" data-bs-interval="7">item 2</div>', '    <div class="carousel-item">item 3</div>', '  </div>', '</div>'].join('');
      var carouselEl = fixtureEl.querySelector('#myCarousel');
      var carousel = new _carousel["default"](carouselEl, {});
      var spy = spyOn(carousel, '_slide');
      carousel.to(25);
      expect(spy).not.toHaveBeenCalled();
      spy.calls.reset();
      carousel.to(-5);
      expect(spy).not.toHaveBeenCalled();
    });
    it('should call pause and cycle is the provided is the same compare to the current one', function () {
      fixtureEl.innerHTML = ['<div id="myCarousel" class="carousel slide">', '  <div class="carousel-inner">', '    <div class="carousel-item active">item 1</div>', '    <div class="carousel-item" data-bs-interval="7">item 2</div>', '    <div class="carousel-item">item 3</div>', '  </div>', '</div>'].join('');
      var carouselEl = fixtureEl.querySelector('#myCarousel');
      var carousel = new _carousel["default"](carouselEl, {});
      spyOn(carousel, '_slide');
      spyOn(carousel, 'pause');
      spyOn(carousel, 'cycle');
      carousel.to(0);
      expect(carousel._slide).not.toHaveBeenCalled();
      expect(carousel.pause).toHaveBeenCalled();
      expect(carousel.cycle).toHaveBeenCalled();
    });
    it('should wait before performing to if a slide is sliding', function (done) {
      fixtureEl.innerHTML = ['<div id="myCarousel" class="carousel slide">', '  <div class="carousel-inner">', '    <div class="carousel-item active">item 1</div>', '    <div class="carousel-item" data-bs-interval="7">item 2</div>', '    <div class="carousel-item">item 3</div>', '  </div>', '</div>'].join('');
      var carouselEl = fixtureEl.querySelector('#myCarousel');
      var carousel = new _carousel["default"](carouselEl, {});
      spyOn(_eventHandler["default"], 'one').and.callThrough();
      spyOn(carousel, '_slide');
      carousel._isSliding = true;
      carousel.to(1);
      expect(carousel._slide).not.toHaveBeenCalled();
      expect(_eventHandler["default"].one).toHaveBeenCalled();
      spyOn(carousel, 'to');

      _eventHandler["default"].trigger(carouselEl, 'slid.bs.carousel');

      setTimeout(function () {
        expect(carousel.to).toHaveBeenCalledWith(1);
        done();
      });
    });
  });
  describe('rtl function', function () {
    it('"_directionToOrder" and "_orderToDirection" must return the right results', function () {
      fixtureEl.innerHTML = '<div></div>';
      var carouselEl = fixtureEl.querySelector('div');
      var carousel = new _carousel["default"](carouselEl, {});
      expect(carousel._directionToOrder('left')).toEqual('next');
      expect(carousel._directionToOrder('prev')).toEqual('prev');
      expect(carousel._directionToOrder('right')).toEqual('prev');
      expect(carousel._directionToOrder('next')).toEqual('next');
      expect(carousel._orderToDirection('next')).toEqual('left');
      expect(carousel._orderToDirection('prev')).toEqual('right');
    });
    it('"_directionToOrder" and "_orderToDirection" must return the right results when rtl=true', function () {
      document.documentElement.dir = 'rtl';
      fixtureEl.innerHTML = '<div></div>';
      var carouselEl = fixtureEl.querySelector('div');
      var carousel = new _carousel["default"](carouselEl, {});
      expect(util.isRTL()).toEqual(true, 'rtl has to be true');
      expect(carousel._directionToOrder('left')).toEqual('prev');
      expect(carousel._directionToOrder('prev')).toEqual('prev');
      expect(carousel._directionToOrder('right')).toEqual('next');
      expect(carousel._directionToOrder('next')).toEqual('next');
      expect(carousel._orderToDirection('next')).toEqual('right');
      expect(carousel._orderToDirection('prev')).toEqual('left');
      document.documentElement.dir = 'ltl';
    });
    it('"_slide" has to call _directionToOrder and "_orderToDirection"', function () {
      fixtureEl.innerHTML = '<div></div>';
      var carouselEl = fixtureEl.querySelector('div');
      var carousel = new _carousel["default"](carouselEl, {});
      var spy = spyOn(carousel, '_directionToOrder').and.callThrough();
      var spy2 = spyOn(carousel, '_orderToDirection').and.callThrough();

      carousel._slide('left');

      expect(spy).toHaveBeenCalledWith('left');
      expect(spy2).toHaveBeenCalledWith('next');

      carousel._slide('right');

      expect(spy).toHaveBeenCalledWith('right');
      expect(spy2).toHaveBeenCalledWith('prev');
    });
    it('"_slide" has to call "_directionToOrder" and "_orderToDirection" when rtl=true', function () {
      document.documentElement.dir = 'rtl';
      fixtureEl.innerHTML = '<div></div>';
      var carouselEl = fixtureEl.querySelector('div');
      var carousel = new _carousel["default"](carouselEl, {});
      var spy = spyOn(carousel, '_directionToOrder').and.callThrough();
      var spy2 = spyOn(carousel, '_orderToDirection').and.callThrough();

      carousel._slide('left');

      expect(spy).toHaveBeenCalledWith('left');
      expect(spy2).toHaveBeenCalledWith('prev');

      carousel._slide('right');

      expect(spy).toHaveBeenCalledWith('right');
      expect(spy2).toHaveBeenCalledWith('next');
      document.documentElement.dir = 'ltl';
    });
  });
  describe('dispose', function () {
    it('should destroy a carousel', function () {
      fixtureEl.innerHTML = ['<div id="myCarousel" class="carousel slide">', '  <div class="carousel-inner">', '    <div class="carousel-item active">item 1</div>', '    <div class="carousel-item" data-bs-interval="7">item 2</div>', '    <div class="carousel-item">item 3</div>', '  </div>', '</div>'].join('');
      var carouselEl = fixtureEl.querySelector('#myCarousel');
      var addEventSpy = spyOn(carouselEl, 'addEventListener').and.callThrough();
      var removeEventSpy = spyOn(carouselEl, 'removeEventListener').and.callThrough(); // Headless browser does not support touch events, so need to fake it
      // to test that touch events are add/removed properly.

      document.documentElement.ontouchstart = function () {};

      var carousel = new _carousel["default"](carouselEl);
      var expectedArgs = [['keydown', jasmine.any(Function), jasmine.any(Boolean)], ['mouseover', jasmine.any(Function), jasmine.any(Boolean)], ['mouseout', jasmine.any(Function), jasmine.any(Boolean)]].concat(_toConsumableArray(carousel._pointerEvent ? [['pointerdown', jasmine.any(Function), jasmine.any(Boolean)], ['pointerup', jasmine.any(Function), jasmine.any(Boolean)]] : [['touchstart', jasmine.any(Function), jasmine.any(Boolean)], ['touchmove', jasmine.any(Function), jasmine.any(Boolean)], ['touchend', jasmine.any(Function), jasmine.any(Boolean)]]));
      expect(addEventSpy.calls.allArgs()).toEqual(expectedArgs);
      carousel.dispose();
      expect(removeEventSpy.calls.allArgs()).toEqual(expectedArgs);
      delete document.documentElement.ontouchstart;
    });
  });
  describe('getInstance', function () {
    it('should return carousel instance', function () {
      fixtureEl.innerHTML = '<div></div>';
      var div = fixtureEl.querySelector('div');
      var carousel = new _carousel["default"](div);
      expect(_carousel["default"].getInstance(div)).toEqual(carousel);
      expect(_carousel["default"].getInstance(div)).toBeInstanceOf(_carousel["default"]);
    });
    it('should return null when there is no carousel instance', function () {
      fixtureEl.innerHTML = '<div></div>';
      var div = fixtureEl.querySelector('div');
      expect(_carousel["default"].getInstance(div)).toEqual(null);
    });
  });
  describe('getOrCreateInstance', function () {
    it('should return carousel instance', function () {
      fixtureEl.innerHTML = '<div></div>';
      var div = fixtureEl.querySelector('div');
      var carousel = new _carousel["default"](div);
      expect(_carousel["default"].getOrCreateInstance(div)).toEqual(carousel);
      expect(_carousel["default"].getInstance(div)).toEqual(_carousel["default"].getOrCreateInstance(div, {}));
      expect(_carousel["default"].getOrCreateInstance(div)).toBeInstanceOf(_carousel["default"]);
    });
    it('should return new instance when there is no carousel instance', function () {
      fixtureEl.innerHTML = '<div></div>';
      var div = fixtureEl.querySelector('div');
      expect(_carousel["default"].getInstance(div)).toEqual(null);
      expect(_carousel["default"].getOrCreateInstance(div)).toBeInstanceOf(_carousel["default"]);
    });
    it('should return new instance when there is no carousel instance with given configuration', function () {
      fixtureEl.innerHTML = '<div></div>';
      var div = fixtureEl.querySelector('div');
      expect(_carousel["default"].getInstance(div)).toEqual(null);

      var carousel = _carousel["default"].getOrCreateInstance(div, {
        interval: 1
      });

      expect(carousel).toBeInstanceOf(_carousel["default"]);
      expect(carousel._config.interval).toEqual(1);
    });
    it('should return the instance when exists without given configuration', function () {
      fixtureEl.innerHTML = '<div></div>';
      var div = fixtureEl.querySelector('div');
      var carousel = new _carousel["default"](div, {
        interval: 1
      });
      expect(_carousel["default"].getInstance(div)).toEqual(carousel);

      var carousel2 = _carousel["default"].getOrCreateInstance(div, {
        interval: 2
      });

      expect(carousel).toBeInstanceOf(_carousel["default"]);
      expect(carousel2).toEqual(carousel);
      expect(carousel2._config.interval).toEqual(1);
    });
  });
  describe('jQueryInterface', function () {
    it('should create a carousel', function () {
      fixtureEl.innerHTML = '<div></div>';
      var div = fixtureEl.querySelector('div');
      _fixture.jQueryMock.fn.carousel = _carousel["default"].jQueryInterface;
      _fixture.jQueryMock.elements = [div];

      _fixture.jQueryMock.fn.carousel.call(_fixture.jQueryMock);

      expect(_carousel["default"].getInstance(div)).not.toBeNull();
    });
    it('should not re create a carousel', function () {
      fixtureEl.innerHTML = '<div></div>';
      var div = fixtureEl.querySelector('div');
      var carousel = new _carousel["default"](div);
      _fixture.jQueryMock.fn.carousel = _carousel["default"].jQueryInterface;
      _fixture.jQueryMock.elements = [div];

      _fixture.jQueryMock.fn.carousel.call(_fixture.jQueryMock);

      expect(_carousel["default"].getInstance(div)).toEqual(carousel);
    });
    it('should call to if the config is a number', function () {
      fixtureEl.innerHTML = '<div></div>';
      var div = fixtureEl.querySelector('div');
      var carousel = new _carousel["default"](div);
      var slideTo = 2;
      spyOn(carousel, 'to');
      _fixture.jQueryMock.fn.carousel = _carousel["default"].jQueryInterface;
      _fixture.jQueryMock.elements = [div];

      _fixture.jQueryMock.fn.carousel.call(_fixture.jQueryMock, slideTo);

      expect(carousel.to).toHaveBeenCalledWith(slideTo);
    });
    it('should throw error on undefined method', function () {
      fixtureEl.innerHTML = '<div></div>';
      var div = fixtureEl.querySelector('div');
      var action = 'undefinedMethod';
      _fixture.jQueryMock.fn.carousel = _carousel["default"].jQueryInterface;
      _fixture.jQueryMock.elements = [div];
      expect(function () {
        _fixture.jQueryMock.fn.carousel.call(_fixture.jQueryMock, action);
      }).toThrowError(TypeError, "No method named \"".concat(action, "\""));
    });
  });
  describe('data-api', function () {
    it('should init carousels with data-bs-ride="carousel" on load', function () {
      fixtureEl.innerHTML = '<div data-bs-ride="carousel"></div>';
      var carouselEl = fixtureEl.querySelector('div');
      var loadEvent = (0, _fixture.createEvent)('load');
      window.dispatchEvent(loadEvent);
      expect(_carousel["default"].getInstance(carouselEl)).not.toBeNull();
    });
    it('should create carousel and go to the next slide on click (with real button controls)', function (done) {
      fixtureEl.innerHTML = ['<div id="myCarousel" class="carousel slide">', '  <div class="carousel-inner">', '    <div class="carousel-item active">item 1</div>', '    <div id="item2" class="carousel-item">item 2</div>', '    <div class="carousel-item">item 3</div>', '  </div>', '  <button class="carousel-control-prev" data-bs-target="#myCarousel" type="button" data-bs-slide="prev"></button>', '  <button id="next" class="carousel-control-next" data-bs-target="#myCarousel" type="button" data-bs-slide="next"></div>', '</div>'].join('');
      var next = fixtureEl.querySelector('#next');
      var item2 = fixtureEl.querySelector('#item2');
      next.click();
      setTimeout(function () {
        expect(item2.classList.contains('active')).toEqual(true);
        done();
      }, 10);
    });
    it('should create carousel and go to the next slide on click (using links as controls)', function (done) {
      fixtureEl.innerHTML = ['<div id="myCarousel" class="carousel slide">', '  <div class="carousel-inner">', '    <div class="carousel-item active">item 1</div>', '    <div id="item2" class="carousel-item">item 2</div>', '    <div class="carousel-item">item 3</div>', '  </div>', '  <a class="carousel-control-prev" href="#myCarousel" role="button" data-bs-slide="prev"></button>', '  <a id="next" class="carousel-control-next" href="#myCarousel" role="button" data-bs-slide="next"></div>', '</div>'].join('');
      var next = fixtureEl.querySelector('#next');
      var item2 = fixtureEl.querySelector('#item2');
      next.click();
      setTimeout(function () {
        expect(item2.classList.contains('active')).toEqual(true);
        done();
      }, 10);
    });
    it('should create carousel and go to the next slide on click with data-bs-slide-to', function (done) {
      fixtureEl.innerHTML = ['<div id="myCarousel" class="carousel slide">', '  <div class="carousel-inner">', '    <div class="carousel-item active">item 1</div>', '    <div id="item2" class="carousel-item">item 2</div>', '    <div class="carousel-item">item 3</div>', '  </div>', '  <div id="next" data-bs-target="#myCarousel" data-bs-slide-to="1"></div>', '</div>'].join('');
      var next = fixtureEl.querySelector('#next');
      var item2 = fixtureEl.querySelector('#item2');
      next.click();
      setTimeout(function () {
        expect(item2.classList.contains('active')).toEqual(true);
        done();
      }, 10);
    });
    it('should do nothing if no selector on click on arrows', function () {
      fixtureEl.innerHTML = ['<div id="myCarousel" class="carousel slide">', '  <div class="carousel-inner">', '    <div class="carousel-item active">item 1</div>', '    <div class="carousel-item">item 2</div>', '    <div class="carousel-item">item 3</div>', '  </div>', '  <button class="carousel-control-prev" data-bs-target="#myCarousel" type="button" data-bs-slide="prev"></button>', '  <button id="next" class="carousel-control-next" type="button" data-bs-slide="next"></button>', '</div>'].join('');
      var next = fixtureEl.querySelector('#next');
      next.click();
      expect().nothing();
    });
    it('should do nothing if no carousel class on click on arrows', function () {
      fixtureEl.innerHTML = ['<div id="myCarousel" class="slide">', '  <div class="carousel-inner">', '    <div class="carousel-item active">item 1</div>', '    <div id="item2" class="carousel-item">item 2</div>', '    <div class="carousel-item">item 3</div>', '  </div>', '  <button class="carousel-control-prev" data-bs-target="#myCarousel" type="button" data-bs-slide="prev"></div>', '  <button id="next" class="carousel-control-next" data-bs-target="#myCarousel" type="button" data-bs-slide="next"></div>', '</div>'].join('');
      var next = fixtureEl.querySelector('#next');
      next.click();
      expect().nothing();
    });
  });
});
"use strict";

var _collapse = _interopRequireDefault(require("../../src/collapse"));

var _eventHandler = _interopRequireDefault(require("../../src/dom/event-handler"));

var _fixture = require("../helpers/fixture");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

describe('Collapse', function () {
  var fixtureEl;
  beforeAll(function () {
    fixtureEl = (0, _fixture.getFixture)();
  });
  afterEach(function () {
    (0, _fixture.clearFixture)();
  });
  describe('VERSION', function () {
    it('should return plugin version', function () {
      expect(_collapse["default"].VERSION).toEqual(jasmine.any(String));
    });
  });
  describe('Default', function () {
    it('should return plugin default config', function () {
      expect(_collapse["default"].Default).toEqual(jasmine.any(Object));
    });
  });
  describe('DATA_KEY', function () {
    it('should return plugin data key', function () {
      expect(_collapse["default"].DATA_KEY).toEqual('bs.collapse');
    });
  });
  describe('constructor', function () {
    it('should take care of element either passed as a CSS selector or DOM element', function () {
      fixtureEl.innerHTML = '<div class="my-collapse"></div>';
      var collapseEl = fixtureEl.querySelector('div.my-collapse');
      var collapseBySelector = new _collapse["default"]('div.my-collapse');
      var collapseByElement = new _collapse["default"](collapseEl);
      expect(collapseBySelector._element).toEqual(collapseEl);
      expect(collapseByElement._element).toEqual(collapseEl);
    });
    it('should allow jquery object in parent config', function () {
      fixtureEl.innerHTML = ['<div class="my-collapse">', '  <div class="item">', '    <a data-bs-toggle="collapse" href="#">Toggle item</a>', '    <div class="collapse">Lorem ipsum</div>', '  </div>', '</div>'].join('');
      var collapseEl = fixtureEl.querySelector('div.collapse');
      var myCollapseEl = fixtureEl.querySelector('.my-collapse');
      var fakejQueryObject = {
        0: myCollapseEl,
        jquery: 'foo'
      };
      var collapse = new _collapse["default"](collapseEl, {
        parent: fakejQueryObject
      });
      expect(collapse._config.parent).toEqual(myCollapseEl);
    });
    it('should allow non jquery object in parent config', function () {
      fixtureEl.innerHTML = ['<div class="my-collapse">', '  <div class="item">', '    <a data-bs-toggle="collapse" href="#">Toggle item</a>', '    <div class="collapse">Lorem ipsum</div>', '  </div>', '</div>'].join('');
      var collapseEl = fixtureEl.querySelector('div.collapse');
      var myCollapseEl = fixtureEl.querySelector('.my-collapse');
      var collapse = new _collapse["default"](collapseEl, {
        parent: myCollapseEl
      });
      expect(collapse._config.parent).toEqual(myCollapseEl);
    });
    it('should allow string selector in parent config', function () {
      fixtureEl.innerHTML = ['<div class="my-collapse">', '  <div class="item">', '    <a data-bs-toggle="collapse" href="#">Toggle item</a>', '    <div class="collapse">Lorem ipsum</div>', '  </div>', '</div>'].join('');
      var collapseEl = fixtureEl.querySelector('div.collapse');
      var myCollapseEl = fixtureEl.querySelector('.my-collapse');
      var collapse = new _collapse["default"](collapseEl, {
        parent: 'div.my-collapse'
      });
      expect(collapse._config.parent).toEqual(myCollapseEl);
    });
  });
  describe('toggle', function () {
    it('should call show method if show class is not present', function () {
      fixtureEl.innerHTML = '<div></div>';
      var collapseEl = fixtureEl.querySelector('div');
      var collapse = new _collapse["default"](collapseEl);
      spyOn(collapse, 'show');
      collapse.toggle();
      expect(collapse.show).toHaveBeenCalled();
    });
    it('should call hide method if show class is present', function () {
      fixtureEl.innerHTML = '<div class="show"></div>';
      var collapseEl = fixtureEl.querySelector('.show');
      var collapse = new _collapse["default"](collapseEl, {
        toggle: false
      });
      spyOn(collapse, 'hide');
      collapse.toggle();
      expect(collapse.hide).toHaveBeenCalled();
    });
    it('should find collapse children if they have collapse class too not only data-bs-parent', function (done) {
      var _ref;

      fixtureEl.innerHTML = ['<div class="my-collapse">', '  <div class="item">', '    <a data-bs-toggle="collapse" href="#">Toggle item 1</a>', '    <div id="collapse1" class="collapse show">Lorem ipsum 1</div>', '  </div>', '  <div class="item">', '    <a id="triggerCollapse2" data-bs-toggle="collapse" href="#">Toggle item 2</a>', '    <div id="collapse2" class="collapse">Lorem ipsum 2</div>', '  </div>', '</div>'].join('');
      var parent = fixtureEl.querySelector('.my-collapse');
      var collapseEl1 = fixtureEl.querySelector('#collapse1');
      var collapseEl2 = fixtureEl.querySelector('#collapse2');

      var collapseList = (_ref = []).concat.apply(_ref, _toConsumableArray(fixtureEl.querySelectorAll('.collapse'))).map(function (el) {
        return new _collapse["default"](el, {
          parent: parent,
          toggle: false
        });
      });

      collapseEl2.addEventListener('shown.bs.collapse', function () {
        expect(collapseEl2.classList.contains('show')).toEqual(true);
        expect(collapseEl1.classList.contains('show')).toEqual(false);
        done();
      });
      collapseList[1].toggle();
    });
  });
  describe('show', function () {
    it('should do nothing if is transitioning', function () {
      fixtureEl.innerHTML = '<div></div>';
      spyOn(_eventHandler["default"], 'trigger');
      var collapseEl = fixtureEl.querySelector('div');
      var collapse = new _collapse["default"](collapseEl, {
        toggle: false
      });
      collapse._isTransitioning = true;
      collapse.show();
      expect(_eventHandler["default"].trigger).not.toHaveBeenCalled();
    });
    it('should do nothing if already shown', function () {
      fixtureEl.innerHTML = '<div class="show"></div>';
      spyOn(_eventHandler["default"], 'trigger');
      var collapseEl = fixtureEl.querySelector('div');
      var collapse = new _collapse["default"](collapseEl, {
        toggle: false
      });
      collapse.show();
      expect(_eventHandler["default"].trigger).not.toHaveBeenCalled();
    });
    it('should show a collapsed element', function (done) {
      fixtureEl.innerHTML = '<div class="collapse" style="height: 0px;"></div>';
      var collapseEl = fixtureEl.querySelector('div');
      var collapse = new _collapse["default"](collapseEl, {
        toggle: false
      });
      collapseEl.addEventListener('show.bs.collapse', function () {
        expect(collapseEl.style.height).toEqual('0px');
      });
      collapseEl.addEventListener('shown.bs.collapse', function () {
        expect(collapseEl.classList.contains('show')).toEqual(true);
        expect(collapseEl.style.height).toEqual('');
        done();
      });
      collapse.show();
    });
    it('should show a collapsed element on width', function (done) {
      fixtureEl.innerHTML = '<div class="collapse collapse-horizontal" style="width: 0px;"></div>';
      var collapseEl = fixtureEl.querySelector('div');
      var collapse = new _collapse["default"](collapseEl, {
        toggle: false
      });
      collapseEl.addEventListener('show.bs.collapse', function () {
        expect(collapseEl.style.width).toEqual('0px');
      });
      collapseEl.addEventListener('shown.bs.collapse', function () {
        expect(collapseEl.classList.contains('show')).toEqual(true);
        expect(collapseEl.style.width).toEqual('');
        done();
      });
      collapse.show();
    });
    it('should collapse only the first collapse', function (done) {
      fixtureEl.innerHTML = ['<div class="card" id="accordion1">', '  <div id="collapse1" class="collapse"></div>', '</div>', '<div class="card" id="accordion2">', '  <div id="collapse2" class="collapse show"></div>', '</div>'].join('');
      var el1 = fixtureEl.querySelector('#collapse1');
      var el2 = fixtureEl.querySelector('#collapse2');
      var collapse = new _collapse["default"](el1, {
        toggle: false
      });
      el1.addEventListener('shown.bs.collapse', function () {
        expect(el1.classList.contains('show')).toEqual(true);
        expect(el2.classList.contains('show')).toEqual(true);
        done();
      });
      collapse.show();
    });
    it('should be able to handle toggling of other children siblings', function (done) {
      fixtureEl.innerHTML = ['<div id="parentGroup" class="accordion">', '   <div id="parentHeader" class="accordion-header">', '      <button data-bs-target="#parentContent" data-bs-toggle="collapse" role="button" class="accordion-toggle">Parent</button>', '   </div>', '   <div id="parentContent" class="accordion-collapse collapse" aria-labelledby="parentHeader" data-bs-parent="#parentGroup">', '      <div class="accordion-body">', '         <div id="childGroup" class="accordion">', '            <div class="accordion-item">', '               <div id="childHeader1" class="accordion-header">', '                  <button data-bs-target="#childContent1" data-bs-toggle="collapse" role="button" class="accordion-toggle">Child 1</button>', '               </div>', '               <div id="childContent1" class="accordion-collapse collapse" aria-labelledby="childHeader1" data-bs-parent="#childGroup">', '                  <div>content</div>', '               </div>', '            </div>', '            <div class="accordion-item">', '               <div id="childHeader2" class="accordion-header">', '                  <button data-bs-target="#childContent2" data-bs-toggle="collapse" role="button" class="accordion-toggle">Child 2</button>', '               </div>', '               <div id="childContent2" class="accordion-collapse collapse" aria-labelledby="childHeader2" data-bs-parent="#childGroup">', '                  <div>content</div>', '               </div>', '            </div>', '         </div>', '      </div>', '   </div>', '</div>'].join('');

      var el = function el(selector) {
        return fixtureEl.querySelector(selector);
      };

      var parentBtn = el('[data-bs-target="#parentContent"]');
      var childBtn1 = el('[data-bs-target="#childContent1"]');
      var childBtn2 = el('[data-bs-target="#childContent2"]');
      var parentCollapseEl = el('#parentContent');
      var childCollapseEl1 = el('#childContent1');
      var childCollapseEl2 = el('#childContent2');
      parentCollapseEl.addEventListener('shown.bs.collapse', function () {
        expect(parentCollapseEl.classList.contains('show')).toEqual(true);
        childBtn1.click();
      });
      childCollapseEl1.addEventListener('shown.bs.collapse', function () {
        expect(childCollapseEl1.classList.contains('show')).toEqual(true);
        childBtn2.click();
      });
      childCollapseEl2.addEventListener('shown.bs.collapse', function () {
        expect(childCollapseEl2.classList.contains('show')).toEqual(true);
        expect(childCollapseEl1.classList.contains('show')).toEqual(false);
        done();
      });
      parentBtn.click();
    });
    it('should not change tab tabpanels descendants on accordion', function (done) {
      fixtureEl.innerHTML = ['<div class="accordion" id="accordionExample">', '      <div class="accordion-item">', '        <h2 class="accordion-header" id="headingOne">', '          <button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapseOne" aria-expanded="true" aria-controls="collapseOne">', '            Accordion Item #1', '          </button>', '        </h2>', '        <div id="collapseOne" class="accordion-collapse collapse show" aria-labelledby="headingOne" data-bs-parent="#accordionExample">', '          <div class="accordion-body">', '            <nav>', '              <div class="nav nav-tabs" id="nav-tab" role="tablist">', '                <button class="nav-link active" id="nav-home-tab" data-bs-toggle="tab" data-bs-target="#nav-home" type="button" role="tab" aria-controls="nav-home" aria-selected="true">Home</button>', '                <button class="nav-link" id="nav-profile-tab" data-bs-toggle="tab" data-bs-target="#nav-profile" type="button" role="tab" aria-controls="nav-profile" aria-selected="false">Profile</button>', '              </div>', '            </nav>', '            <div class="tab-content" id="nav-tabContent">', '              <div class="tab-pane fade show active" id="nav-home" role="tabpanel" aria-labelledby="nav-home-tab">Home</div>', '              <div class="tab-pane fade" id="nav-profile" role="tabpanel" aria-labelledby="nav-profile-tab">Profile</div>', '            </div>', '          </div>', '        </div>', '      </div>', '    </div>'].join('');
      var el = fixtureEl.querySelector('#collapseOne');
      var activeTabPane = fixtureEl.querySelector('#nav-home');
      var collapse = new _collapse["default"](el);
      var times = 1;
      el.addEventListener('hidden.bs.collapse', function () {
        collapse.show();
      });
      el.addEventListener('shown.bs.collapse', function () {
        expect(activeTabPane.classList.contains('show')).toEqual(true);
        times++;

        if (times === 2) {
          done();
        }

        collapse.hide();
      });
      collapse.show();
    });
    it('should not fire shown when show is prevented', function (done) {
      fixtureEl.innerHTML = '<div class="collapse"></div>';
      var collapseEl = fixtureEl.querySelector('div');
      var collapse = new _collapse["default"](collapseEl, {
        toggle: false
      });

      var expectEnd = function expectEnd() {
        setTimeout(function () {
          expect().nothing();
          done();
        }, 10);
      };

      collapseEl.addEventListener('show.bs.collapse', function (event) {
        event.preventDefault();
        expectEnd();
      });
      collapseEl.addEventListener('shown.bs.collapse', function () {
        throw new Error('should not fire shown event');
      });
      collapse.show();
    });
  });
  describe('hide', function () {
    it('should do nothing if is transitioning', function () {
      fixtureEl.innerHTML = '<div></div>';
      spyOn(_eventHandler["default"], 'trigger');
      var collapseEl = fixtureEl.querySelector('div');
      var collapse = new _collapse["default"](collapseEl, {
        toggle: false
      });
      collapse._isTransitioning = true;
      collapse.hide();
      expect(_eventHandler["default"].trigger).not.toHaveBeenCalled();
    });
    it('should do nothing if already shown', function () {
      fixtureEl.innerHTML = '<div></div>';
      spyOn(_eventHandler["default"], 'trigger');
      var collapseEl = fixtureEl.querySelector('div');
      var collapse = new _collapse["default"](collapseEl, {
        toggle: false
      });
      collapse.hide();
      expect(_eventHandler["default"].trigger).not.toHaveBeenCalled();
    });
    it('should hide a collapsed element', function (done) {
      fixtureEl.innerHTML = '<div class="collapse show"></div>';
      var collapseEl = fixtureEl.querySelector('div');
      var collapse = new _collapse["default"](collapseEl, {
        toggle: false
      });
      collapseEl.addEventListener('hidden.bs.collapse', function () {
        expect(collapseEl.classList.contains('show')).toEqual(false);
        expect(collapseEl.style.height).toEqual('');
        done();
      });
      collapse.hide();
    });
    it('should not fire hidden when hide is prevented', function (done) {
      fixtureEl.innerHTML = '<div class="collapse show"></div>';
      var collapseEl = fixtureEl.querySelector('div');
      var collapse = new _collapse["default"](collapseEl, {
        toggle: false
      });

      var expectEnd = function expectEnd() {
        setTimeout(function () {
          expect().nothing();
          done();
        }, 10);
      };

      collapseEl.addEventListener('hide.bs.collapse', function (event) {
        event.preventDefault();
        expectEnd();
      });
      collapseEl.addEventListener('hidden.bs.collapse', function () {
        throw new Error('should not fire hidden event');
      });
      collapse.hide();
    });
  });
  describe('dispose', function () {
    it('should destroy a collapse', function () {
      fixtureEl.innerHTML = '<div class="collapse show"></div>';
      var collapseEl = fixtureEl.querySelector('div');
      var collapse = new _collapse["default"](collapseEl, {
        toggle: false
      });
      expect(_collapse["default"].getInstance(collapseEl)).toEqual(collapse);
      collapse.dispose();
      expect(_collapse["default"].getInstance(collapseEl)).toEqual(null);
    });
  });
  describe('data-api', function () {
    it('should prevent url change if click on nested elements', function (done) {
      fixtureEl.innerHTML = ['<a role="button" data-bs-toggle="collapse" class="collapsed" href="#collapse">', '  <span id="nested"></span>', '</a>', '<div id="collapse" class="collapse"></div>'].join('');
      var triggerEl = fixtureEl.querySelector('a');
      var nestedTriggerEl = fixtureEl.querySelector('#nested');
      spyOn(Event.prototype, 'preventDefault').and.callThrough();
      triggerEl.addEventListener('click', function (event) {
        expect(event.target.isEqualNode(nestedTriggerEl)).toEqual(true);
        expect(event.delegateTarget.isEqualNode(triggerEl)).toEqual(true);
        expect(Event.prototype.preventDefault).toHaveBeenCalled();
        done();
      });
      nestedTriggerEl.click();
    });
    it('should show multiple collapsed elements', function (done) {
      fixtureEl.innerHTML = ['<a role="button" data-bs-toggle="collapse" class="collapsed" href=".multi"></a>', '<div id="collapse1" class="collapse multi"></div>', '<div id="collapse2" class="collapse multi"></div>'].join('');
      var trigger = fixtureEl.querySelector('a');
      var collapse1 = fixtureEl.querySelector('#collapse1');
      var collapse2 = fixtureEl.querySelector('#collapse2');
      collapse2.addEventListener('shown.bs.collapse', function () {
        expect(trigger.getAttribute('aria-expanded')).toEqual('true');
        expect(trigger.classList.contains('collapsed')).toEqual(false);
        expect(collapse1.classList.contains('show')).toEqual(true);
        expect(collapse1.classList.contains('show')).toEqual(true);
        done();
      });
      trigger.click();
    });
    it('should hide multiple collapsed elements', function (done) {
      fixtureEl.innerHTML = ['<a role="button" data-bs-toggle="collapse" href=".multi"></a>', '<div id="collapse1" class="collapse multi show"></div>', '<div id="collapse2" class="collapse multi show"></div>'].join('');
      var trigger = fixtureEl.querySelector('a');
      var collapse1 = fixtureEl.querySelector('#collapse1');
      var collapse2 = fixtureEl.querySelector('#collapse2');
      collapse2.addEventListener('hidden.bs.collapse', function () {
        expect(trigger.getAttribute('aria-expanded')).toEqual('false');
        expect(trigger.classList.contains('collapsed')).toEqual(true);
        expect(collapse1.classList.contains('show')).toEqual(false);
        expect(collapse1.classList.contains('show')).toEqual(false);
        done();
      });
      trigger.click();
    });
    it('should remove "collapsed" class from target when collapse is shown', function (done) {
      fixtureEl.innerHTML = ['<a id="link1" role="button" data-bs-toggle="collapse" class="collapsed" href="#" data-bs-target="#test1"></a>', '<a id="link2" role="button" data-bs-toggle="collapse" class="collapsed" href="#" data-bs-target="#test1"></a>', '<div id="test1"></div>'].join('');
      var link1 = fixtureEl.querySelector('#link1');
      var link2 = fixtureEl.querySelector('#link2');
      var collapseTest1 = fixtureEl.querySelector('#test1');
      collapseTest1.addEventListener('shown.bs.collapse', function () {
        expect(link1.getAttribute('aria-expanded')).toEqual('true');
        expect(link2.getAttribute('aria-expanded')).toEqual('true');
        expect(link1.classList.contains('collapsed')).toEqual(false);
        expect(link2.classList.contains('collapsed')).toEqual(false);
        done();
      });
      link1.click();
    });
    it('should add "collapsed" class to target when collapse is hidden', function (done) {
      fixtureEl.innerHTML = ['<a id="link1" role="button" data-bs-toggle="collapse" href="#" data-bs-target="#test1"></a>', '<a id="link2" role="button" data-bs-toggle="collapse" href="#" data-bs-target="#test1"></a>', '<div id="test1" class="show"></div>'].join('');
      var link1 = fixtureEl.querySelector('#link1');
      var link2 = fixtureEl.querySelector('#link2');
      var collapseTest1 = fixtureEl.querySelector('#test1');
      collapseTest1.addEventListener('hidden.bs.collapse', function () {
        expect(link1.getAttribute('aria-expanded')).toEqual('false');
        expect(link2.getAttribute('aria-expanded')).toEqual('false');
        expect(link1.classList.contains('collapsed')).toEqual(true);
        expect(link2.classList.contains('collapsed')).toEqual(true);
        done();
      });
      link1.click();
    });
    it('should allow accordion to use children other than card', function (done) {
      fixtureEl.innerHTML = ['<div id="accordion">', '  <div class="item">', '    <a id="linkTrigger" data-bs-toggle="collapse" href="#collapseOne" aria-expanded="false" aria-controls="collapseOne"></a>', '    <div id="collapseOne" class="collapse" role="tabpanel" aria-labelledby="headingThree" data-bs-parent="#accordion"></div>', '  </div>', '  <div class="item">', '    <a id="linkTriggerTwo" data-bs-toggle="collapse" href="#collapseTwo" aria-expanded="false" aria-controls="collapseTwo"></a>', '    <div id="collapseTwo" class="collapse show" role="tabpanel" aria-labelledby="headingTwo" data-bs-parent="#accordion"></div>', '  </div>', '</div>'].join('');
      var trigger = fixtureEl.querySelector('#linkTrigger');
      var triggerTwo = fixtureEl.querySelector('#linkTriggerTwo');
      var collapseOne = fixtureEl.querySelector('#collapseOne');
      var collapseTwo = fixtureEl.querySelector('#collapseTwo');
      collapseOne.addEventListener('shown.bs.collapse', function () {
        expect(collapseOne.classList.contains('show')).toEqual(true);
        expect(collapseTwo.classList.contains('show')).toEqual(false);
        collapseTwo.addEventListener('shown.bs.collapse', function () {
          expect(collapseOne.classList.contains('show')).toEqual(false);
          expect(collapseTwo.classList.contains('show')).toEqual(true);
          done();
        });
        triggerTwo.click();
      });
      trigger.click();
    });
    it('should not prevent event for input', function (done) {
      fixtureEl.innerHTML = ['<input type="checkbox" data-bs-toggle="collapse" data-bs-target="#collapsediv1">', '<div id="collapsediv1"></div>'].join('');
      var target = fixtureEl.querySelector('input');
      var collapseEl = fixtureEl.querySelector('#collapsediv1');
      collapseEl.addEventListener('shown.bs.collapse', function () {
        expect(collapseEl.classList.contains('show')).toEqual(true);
        expect(target.checked).toEqual(true);
        done();
      });
      target.click();
    });
    it('should allow accordion to contain nested elements', function (done) {
      fixtureEl.innerHTML = ['<div id="accordion">', '  <div class="row">', '    <div class="col-lg-6">', '      <div class="item">', '        <a id="linkTrigger" data-bs-toggle="collapse" href="#collapseOne" aria-expanded="false" aria-controls="collapseOne"></a>', '        <div id="collapseOne" class="collapse" role="tabpanel" aria-labelledby="headingThree" data-bs-parent="#accordion"></div>', '      </div>', '    </div>', '    <div class="col-lg-6">', '      <div class="item">', '        <a id="linkTriggerTwo" data-bs-toggle="collapse" href="#collapseTwo" aria-expanded="false" aria-controls="collapseTwo"></a>', '        <div id="collapseTwo" class="collapse show" role="tabpanel" aria-labelledby="headingTwo" data-bs-parent="#accordion"></div>', '      </div>', '    </div>', '  </div>', '</div>'].join('');
      var triggerEl = fixtureEl.querySelector('#linkTrigger');
      var triggerTwoEl = fixtureEl.querySelector('#linkTriggerTwo');
      var collapseOneEl = fixtureEl.querySelector('#collapseOne');
      var collapseTwoEl = fixtureEl.querySelector('#collapseTwo');
      collapseOneEl.addEventListener('shown.bs.collapse', function () {
        expect(collapseOneEl.classList.contains('show')).toEqual(true);
        expect(triggerEl.classList.contains('collapsed')).toEqual(false);
        expect(triggerEl.getAttribute('aria-expanded')).toEqual('true');
        expect(collapseTwoEl.classList.contains('show')).toEqual(false);
        expect(triggerTwoEl.classList.contains('collapsed')).toEqual(true);
        expect(triggerTwoEl.getAttribute('aria-expanded')).toEqual('false');
        collapseTwoEl.addEventListener('shown.bs.collapse', function () {
          expect(collapseOneEl.classList.contains('show')).toEqual(false);
          expect(triggerEl.classList.contains('collapsed')).toEqual(true);
          expect(triggerEl.getAttribute('aria-expanded')).toEqual('false');
          expect(collapseTwoEl.classList.contains('show')).toEqual(true);
          expect(triggerTwoEl.classList.contains('collapsed')).toEqual(false);
          expect(triggerTwoEl.getAttribute('aria-expanded')).toEqual('true');
          done();
        });
        triggerTwoEl.click();
      });
      triggerEl.click();
    });
    it('should allow accordion to target multiple elements', function (done) {
      fixtureEl.innerHTML = ['<div id="accordion">', '  <a id="linkTriggerOne" data-bs-toggle="collapse" data-bs-target=".collapseOne" href="#" aria-expanded="false" aria-controls="collapseOne"></a>', '  <a id="linkTriggerTwo" data-bs-toggle="collapse" data-bs-target=".collapseTwo" href="#" aria-expanded="false" aria-controls="collapseTwo"></a>', '  <div id="collapseOneOne" class="collapse collapseOne" role="tabpanel" data-bs-parent="#accordion"></div>', '  <div id="collapseOneTwo" class="collapse collapseOne" role="tabpanel" data-bs-parent="#accordion"></div>', '  <div id="collapseTwoOne" class="collapse collapseTwo" role="tabpanel" data-bs-parent="#accordion"></div>', '  <div id="collapseTwoTwo" class="collapse collapseTwo" role="tabpanel" data-bs-parent="#accordion"></div>', '</div>'].join('');
      var trigger = fixtureEl.querySelector('#linkTriggerOne');
      var triggerTwo = fixtureEl.querySelector('#linkTriggerTwo');
      var collapseOneOne = fixtureEl.querySelector('#collapseOneOne');
      var collapseOneTwo = fixtureEl.querySelector('#collapseOneTwo');
      var collapseTwoOne = fixtureEl.querySelector('#collapseTwoOne');
      var collapseTwoTwo = fixtureEl.querySelector('#collapseTwoTwo');
      var collapsedElements = {
        one: false,
        two: false
      };

      function firstTest() {
        expect(collapseOneOne.classList.contains('show')).toEqual(true);
        expect(collapseOneTwo.classList.contains('show')).toEqual(true);
        expect(collapseTwoOne.classList.contains('show')).toEqual(false);
        expect(collapseTwoTwo.classList.contains('show')).toEqual(false);
        triggerTwo.click();
      }

      function secondTest() {
        expect(collapseOneOne.classList.contains('show')).toEqual(false);
        expect(collapseOneTwo.classList.contains('show')).toEqual(false);
        expect(collapseTwoOne.classList.contains('show')).toEqual(true);
        expect(collapseTwoTwo.classList.contains('show')).toEqual(true);
        done();
      }

      collapseOneOne.addEventListener('shown.bs.collapse', function () {
        if (collapsedElements.one) {
          firstTest();
        } else {
          collapsedElements.one = true;
        }
      });
      collapseOneTwo.addEventListener('shown.bs.collapse', function () {
        if (collapsedElements.one) {
          firstTest();
        } else {
          collapsedElements.one = true;
        }
      });
      collapseTwoOne.addEventListener('shown.bs.collapse', function () {
        if (collapsedElements.two) {
          secondTest();
        } else {
          collapsedElements.two = true;
        }
      });
      collapseTwoTwo.addEventListener('shown.bs.collapse', function () {
        if (collapsedElements.two) {
          secondTest();
        } else {
          collapsedElements.two = true;
        }
      });
      trigger.click();
    });
    it('should collapse accordion children but not nested accordion children', function (done) {
      fixtureEl.innerHTML = ['<div id="accordion">', '  <div class="item">', '    <a id="linkTrigger" data-bs-toggle="collapse" href="#collapseOne" aria-expanded="false" aria-controls="collapseOne"></a>', '    <div id="collapseOne" data-bs-parent="#accordion" class="collapse" role="tabpanel" aria-labelledby="headingThree">', '      <div id="nestedAccordion">', '        <div class="item">', '          <a id="nestedLinkTrigger" data-bs-toggle="collapse" href="#nestedCollapseOne" aria-expanded="false" aria-controls="nestedCollapseOne"></a>', '          <div id="nestedCollapseOne" data-bs-parent="#nestedAccordion" class="collapse" role="tabpanel" aria-labelledby="headingThree"></div>', '        </div>', '      </div>', '    </div>', '  </div>', '  <div class="item">', '    <a id="linkTriggerTwo" data-bs-toggle="collapse" href="#collapseTwo" aria-expanded="false" aria-controls="collapseTwo"></a>', '    <div id="collapseTwo" data-bs-parent="#accordion" class="collapse show" role="tabpanel" aria-labelledby="headingTwo"></div>', '  </div>', '</div>'].join('');
      var trigger = fixtureEl.querySelector('#linkTrigger');
      var triggerTwo = fixtureEl.querySelector('#linkTriggerTwo');
      var nestedTrigger = fixtureEl.querySelector('#nestedLinkTrigger');
      var collapseOne = fixtureEl.querySelector('#collapseOne');
      var collapseTwo = fixtureEl.querySelector('#collapseTwo');
      var nestedCollapseOne = fixtureEl.querySelector('#nestedCollapseOne');

      function handlerCollapseOne() {
        expect(collapseOne.classList.contains('show')).toEqual(true);
        expect(collapseTwo.classList.contains('show')).toEqual(false);
        expect(nestedCollapseOne.classList.contains('show')).toEqual(false);
        nestedCollapseOne.addEventListener('shown.bs.collapse', handlerNestedCollapseOne);
        nestedTrigger.click();
        collapseOne.removeEventListener('shown.bs.collapse', handlerCollapseOne);
      }

      function handlerNestedCollapseOne() {
        expect(collapseOne.classList.contains('show')).toEqual(true);
        expect(collapseTwo.classList.contains('show')).toEqual(false);
        expect(nestedCollapseOne.classList.contains('show')).toEqual(true);
        collapseTwo.addEventListener('shown.bs.collapse', function () {
          expect(collapseOne.classList.contains('show')).toEqual(false);
          expect(collapseTwo.classList.contains('show')).toEqual(true);
          expect(nestedCollapseOne.classList.contains('show')).toEqual(true);
          done();
        });
        triggerTwo.click();
        nestedCollapseOne.removeEventListener('shown.bs.collapse', handlerNestedCollapseOne);
      }

      collapseOne.addEventListener('shown.bs.collapse', handlerCollapseOne);
      trigger.click();
    });
    it('should add "collapsed" class and set aria-expanded to triggers only when all the targeted collapse are hidden', function (done) {
      fixtureEl.innerHTML = ['<a id="trigger1" role="button" data-bs-toggle="collapse" href="#test1"></a>', '<a id="trigger2" role="button" data-bs-toggle="collapse" href="#test2"></a>', '<a id="trigger3" role="button" data-bs-toggle="collapse" href=".multi"></a>', '<div id="test1" class="multi"></div>', '<div id="test2" class="multi"></div>'].join('');
      var trigger1 = fixtureEl.querySelector('#trigger1');
      var trigger2 = fixtureEl.querySelector('#trigger2');
      var trigger3 = fixtureEl.querySelector('#trigger3');
      var target1 = fixtureEl.querySelector('#test1');
      var target2 = fixtureEl.querySelector('#test2');

      var target2Shown = function target2Shown() {
        expect(trigger1.classList.contains('collapsed')).toEqual(false);
        expect(trigger1.getAttribute('aria-expanded')).toEqual('true');
        expect(trigger2.classList.contains('collapsed')).toEqual(false);
        expect(trigger2.getAttribute('aria-expanded')).toEqual('true');
        expect(trigger3.classList.contains('collapsed')).toEqual(false);
        expect(trigger3.getAttribute('aria-expanded')).toEqual('true');
        target2.addEventListener('hidden.bs.collapse', function () {
          expect(trigger1.classList.contains('collapsed')).toEqual(false);
          expect(trigger1.getAttribute('aria-expanded')).toEqual('true');
          expect(trigger2.classList.contains('collapsed')).toEqual(true);
          expect(trigger2.getAttribute('aria-expanded')).toEqual('false');
          expect(trigger3.classList.contains('collapsed')).toEqual(false);
          expect(trigger3.getAttribute('aria-expanded')).toEqual('true');
          target1.addEventListener('hidden.bs.collapse', function () {
            expect(trigger1.classList.contains('collapsed')).toEqual(true);
            expect(trigger1.getAttribute('aria-expanded')).toEqual('false');
            expect(trigger2.classList.contains('collapsed')).toEqual(true);
            expect(trigger2.getAttribute('aria-expanded')).toEqual('false');
            expect(trigger3.classList.contains('collapsed')).toEqual(true);
            expect(trigger3.getAttribute('aria-expanded')).toEqual('false');
            done();
          });
          trigger1.click();
        });
        trigger2.click();
      };

      target2.addEventListener('shown.bs.collapse', target2Shown);
      trigger3.click();
    });
  });
  describe('jQueryInterface', function () {
    it('should create a collapse', function () {
      fixtureEl.innerHTML = '<div></div>';
      var div = fixtureEl.querySelector('div');
      _fixture.jQueryMock.fn.collapse = _collapse["default"].jQueryInterface;
      _fixture.jQueryMock.elements = [div];

      _fixture.jQueryMock.fn.collapse.call(_fixture.jQueryMock);

      expect(_collapse["default"].getInstance(div)).not.toBeNull();
    });
    it('should not re create a collapse', function () {
      fixtureEl.innerHTML = '<div></div>';
      var div = fixtureEl.querySelector('div');
      var collapse = new _collapse["default"](div);
      _fixture.jQueryMock.fn.collapse = _collapse["default"].jQueryInterface;
      _fixture.jQueryMock.elements = [div];

      _fixture.jQueryMock.fn.collapse.call(_fixture.jQueryMock);

      expect(_collapse["default"].getInstance(div)).toEqual(collapse);
    });
    it('should throw error on undefined method', function () {
      fixtureEl.innerHTML = '<div></div>';
      var div = fixtureEl.querySelector('div');
      var action = 'undefinedMethod';
      _fixture.jQueryMock.fn.collapse = _collapse["default"].jQueryInterface;
      _fixture.jQueryMock.elements = [div];
      expect(function () {
        _fixture.jQueryMock.fn.collapse.call(_fixture.jQueryMock, action);
      }).toThrowError(TypeError, "No method named \"".concat(action, "\""));
    });
  });
  describe('getInstance', function () {
    it('should return collapse instance', function () {
      fixtureEl.innerHTML = '<div></div>';
      var div = fixtureEl.querySelector('div');
      var collapse = new _collapse["default"](div);
      expect(_collapse["default"].getInstance(div)).toEqual(collapse);
      expect(_collapse["default"].getInstance(div)).toBeInstanceOf(_collapse["default"]);
    });
    it('should return null when there is no collapse instance', function () {
      fixtureEl.innerHTML = '<div></div>';
      var div = fixtureEl.querySelector('div');
      expect(_collapse["default"].getInstance(div)).toEqual(null);
    });
  });
  describe('getOrCreateInstance', function () {
    it('should return collapse instance', function () {
      fixtureEl.innerHTML = '<div></div>';
      var div = fixtureEl.querySelector('div');
      var collapse = new _collapse["default"](div);
      expect(_collapse["default"].getOrCreateInstance(div)).toEqual(collapse);
      expect(_collapse["default"].getInstance(div)).toEqual(_collapse["default"].getOrCreateInstance(div, {}));
      expect(_collapse["default"].getOrCreateInstance(div)).toBeInstanceOf(_collapse["default"]);
    });
    it('should return new instance when there is no collapse instance', function () {
      fixtureEl.innerHTML = '<div></div>';
      var div = fixtureEl.querySelector('div');
      expect(_collapse["default"].getInstance(div)).toEqual(null);
      expect(_collapse["default"].getOrCreateInstance(div)).toBeInstanceOf(_collapse["default"]);
    });
    it('should return new instance when there is no collapse instance with given configuration', function () {
      fixtureEl.innerHTML = '<div></div>';
      var div = fixtureEl.querySelector('div');
      expect(_collapse["default"].getInstance(div)).toEqual(null);

      var collapse = _collapse["default"].getOrCreateInstance(div, {
        toggle: false
      });

      expect(collapse).toBeInstanceOf(_collapse["default"]);
      expect(collapse._config.toggle).toEqual(false);
    });
    it('should return the instance when exists without given configuration', function () {
      fixtureEl.innerHTML = '<div></div>';
      var div = fixtureEl.querySelector('div');
      var collapse = new _collapse["default"](div, {
        toggle: false
      });
      expect(_collapse["default"].getInstance(div)).toEqual(collapse);

      var collapse2 = _collapse["default"].getOrCreateInstance(div, {
        toggle: true
      });

      expect(collapse).toBeInstanceOf(_collapse["default"]);
      expect(collapse2).toEqual(collapse);
      expect(collapse2._config.toggle).toEqual(false);
    });
  });
});
"use strict";

var _dropdown = _interopRequireDefault(require("../../src/dropdown"));

var _eventHandler = _interopRequireDefault(require("../../src/dom/event-handler"));

var _util = require("../../src/util");

var _fixture = require("../helpers/fixture");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

describe('Dropdown', function () {
  var fixtureEl;
  beforeAll(function () {
    fixtureEl = (0, _fixture.getFixture)();
  });
  afterEach(function () {
    (0, _fixture.clearFixture)();
  });
  describe('VERSION', function () {
    it('should return plugin version', function () {
      expect(_dropdown["default"].VERSION).toEqual(jasmine.any(String));
    });
  });
  describe('Default', function () {
    it('should return plugin default config', function () {
      expect(_dropdown["default"].Default).toEqual(jasmine.any(Object));
    });
  });
  describe('DefaultType', function () {
    it('should return plugin default type config', function () {
      expect(_dropdown["default"].DefaultType).toEqual(jasmine.any(Object));
    });
  });
  describe('DATA_KEY', function () {
    it('should return plugin data key', function () {
      expect(_dropdown["default"].DATA_KEY).toEqual('bs.dropdown');
    });
  });
  describe('constructor', function () {
    it('should take care of element either passed as a CSS selector or DOM element', function () {
      fixtureEl.innerHTML = ['<div class="dropdown">', '  <button class="btn dropdown-toggle" data-bs-toggle="dropdown">Dropdown</button>', '  <div class="dropdown-menu">', '    <a class="dropdown-item" href="#">Link</a>', '  </div>', '</div>'].join('');
      var btnDropdown = fixtureEl.querySelector('[data-bs-toggle="dropdown"]');
      var dropdownBySelector = new _dropdown["default"]('[data-bs-toggle="dropdown"]');
      var dropdownByElement = new _dropdown["default"](btnDropdown);
      expect(dropdownBySelector._element).toEqual(btnDropdown);
      expect(dropdownByElement._element).toEqual(btnDropdown);
    });
    it('should create offset modifier correctly when offset option is a function', function (done) {
      fixtureEl.innerHTML = ['<div class="dropdown">', '  <button class="btn dropdown-toggle" data-bs-toggle="dropdown">Dropdown</button>', '  <div class="dropdown-menu">', '    <a class="dropdown-item" href="#">Secondary link</a>', '  </div>', '</div>'].join('');
      var getOffset = jasmine.createSpy('getOffset').and.returnValue([10, 20]);
      var btnDropdown = fixtureEl.querySelector('[data-bs-toggle="dropdown"]');
      var dropdown = new _dropdown["default"](btnDropdown, {
        offset: getOffset,
        popperConfig: {
          onFirstUpdate: function onFirstUpdate(state) {
            expect(getOffset).toHaveBeenCalledWith({
              popper: state.rects.popper,
              reference: state.rects.reference,
              placement: state.placement
            }, btnDropdown);
            done();
          }
        }
      });

      var offset = dropdown._getOffset();

      expect(_typeof(offset)).toEqual('function');
      dropdown.show();
    });
    it('should create offset modifier correctly when offset option is a string into data attribute', function () {
      fixtureEl.innerHTML = ['<div class="dropdown">', '  <button class="btn dropdown-toggle" data-bs-toggle="dropdown" data-bs-offset="10,20">Dropdown</button>', '  <div class="dropdown-menu">', '    <a class="dropdown-item" href="#">Secondary link</a>', '  </div>', '</div>'].join('');
      var btnDropdown = fixtureEl.querySelector('[data-bs-toggle="dropdown"]');
      var dropdown = new _dropdown["default"](btnDropdown);
      expect(dropdown._getOffset()).toEqual([10, 20]);
    });
    it('should allow to pass config to Popper with `popperConfig`', function () {
      fixtureEl.innerHTML = ['<div class="dropdown">', '  <button class="btn dropdown-toggle" data-bs-toggle="dropdown">Dropdown</button>', '  <div class="dropdown-menu">', '    <a class="dropdown-item" href="#">Secondary link</a>', '  </div>', '</div>'].join('');
      var btnDropdown = fixtureEl.querySelector('[data-bs-toggle="dropdown"]');
      var dropdown = new _dropdown["default"](btnDropdown, {
        popperConfig: {
          placement: 'left'
        }
      });

      var popperConfig = dropdown._getPopperConfig();

      expect(popperConfig.placement).toEqual('left');
    });
    it('should allow to pass config to Popper with `popperConfig` as a function', function () {
      fixtureEl.innerHTML = ['<div class="dropdown">', '  <button class="btn dropdown-toggle" data-bs-toggle="dropdown" data-bs-placement="right" >Dropdown</button>', '  <div class="dropdown-menu">', '    <a class="dropdown-item" href="#">Secondary link</a>', '  </div>', '</div>'].join('');
      var btnDropdown = fixtureEl.querySelector('[data-bs-toggle="dropdown"]');
      var getPopperConfig = jasmine.createSpy('getPopperConfig').and.returnValue({
        placement: 'left'
      });
      var dropdown = new _dropdown["default"](btnDropdown, {
        popperConfig: getPopperConfig
      });

      var popperConfig = dropdown._getPopperConfig();

      expect(getPopperConfig).toHaveBeenCalled();
      expect(popperConfig.placement).toEqual('left');
    });
  });
  describe('toggle', function () {
    it('should toggle a dropdown', function (done) {
      fixtureEl.innerHTML = ['<div class="dropdown">', '  <button class="btn dropdown-toggle" data-bs-toggle="dropdown" aria-expanded="false">Dropdown</button>', '  <div class="dropdown-menu">', '    <a class="dropdown-item" href="#">Secondary link</a>', '  </div>', '</div>'].join('');
      var btnDropdown = fixtureEl.querySelector('[data-bs-toggle="dropdown"]');
      var dropdown = new _dropdown["default"](btnDropdown);
      btnDropdown.addEventListener('shown.bs.dropdown', function () {
        expect(btnDropdown.classList.contains('show')).toEqual(true);
        expect(btnDropdown.getAttribute('aria-expanded')).toEqual('true');
        done();
      });
      dropdown.toggle();
    });
    it('should destroy old popper references on toggle', function (done) {
      fixtureEl.innerHTML = ['<div class="first dropdown">', '  <button class="firstBtn btn" data-bs-toggle="dropdown" aria-expanded="false">Dropdown</button>', '  <div class="dropdown-menu">', '    <a class="dropdown-item" href="#">Secondary link</a>', '  </div>', '</div>', '<div class="second dropdown">', '  <button class="secondBtn btn" data-bs-toggle="dropdown" aria-expanded="false">Dropdown</button>', '  <div class="dropdown-menu">', '    <a class="dropdown-item" href="#">Secondary link</a>', '  </div>', '</div>'].join('');
      var btnDropdown1 = fixtureEl.querySelector('.firstBtn');
      var btnDropdown2 = fixtureEl.querySelector('.secondBtn');
      var firstDropdownEl = fixtureEl.querySelector('.first');
      var secondDropdownEl = fixtureEl.querySelector('.second');
      var dropdown1 = new _dropdown["default"](btnDropdown1);
      firstDropdownEl.addEventListener('shown.bs.dropdown', function () {
        expect(btnDropdown1.classList.contains('show')).toEqual(true);
        spyOn(dropdown1._popper, 'destroy');
        btnDropdown2.click();
      });
      secondDropdownEl.addEventListener('shown.bs.dropdown', function () {
        return setTimeout(function () {
          expect(dropdown1._popper.destroy).toHaveBeenCalled();
          done();
        });
      });
      dropdown1.toggle();
    });
    it('should toggle a dropdown and add/remove event listener on mobile', function (done) {
      fixtureEl.innerHTML = ['<div class="dropdown">', '  <button class="btn dropdown-toggle" data-bs-toggle="dropdown" aria-expanded="false">Dropdown</button>', '  <div class="dropdown-menu">', '    <a class="dropdown-item" href="#">Secondary link</a>', '  </div>', '</div>'].join('');
      var defaultValueOnTouchStart = document.documentElement.ontouchstart;
      var btnDropdown = fixtureEl.querySelector('[data-bs-toggle="dropdown"]');
      var dropdown = new _dropdown["default"](btnDropdown);

      document.documentElement.ontouchstart = function () {};

      spyOn(_eventHandler["default"], 'on');
      spyOn(_eventHandler["default"], 'off');
      btnDropdown.addEventListener('shown.bs.dropdown', function () {
        expect(btnDropdown.classList.contains('show')).toEqual(true);
        expect(btnDropdown.getAttribute('aria-expanded')).toEqual('true');
        expect(_eventHandler["default"].on).toHaveBeenCalledWith(jasmine.any(Object), 'mouseover', _util.noop);
        dropdown.toggle();
      });
      btnDropdown.addEventListener('hidden.bs.dropdown', function () {
        expect(btnDropdown.classList.contains('show')).toEqual(false);
        expect(btnDropdown.getAttribute('aria-expanded')).toEqual('false');
        expect(_eventHandler["default"].off).toHaveBeenCalledWith(jasmine.any(Object), 'mouseover', _util.noop);
        document.documentElement.ontouchstart = defaultValueOnTouchStart;
        done();
      });
      dropdown.toggle();
    });
    it('should toggle a dropdown at the right', function (done) {
      fixtureEl.innerHTML = ['<div class="dropdown">', '  <button class="btn dropdown-toggle" data-bs-toggle="dropdown" aria-expanded="false">Dropdown</button>', '  <div class="dropdown-menu dropdown-menu-end">', '    <a class="dropdown-item" href="#">Secondary link</a>', '  </div>', '</div>'].join('');
      var btnDropdown = fixtureEl.querySelector('[data-bs-toggle="dropdown"]');
      var dropdown = new _dropdown["default"](btnDropdown);
      btnDropdown.addEventListener('shown.bs.dropdown', function () {
        expect(btnDropdown.classList.contains('show')).toEqual(true);
        expect(btnDropdown.getAttribute('aria-expanded')).toEqual('true');
        done();
      });
      dropdown.toggle();
    });
    it('should toggle a dropup', function (done) {
      fixtureEl.innerHTML = ['<div class="dropup">', '  <button class="btn dropdown-toggle" data-bs-toggle="dropdown" aria-expanded="false">Dropdown</button>', '  <div class="dropdown-menu">', '    <a class="dropdown-item" href="#">Secondary link</a>', '  </div>', '</div>'].join('');
      var btnDropdown = fixtureEl.querySelector('[data-bs-toggle="dropdown"]');
      var dropupEl = fixtureEl.querySelector('.dropup');
      var dropdown = new _dropdown["default"](btnDropdown);
      dropupEl.addEventListener('shown.bs.dropdown', function () {
        expect(btnDropdown.classList.contains('show')).toEqual(true);
        expect(btnDropdown.getAttribute('aria-expanded')).toEqual('true');
        done();
      });
      dropdown.toggle();
    });
    it('should toggle a dropup at the right', function (done) {
      fixtureEl.innerHTML = ['<div class="dropup">', '  <button class="btn dropdown-toggle" data-bs-toggle="dropdown" aria-expanded="false">Dropdown</button>', '  <div class="dropdown-menu dropdown-menu-end">', '    <a class="dropdown-item" href="#">Secondary link</a>', '  </div>', '</div>'].join('');
      var btnDropdown = fixtureEl.querySelector('[data-bs-toggle="dropdown"]');
      var dropupEl = fixtureEl.querySelector('.dropup');
      var dropdown = new _dropdown["default"](btnDropdown);
      dropupEl.addEventListener('shown.bs.dropdown', function () {
        expect(btnDropdown.classList.contains('show')).toEqual(true);
        expect(btnDropdown.getAttribute('aria-expanded')).toEqual('true');
        done();
      });
      dropdown.toggle();
    });
    it('should toggle a dropend', function (done) {
      fixtureEl.innerHTML = ['<div class="dropend">', '  <button class="btn dropdown-toggle" data-bs-toggle="dropdown" aria-expanded="false">Dropdown</button>', '  <div class="dropdown-menu">', '    <a class="dropdown-item" href="#">Secondary link</a>', '  </div>', '</div>'].join('');
      var btnDropdown = fixtureEl.querySelector('[data-bs-toggle="dropdown"]');
      var dropendEl = fixtureEl.querySelector('.dropend');
      var dropdown = new _dropdown["default"](btnDropdown);
      dropendEl.addEventListener('shown.bs.dropdown', function () {
        expect(btnDropdown.classList.contains('show')).toEqual(true);
        expect(btnDropdown.getAttribute('aria-expanded')).toEqual('true');
        done();
      });
      dropdown.toggle();
    });
    it('should toggle a dropstart', function (done) {
      fixtureEl.innerHTML = ['<div class="dropstart">', '  <button class="btn dropdown-toggle" data-bs-toggle="dropdown" aria-expanded="false">Dropdown</button>', '  <div class="dropdown-menu">', '    <a class="dropdown-item" href="#">Secondary link</a>', '  </div>', '</div>'].join('');
      var btnDropdown = fixtureEl.querySelector('[data-bs-toggle="dropdown"]');
      var dropstartEl = fixtureEl.querySelector('.dropstart');
      var dropdown = new _dropdown["default"](btnDropdown);
      dropstartEl.addEventListener('shown.bs.dropdown', function () {
        expect(btnDropdown.classList.contains('show')).toEqual(true);
        expect(btnDropdown.getAttribute('aria-expanded')).toEqual('true');
        done();
      });
      dropdown.toggle();
    });
    it('should toggle a dropdown with parent reference', function (done) {
      fixtureEl.innerHTML = ['<div class="dropdown">', '  <button class="btn dropdown-toggle" data-bs-toggle="dropdown" aria-expanded="false">Dropdown</button>', '  <div class="dropdown-menu">', '    <a class="dropdown-item" href="#">Secondary link</a>', '  </div>', '</div>'].join('');
      var btnDropdown = fixtureEl.querySelector('[data-bs-toggle="dropdown"]');
      var dropdown = new _dropdown["default"](btnDropdown, {
        reference: 'parent'
      });
      btnDropdown.addEventListener('shown.bs.dropdown', function () {
        expect(btnDropdown.classList.contains('show')).toEqual(true);
        expect(btnDropdown.getAttribute('aria-expanded')).toEqual('true');
        done();
      });
      dropdown.toggle();
    });
    it('should toggle a dropdown with a dom node reference', function (done) {
      fixtureEl.innerHTML = ['<div class="dropdown">', '  <button class="btn dropdown-toggle" data-bs-toggle="dropdown" aria-expanded="false">Dropdown</button>', '  <div class="dropdown-menu">', '    <a class="dropdown-item" href="#">Secondary link</a>', '  </div>', '</div>'].join('');
      var btnDropdown = fixtureEl.querySelector('[data-bs-toggle="dropdown"]');
      var dropdown = new _dropdown["default"](btnDropdown, {
        reference: fixtureEl
      });
      btnDropdown.addEventListener('shown.bs.dropdown', function () {
        expect(btnDropdown.classList.contains('show')).toEqual(true);
        expect(btnDropdown.getAttribute('aria-expanded')).toEqual('true');
        done();
      });
      dropdown.toggle();
    });
    it('should toggle a dropdown with a jquery object reference', function (done) {
      fixtureEl.innerHTML = ['<div class="dropdown">', '  <button class="btn dropdown-toggle" data-bs-toggle="dropdown" aria-expanded="false">Dropdown</button>', '  <div class="dropdown-menu">', '    <a class="dropdown-item" href="#">Secondary link</a>', '  </div>', '</div>'].join('');
      var btnDropdown = fixtureEl.querySelector('[data-bs-toggle="dropdown"]');
      var dropdown = new _dropdown["default"](btnDropdown, {
        reference: {
          0: fixtureEl,
          jquery: 'jQuery'
        }
      });
      btnDropdown.addEventListener('shown.bs.dropdown', function () {
        expect(btnDropdown.classList.contains('show')).toEqual(true);
        expect(btnDropdown.getAttribute('aria-expanded')).toEqual('true');
        done();
      });
      dropdown.toggle();
    });
    it('should toggle a dropdown with a valid virtual element reference', function (done) {
      fixtureEl.innerHTML = ['<div class="dropdown">', '  <button class="btn dropdown-toggle visually-hidden" data-bs-toggle="dropdown" aria-expanded="false">Dropdown</button>', '  <div class="dropdown-menu">', '    <a class="dropdown-item" href="#">Secondary link</a>', '  </div>', '</div>'].join('');
      var btnDropdown = fixtureEl.querySelector('[data-bs-toggle="dropdown"]');
      var virtualElement = {
        nodeType: 1,
        getBoundingClientRect: function getBoundingClientRect() {
          return {
            width: 0,
            height: 0,
            top: 0,
            right: 0,
            bottom: 0,
            left: 0
          };
        }
      };
      expect(function () {
        return new _dropdown["default"](btnDropdown, {
          reference: {}
        });
      }).toThrowError(TypeError, 'DROPDOWN: Option "reference" provided type "object" without a required "getBoundingClientRect" method.');
      expect(function () {
        return new _dropdown["default"](btnDropdown, {
          reference: {
            getBoundingClientRect: 'not-a-function'
          }
        });
      }).toThrowError(TypeError, 'DROPDOWN: Option "reference" provided type "object" without a required "getBoundingClientRect" method.'); // use onFirstUpdate as Poppers internal update is executed async

      var dropdown = new _dropdown["default"](btnDropdown, {
        reference: virtualElement,
        popperConfig: {
          onFirstUpdate: function onFirstUpdate() {
            expect(virtualElement.getBoundingClientRect).toHaveBeenCalled();
            expect(btnDropdown.classList.contains('show')).toEqual(true);
            expect(btnDropdown.getAttribute('aria-expanded')).toEqual('true');
            done();
          }
        }
      });
      spyOn(virtualElement, 'getBoundingClientRect').and.callThrough();
      dropdown.toggle();
    });
    it('should not toggle a dropdown if the element is disabled', function (done) {
      fixtureEl.innerHTML = ['<div class="dropdown">', '  <button disabled class="btn dropdown-toggle" data-bs-toggle="dropdown">Dropdown</button>', '  <div class="dropdown-menu">', '    <a class="dropdown-item" href="#">Secondary link</a>', '  </div>', '</div>'].join('');
      var btnDropdown = fixtureEl.querySelector('[data-bs-toggle="dropdown"]');
      var dropdown = new _dropdown["default"](btnDropdown);
      btnDropdown.addEventListener('shown.bs.dropdown', function () {
        throw new Error('should not throw shown.bs.dropdown event');
      });
      dropdown.toggle();
      setTimeout(function () {
        expect().nothing();
        done();
      });
    });
    it('should not toggle a dropdown if the element contains .disabled', function (done) {
      fixtureEl.innerHTML = ['<div class="dropdown">', '  <button class="btn dropdown-toggle disabled" data-bs-toggle="dropdown">Dropdown</button>', '  <div class="dropdown-menu">', '    <a class="dropdown-item" href="#">Secondary link</a>', '  </div>', '</div>'].join('');
      var btnDropdown = fixtureEl.querySelector('[data-bs-toggle="dropdown"]');
      var dropdown = new _dropdown["default"](btnDropdown);
      btnDropdown.addEventListener('shown.bs.dropdown', function () {
        throw new Error('should not throw shown.bs.dropdown event');
      });
      dropdown.toggle();
      setTimeout(function () {
        expect().nothing();
        done();
      });
    });
    it('should not toggle a dropdown if the menu is shown', function (done) {
      fixtureEl.innerHTML = ['<div class="dropdown">', '  <button class="btn dropdown-toggle" data-bs-toggle="dropdown">Dropdown</button>', '  <div class="dropdown-menu show">', '    <a class="dropdown-item" href="#">Secondary link</a>', '  </div>', '</div>'].join('');
      var btnDropdown = fixtureEl.querySelector('[data-bs-toggle="dropdown"]');
      var dropdown = new _dropdown["default"](btnDropdown);
      btnDropdown.addEventListener('shown.bs.dropdown', function () {
        throw new Error('should not throw shown.bs.dropdown event');
      });
      dropdown.toggle();
      setTimeout(function () {
        expect().nothing();
        done();
      });
    });
    it('should not toggle a dropdown if show event is prevented', function (done) {
      fixtureEl.innerHTML = ['<div class="dropdown">', '  <button class="btn dropdown-toggle" data-bs-toggle="dropdown">Dropdown</button>', '  <div class="dropdown-menu">', '    <a class="dropdown-item" href="#">Secondary link</a>', '  </div>', '</div>'].join('');
      var btnDropdown = fixtureEl.querySelector('[data-bs-toggle="dropdown"]');
      var dropdown = new _dropdown["default"](btnDropdown);
      btnDropdown.addEventListener('show.bs.dropdown', function (event) {
        event.preventDefault();
      });
      btnDropdown.addEventListener('shown.bs.dropdown', function () {
        throw new Error('should not throw shown.bs.dropdown event');
      });
      dropdown.toggle();
      setTimeout(function () {
        expect().nothing();
        done();
      });
    });
  });
  describe('show', function () {
    it('should show a dropdown', function (done) {
      fixtureEl.innerHTML = ['<div class="dropdown">', '  <button class="btn dropdown-toggle" data-bs-toggle="dropdown">Dropdown</button>', '  <div class="dropdown-menu">', '    <a class="dropdown-item" href="#">Secondary link</a>', '  </div>', '</div>'].join('');
      var btnDropdown = fixtureEl.querySelector('[data-bs-toggle="dropdown"]');
      var dropdown = new _dropdown["default"](btnDropdown);
      btnDropdown.addEventListener('shown.bs.dropdown', function () {
        expect(btnDropdown.classList.contains('show')).toEqual(true);
        done();
      });
      dropdown.show();
    });
    it('should not show a dropdown if the element is disabled', function (done) {
      fixtureEl.innerHTML = ['<div class="dropdown">', '  <button disabled class="btn dropdown-toggle" data-bs-toggle="dropdown">Dropdown</button>', '  <div class="dropdown-menu">', '    <a class="dropdown-item" href="#">Secondary link</a>', '  </div>', '</div>'].join('');
      var btnDropdown = fixtureEl.querySelector('[data-bs-toggle="dropdown"]');
      var dropdown = new _dropdown["default"](btnDropdown);
      btnDropdown.addEventListener('shown.bs.dropdown', function () {
        throw new Error('should not throw shown.bs.dropdown event');
      });
      dropdown.show();
      setTimeout(function () {
        expect().nothing();
        done();
      }, 10);
    });
    it('should not show a dropdown if the element contains .disabled', function (done) {
      fixtureEl.innerHTML = ['<div class="dropdown">', '  <button class="btn dropdown-toggle disabled" data-bs-toggle="dropdown">Dropdown</button>', '  <div class="dropdown-menu">', '    <a class="dropdown-item" href="#">Secondary link</a>', '  </div>', '</div>'].join('');
      var btnDropdown = fixtureEl.querySelector('[data-bs-toggle="dropdown"]');
      var dropdown = new _dropdown["default"](btnDropdown);
      btnDropdown.addEventListener('shown.bs.dropdown', function () {
        throw new Error('should not throw shown.bs.dropdown event');
      });
      dropdown.show();
      setTimeout(function () {
        expect().nothing();
        done();
      }, 10);
    });
    it('should not show a dropdown if the menu is shown', function (done) {
      fixtureEl.innerHTML = ['<div class="dropdown">', '  <button class="btn dropdown-toggle" data-bs-toggle="dropdown">Dropdown</button>', '  <div class="dropdown-menu show">', '    <a class="dropdown-item" href="#">Secondary link</a>', '  </div>', '</div>'].join('');
      var btnDropdown = fixtureEl.querySelector('[data-bs-toggle="dropdown"]');
      var dropdown = new _dropdown["default"](btnDropdown);
      btnDropdown.addEventListener('shown.bs.dropdown', function () {
        throw new Error('should not throw shown.bs.dropdown event');
      });
      dropdown.show();
      setTimeout(function () {
        expect().nothing();
        done();
      }, 10);
    });
    it('should not show a dropdown if show event is prevented', function (done) {
      fixtureEl.innerHTML = ['<div class="dropdown">', '  <button class="btn dropdown-toggle" data-bs-toggle="dropdown">Dropdown</button>', '  <div class="dropdown-menu">', '    <a class="dropdown-item" href="#">Secondary link</a>', '  </div>', '</div>'].join('');
      var btnDropdown = fixtureEl.querySelector('[data-bs-toggle="dropdown"]');
      var dropdown = new _dropdown["default"](btnDropdown);
      btnDropdown.addEventListener('show.bs.dropdown', function (event) {
        event.preventDefault();
      });
      btnDropdown.addEventListener('shown.bs.dropdown', function () {
        throw new Error('should not throw shown.bs.dropdown event');
      });
      dropdown.show();
      setTimeout(function () {
        expect().nothing();
        done();
      }, 10);
    });
  });
  describe('hide', function () {
    it('should hide a dropdown', function (done) {
      fixtureEl.innerHTML = ['<div class="dropdown">', '  <button class="btn dropdown-toggle" data-bs-toggle="dropdown" aria-expanded="true">Dropdown</button>', '  <div class="dropdown-menu show">', '    <a class="dropdown-item" href="#">Secondary link</a>', '  </div>', '</div>'].join('');
      var btnDropdown = fixtureEl.querySelector('[data-bs-toggle="dropdown"]');
      var dropdownMenu = fixtureEl.querySelector('.dropdown-menu');
      var dropdown = new _dropdown["default"](btnDropdown);
      btnDropdown.addEventListener('hidden.bs.dropdown', function () {
        expect(dropdownMenu.classList.contains('show')).toEqual(false);
        expect(btnDropdown.getAttribute('aria-expanded')).toEqual('false');
        done();
      });
      dropdown.hide();
    });
    it('should hide a dropdown and destroy popper', function (done) {
      fixtureEl.innerHTML = ['<div class="dropdown">', '  <button class="btn dropdown-toggle" data-bs-toggle="dropdown">Dropdown</button>', '  <div class="dropdown-menu">', '    <a class="dropdown-item" href="#">Secondary link</a>', '  </div>', '</div>'].join('');
      var btnDropdown = fixtureEl.querySelector('[data-bs-toggle="dropdown"]');
      var dropdown = new _dropdown["default"](btnDropdown);
      btnDropdown.addEventListener('shown.bs.dropdown', function () {
        spyOn(dropdown._popper, 'destroy');
        dropdown.hide();
      });
      btnDropdown.addEventListener('hidden.bs.dropdown', function () {
        expect(dropdown._popper.destroy).toHaveBeenCalled();
        done();
      });
      dropdown.show();
    });
    it('should not hide a dropdown if the element is disabled', function (done) {
      fixtureEl.innerHTML = ['<div class="dropdown">', '  <button disabled class="btn dropdown-toggle" data-bs-toggle="dropdown">Dropdown</button>', '  <div class="dropdown-menu show">', '    <a class="dropdown-item" href="#">Secondary link</a>', '  </div>', '</div>'].join('');
      var btnDropdown = fixtureEl.querySelector('[data-bs-toggle="dropdown"]');
      var dropdownMenu = fixtureEl.querySelector('.dropdown-menu');
      var dropdown = new _dropdown["default"](btnDropdown);
      btnDropdown.addEventListener('hidden.bs.dropdown', function () {
        throw new Error('should not throw hidden.bs.dropdown event');
      });
      dropdown.hide();
      setTimeout(function () {
        expect(dropdownMenu.classList.contains('show')).toEqual(true);
        done();
      }, 10);
    });
    it('should not hide a dropdown if the element contains .disabled', function (done) {
      fixtureEl.innerHTML = ['<div class="dropdown">', '  <button class="btn dropdown-toggle disabled" data-bs-toggle="dropdown">Dropdown</button>', '  <div class="dropdown-menu show">', '    <a class="dropdown-item" href="#">Secondary link</a>', '  </div>', '</div>'].join('');
      var btnDropdown = fixtureEl.querySelector('[data-bs-toggle="dropdown"]');
      var dropdownMenu = fixtureEl.querySelector('.dropdown-menu');
      var dropdown = new _dropdown["default"](btnDropdown);
      btnDropdown.addEventListener('hidden.bs.dropdown', function () {
        throw new Error('should not throw hidden.bs.dropdown event');
      });
      dropdown.hide();
      setTimeout(function () {
        expect(dropdownMenu.classList.contains('show')).toEqual(true);
        done();
      }, 10);
    });
    it('should not hide a dropdown if the menu is not shown', function (done) {
      fixtureEl.innerHTML = ['<div class="dropdown">', '  <button class="btn dropdown-toggle" data-bs-toggle="dropdown">Dropdown</button>', '  <div class="dropdown-menu">', '    <a class="dropdown-item" href="#">Secondary link</a>', '  </div>', '</div>'].join('');
      var btnDropdown = fixtureEl.querySelector('[data-bs-toggle="dropdown"]');
      var dropdown = new _dropdown["default"](btnDropdown);
      btnDropdown.addEventListener('hidden.bs.dropdown', function () {
        throw new Error('should not throw hidden.bs.dropdown event');
      });
      dropdown.hide();
      setTimeout(function () {
        expect().nothing();
        done();
      }, 10);
    });
    it('should not hide a dropdown if hide event is prevented', function (done) {
      fixtureEl.innerHTML = ['<div class="dropdown">', '  <button class="btn dropdown-toggle" data-bs-toggle="dropdown">Dropdown</button>', '  <div class="dropdown-menu show">', '    <a class="dropdown-item" href="#">Secondary link</a>', '  </div>', '</div>'].join('');
      var btnDropdown = fixtureEl.querySelector('[data-bs-toggle="dropdown"]');
      var dropdownMenu = fixtureEl.querySelector('.dropdown-menu');
      var dropdown = new _dropdown["default"](btnDropdown);
      btnDropdown.addEventListener('hide.bs.dropdown', function (event) {
        event.preventDefault();
      });
      btnDropdown.addEventListener('hidden.bs.dropdown', function () {
        throw new Error('should not throw hidden.bs.dropdown event');
      });
      dropdown.hide();
      setTimeout(function () {
        expect(dropdownMenu.classList.contains('show')).toEqual(true);
        done();
      });
    });
    it('should remove event listener on touch-enabled device that was added in show method', function (done) {
      fixtureEl.innerHTML = ['<div class="dropdown">', '  <button class="btn dropdown-toggle" data-bs-toggle="dropdown">Dropdown</button>', '  <div class="dropdown-menu">', '    <a class="dropdown-item" href="#">Dropdwon item</a>', '  </div>', '</div>'].join('');
      var defaultValueOnTouchStart = document.documentElement.ontouchstart;
      var btnDropdown = fixtureEl.querySelector('[data-bs-toggle="dropdown"]');
      var dropdown = new _dropdown["default"](btnDropdown);

      document.documentElement.ontouchstart = function () {};

      spyOn(_eventHandler["default"], 'off');
      btnDropdown.addEventListener('shown.bs.dropdown', function () {
        dropdown.hide();
      });
      btnDropdown.addEventListener('hidden.bs.dropdown', function () {
        expect(btnDropdown.classList.contains('show')).toEqual(false);
        expect(btnDropdown.getAttribute('aria-expanded')).toEqual('false');
        expect(_eventHandler["default"].off).toHaveBeenCalled();
        document.documentElement.ontouchstart = defaultValueOnTouchStart;
        done();
      });
      dropdown.show();
    });
  });
  describe('dispose', function () {
    it('should dispose dropdown', function () {
      fixtureEl.innerHTML = ['<div class="dropdown">', '  <button class="btn dropdown-toggle" data-bs-toggle="dropdown">Dropdown</button>', '  <div class="dropdown-menu">', '    <a class="dropdown-item" href="#">Secondary link</a>', '  </div>', '</div>'].join('');
      var btnDropdown = fixtureEl.querySelector('[data-bs-toggle="dropdown"]');
      var dropdown = new _dropdown["default"](btnDropdown);
      expect(dropdown._popper).toBeNull();
      expect(dropdown._menu).not.toBeNull();
      expect(dropdown._element).not.toBeNull();
      spyOn(_eventHandler["default"], 'off');
      dropdown.dispose();
      expect(dropdown._menu).toBeNull();
      expect(dropdown._element).toBeNull();
      expect(_eventHandler["default"].off).toHaveBeenCalledWith(btnDropdown, _dropdown["default"].EVENT_KEY);
    });
    it('should dispose dropdown with Popper', function () {
      fixtureEl.innerHTML = ['<div class="dropdown">', '  <button class="btn dropdown-toggle" data-bs-toggle="dropdown">Dropdown</button>', '  <div class="dropdown-menu">', '    <a class="dropdown-item" href="#">Secondary link</a>', '  </div>', '</div>'].join('');
      var btnDropdown = fixtureEl.querySelector('[data-bs-toggle="dropdown"]');
      var dropdown = new _dropdown["default"](btnDropdown);
      dropdown.toggle();
      expect(dropdown._popper).not.toBeNull();
      expect(dropdown._menu).not.toBeNull();
      expect(dropdown._element).not.toBeNull();
      dropdown.dispose();
      expect(dropdown._popper).toBeNull();
      expect(dropdown._menu).toBeNull();
      expect(dropdown._element).toBeNull();
    });
  });
  describe('update', function () {
    it('should call Popper and detect navbar on update', function () {
      fixtureEl.innerHTML = ['<div class="dropdown">', '  <button class="btn dropdown-toggle" data-bs-toggle="dropdown">Dropdown</button>', '  <div class="dropdown-menu">', '    <a class="dropdown-item" href="#">Secondary link</a>', '  </div>', '</div>'].join('');
      var btnDropdown = fixtureEl.querySelector('[data-bs-toggle="dropdown"]');
      var dropdown = new _dropdown["default"](btnDropdown);
      dropdown.toggle();
      expect(dropdown._popper).not.toBeNull();
      spyOn(dropdown._popper, 'update');
      spyOn(dropdown, '_detectNavbar');
      dropdown.update();
      expect(dropdown._popper.update).toHaveBeenCalled();
      expect(dropdown._detectNavbar).toHaveBeenCalled();
    });
    it('should just detect navbar on update', function () {
      fixtureEl.innerHTML = ['<div class="dropdown">', '  <button class="btn dropdown-toggle" data-bs-toggle="dropdown">Dropdown</button>', '  <div class="dropdown-menu">', '    <a class="dropdown-item" href="#">Secondary link</a>', '  </div>', '</div>'].join('');
      var btnDropdown = fixtureEl.querySelector('[data-bs-toggle="dropdown"]');
      var dropdown = new _dropdown["default"](btnDropdown);
      spyOn(dropdown, '_detectNavbar');
      dropdown.update();
      expect(dropdown._popper).toBeNull();
      expect(dropdown._detectNavbar).toHaveBeenCalled();
    });
  });
  describe('data-api', function () {
    it('should show and hide a dropdown', function (done) {
      fixtureEl.innerHTML = ['<div class="dropdown">', '  <button class="btn dropdown-toggle" data-bs-toggle="dropdown" aria-expanded="false">Dropdown</button>', '  <div class="dropdown-menu">', '    <a class="dropdown-item" href="#">Secondary link</a>', '  </div>', '</div>'].join('');
      var btnDropdown = fixtureEl.querySelector('[data-bs-toggle="dropdown"]');
      var showEventTriggered = false;
      var hideEventTriggered = false;
      btnDropdown.addEventListener('show.bs.dropdown', function () {
        showEventTriggered = true;
      });
      btnDropdown.addEventListener('shown.bs.dropdown', function (event) {
        return setTimeout(function () {
          expect(btnDropdown.classList.contains('show')).toEqual(true);
          expect(btnDropdown.getAttribute('aria-expanded')).toEqual('true');
          expect(showEventTriggered).toEqual(true);
          expect(event.relatedTarget).toEqual(btnDropdown);
          document.body.click();
        });
      });
      btnDropdown.addEventListener('hide.bs.dropdown', function () {
        hideEventTriggered = true;
      });
      btnDropdown.addEventListener('hidden.bs.dropdown', function (event) {
        expect(btnDropdown.classList.contains('show')).toEqual(false);
        expect(btnDropdown.getAttribute('aria-expanded')).toEqual('false');
        expect(hideEventTriggered).toEqual(true);
        expect(event.relatedTarget).toEqual(btnDropdown);
        done();
      });
      btnDropdown.click();
    });
    it('should not use Popper in navbar', function (done) {
      fixtureEl.innerHTML = ['<nav class="navbar navbar-expand-md navbar-light bg-light">', '  <div class="dropdown">', '    <button class="btn dropdown-toggle" data-bs-toggle="dropdown" aria-expanded="false">Dropdown</button>', '    <div class="dropdown-menu">', '      <a class="dropdown-item" href="#">Secondary link</a>', '    </div>', '  </div>', '</nav>'].join('');
      var btnDropdown = fixtureEl.querySelector('[data-bs-toggle="dropdown"]');
      var dropdownMenu = fixtureEl.querySelector('.dropdown-menu');
      var dropdown = new _dropdown["default"](btnDropdown);
      btnDropdown.addEventListener('shown.bs.dropdown', function () {
        expect(dropdown._popper).toBeNull();
        expect(dropdownMenu.getAttribute('style')).toEqual(null, 'no inline style applied by Popper');
        done();
      });
      dropdown.show();
    });
    it('should not collapse the dropdown when clicking a select option nested in the dropdown', function (done) {
      fixtureEl.innerHTML = ['<div class="dropdown">', '  <button class="btn dropdown-toggle" data-bs-toggle="dropdown" aria-expanded="false">Dropdown</button>', '  <div class="dropdown-menu">', '    <select>', '      <option selected>Open this select menu</option>', '      <option value="1">One</option>', '    </select>', '  </div>', '</div>'].join('');
      var btnDropdown = fixtureEl.querySelector('[data-bs-toggle="dropdown"]');
      var dropdownMenu = fixtureEl.querySelector('.dropdown-menu');
      var dropdown = new _dropdown["default"](btnDropdown);
      var hideSpy = spyOn(dropdown, '_completeHide');
      btnDropdown.addEventListener('shown.bs.dropdown', function () {
        var clickEvent = new MouseEvent('click', {
          bubbles: true
        });
        dropdownMenu.querySelector('option').dispatchEvent(clickEvent);
      });
      dropdownMenu.addEventListener('click', function (event) {
        expect(event.target.tagName).toMatch(/select|option/i);

        _dropdown["default"].clearMenus(event);

        setTimeout(function () {
          expect(hideSpy).not.toHaveBeenCalled();
          done();
        }, 10);
      });
      dropdown.show();
    });
    it('should manage bs attribute `data-bs-popper`="none" when dropdown is in navbar', function (done) {
      fixtureEl.innerHTML = ['<nav class="navbar navbar-expand-md navbar-light bg-light">', '  <div class="dropdown">', '    <button class="btn dropdown-toggle" data-bs-toggle="dropdown" aria-expanded="false">Dropdown</button>', '    <div class="dropdown-menu">', '      <a class="dropdown-item" href="#">Secondary link</a>', '    </div>', '  </div>', '</nav>'].join('');
      var btnDropdown = fixtureEl.querySelector('[data-bs-toggle="dropdown"]');
      var dropdownMenu = fixtureEl.querySelector('.dropdown-menu');
      var dropdown = new _dropdown["default"](btnDropdown);
      btnDropdown.addEventListener('shown.bs.dropdown', function () {
        expect(dropdownMenu.getAttribute('data-bs-popper')).toEqual('none');
        dropdown.hide();
      });
      btnDropdown.addEventListener('hidden.bs.dropdown', function () {
        expect(dropdownMenu.getAttribute('data-bs-popper')).toBeNull();
        done();
      });
      dropdown.show();
    });
    it('should not use Popper if display set to static', function (done) {
      fixtureEl.innerHTML = ['<div class="dropdown">', '  <button class="btn dropdown-toggle" data-bs-toggle="dropdown" data-bs-display="static">Dropdown</button>', '  <div class="dropdown-menu">', '    <a class="dropdown-item" href="#">Secondary link</a>', '  </div>', '</div>'].join('');
      var btnDropdown = fixtureEl.querySelector('[data-bs-toggle="dropdown"]');
      var dropdownMenu = fixtureEl.querySelector('.dropdown-menu');
      btnDropdown.addEventListener('shown.bs.dropdown', function () {
        // Popper adds this attribute when we use it
        expect(dropdownMenu.getAttribute('data-popper-placement')).toEqual(null);
        done();
      });
      btnDropdown.click();
    });
    it('should manage bs attribute `data-bs-popper`="static" when display set to static', function (done) {
      fixtureEl.innerHTML = ['<div class="dropdown">', '  <button class="btn dropdown-toggle" data-bs-toggle="dropdown" data-bs-display="static">Dropdown</button>', '  <div class="dropdown-menu">', '    <a class="dropdown-item" href="#">Secondary link</a>', '  </div>', '</div>'].join('');
      var btnDropdown = fixtureEl.querySelector('[data-bs-toggle="dropdown"]');
      var dropdownMenu = fixtureEl.querySelector('.dropdown-menu');
      var dropdown = new _dropdown["default"](btnDropdown);
      btnDropdown.addEventListener('shown.bs.dropdown', function () {
        expect(dropdownMenu.getAttribute('data-bs-popper')).toEqual('static');
        dropdown.hide();
      });
      btnDropdown.addEventListener('hidden.bs.dropdown', function () {
        expect(dropdownMenu.getAttribute('data-bs-popper')).toBeNull();
        done();
      });
      dropdown.show();
    });
    it('should remove "show" class if tabbing outside of menu', function (done) {
      fixtureEl.innerHTML = ['<div class="dropdown">', '  <button class="btn dropdown-toggle" data-bs-toggle="dropdown">Dropdown</button>', '  <div class="dropdown-menu">', '    <a class="dropdown-item" href="#">Secondary link</a>', '  </div>', '</div>'].join('');
      var btnDropdown = fixtureEl.querySelector('[data-bs-toggle="dropdown"]');
      btnDropdown.addEventListener('shown.bs.dropdown', function () {
        expect(btnDropdown.classList.contains('show')).toEqual(true);
        var keyup = (0, _fixture.createEvent)('keyup');
        keyup.key = 'Tab';
        document.dispatchEvent(keyup);
      });
      btnDropdown.addEventListener('hidden.bs.dropdown', function () {
        expect(btnDropdown.classList.contains('show')).toEqual(false);
        done();
      });
      btnDropdown.click();
    });
    it('should remove "show" class if body is clicked, with multiple dropdowns', function (done) {
      fixtureEl.innerHTML = ['<div class="nav">', '  <div class="dropdown" id="testmenu">', '    <a class="dropdown-toggle" data-bs-toggle="dropdown" href="#testmenu">Test menu</a>', '    <div class="dropdown-menu">', '      <a class="dropdown-item" href="#sub1">Submenu 1</a>', '    </div>', '  </div>', '</div>', '<div class="btn-group">', '  <button class="btn">Actions</button>', '  <button class="btn dropdown-toggle" data-bs-toggle="dropdown"></button>', '  <div class="dropdown-menu">', '    <a class="dropdown-item" href="#">Action 1</a>', '  </div>', '</div>'].join('');
      var triggerDropdownList = fixtureEl.querySelectorAll('[data-bs-toggle="dropdown"]');
      expect(triggerDropdownList.length).toEqual(2);

      var _triggerDropdownList = _slicedToArray(triggerDropdownList, 2),
          triggerDropdownFirst = _triggerDropdownList[0],
          triggerDropdownLast = _triggerDropdownList[1];

      triggerDropdownFirst.addEventListener('shown.bs.dropdown', function () {
        expect(triggerDropdownFirst.classList.contains('show')).toEqual(true);
        expect(fixtureEl.querySelectorAll('.dropdown-menu.show').length).toEqual(1);
        document.body.click();
      });
      triggerDropdownFirst.addEventListener('hidden.bs.dropdown', function () {
        expect(fixtureEl.querySelectorAll('.dropdown-menu.show').length).toEqual(0);
        triggerDropdownLast.click();
      });
      triggerDropdownLast.addEventListener('shown.bs.dropdown', function () {
        expect(triggerDropdownLast.classList.contains('show')).toEqual(true);
        expect(fixtureEl.querySelectorAll('.dropdown-menu.show').length).toEqual(1);
        document.body.click();
      });
      triggerDropdownLast.addEventListener('hidden.bs.dropdown', function () {
        expect(fixtureEl.querySelectorAll('.dropdown-menu.show').length).toEqual(0);
        done();
      });
      triggerDropdownFirst.click();
    });
    it('should remove "show" class if body if tabbing outside of menu, with multiple dropdowns', function (done) {
      fixtureEl.innerHTML = ['<div class="dropdown">', '  <a class="dropdown-toggle" data-bs-toggle="dropdown" href="#testmenu">Test menu</a>', '  <div class="dropdown-menu">', '    <a class="dropdown-item" href="#sub1">Submenu 1</a>', '  </div>', '</div>', '<div class="btn-group">', '  <button class="btn">Actions</button>', '  <button class="btn dropdown-toggle" data-bs-toggle="dropdown"></button>', '  <div class="dropdown-menu">', '    <a class="dropdown-item" href="#">Action 1</a>', '  </div>', '</div>'].join('');
      var triggerDropdownList = fixtureEl.querySelectorAll('[data-bs-toggle="dropdown"]');
      expect(triggerDropdownList.length).toEqual(2);

      var _triggerDropdownList2 = _slicedToArray(triggerDropdownList, 2),
          triggerDropdownFirst = _triggerDropdownList2[0],
          triggerDropdownLast = _triggerDropdownList2[1];

      triggerDropdownFirst.addEventListener('shown.bs.dropdown', function () {
        expect(triggerDropdownFirst.classList.contains('show')).toEqual(true, '"show" class added on click');
        expect(fixtureEl.querySelectorAll('.dropdown-menu.show').length).toEqual(1, 'only one dropdown is shown');
        var keyup = (0, _fixture.createEvent)('keyup');
        keyup.key = 'Tab';
        document.dispatchEvent(keyup);
      });
      triggerDropdownFirst.addEventListener('hidden.bs.dropdown', function () {
        expect(fixtureEl.querySelectorAll('.dropdown-menu.show').length).toEqual(0, '"show" class removed');
        triggerDropdownLast.click();
      });
      triggerDropdownLast.addEventListener('shown.bs.dropdown', function () {
        expect(triggerDropdownLast.classList.contains('show')).toEqual(true, '"show" class added on click');
        expect(fixtureEl.querySelectorAll('.dropdown-menu.show').length).toEqual(1, 'only one dropdown is shown');
        var keyup = (0, _fixture.createEvent)('keyup');
        keyup.key = 'Tab';
        document.dispatchEvent(keyup);
      });
      triggerDropdownLast.addEventListener('hidden.bs.dropdown', function () {
        expect(fixtureEl.querySelectorAll('.dropdown-menu.show').length).toEqual(0, '"show" class removed');
        done();
      });
      triggerDropdownFirst.click();
    });
    it('should fire hide and hidden event without a clickEvent if event type is not click', function (done) {
      fixtureEl.innerHTML = ['<div class="dropdown">', '  <button class="btn dropdown-toggle" data-bs-toggle="dropdown">Dropdown</button>', '  <div class="dropdown-menu">', '    <a class="dropdown-item" href="#sub1">Submenu 1</a>', '  </div>', '</div>'].join('');
      var triggerDropdown = fixtureEl.querySelector('[data-bs-toggle="dropdown"]');
      triggerDropdown.addEventListener('hide.bs.dropdown', function (event) {
        expect(event.clickEvent).toBeUndefined();
      });
      triggerDropdown.addEventListener('hidden.bs.dropdown', function (event) {
        expect(event.clickEvent).toBeUndefined();
        done();
      });
      triggerDropdown.addEventListener('shown.bs.dropdown', function () {
        var keydown = (0, _fixture.createEvent)('keydown');
        keydown.key = 'Escape';
        triggerDropdown.dispatchEvent(keydown);
      });
      triggerDropdown.click();
    });
    it('should bubble up the events to the parent elements', function (done) {
      fixtureEl.innerHTML = ['<div class="dropdown">', '  <button class="btn dropdown-toggle" data-bs-toggle="dropdown">Dropdown</button>', '  <div class="dropdown-menu">', '    <a class="dropdown-item" href="#subMenu">Sub menu</a>', '  </div>', '</div>'].join('');
      var triggerDropdown = fixtureEl.querySelector('[data-bs-toggle="dropdown"]');
      var dropdownParent = fixtureEl.querySelector('.dropdown');
      var dropdown = new _dropdown["default"](triggerDropdown);
      var showFunction = jasmine.createSpy('showFunction');
      dropdownParent.addEventListener('show.bs.dropdown', showFunction);
      var shownFunction = jasmine.createSpy('shownFunction');
      dropdownParent.addEventListener('shown.bs.dropdown', function () {
        shownFunction();
        dropdown.hide();
      });
      var hideFunction = jasmine.createSpy('hideFunction');
      dropdownParent.addEventListener('hide.bs.dropdown', hideFunction);
      dropdownParent.addEventListener('hidden.bs.dropdown', function () {
        expect(showFunction).toHaveBeenCalled();
        expect(shownFunction).toHaveBeenCalled();
        expect(hideFunction).toHaveBeenCalled();
        done();
      });
      dropdown.show();
    });
    it('should ignore keyboard events within <input>s and <textarea>s', function (done) {
      fixtureEl.innerHTML = ['<div class="dropdown">', '  <button class="btn dropdown-toggle" data-bs-toggle="dropdown">Dropdown</button>', '  <div class="dropdown-menu">', '    <a class="dropdown-item" href="#sub1">Submenu 1</a>', '    <input type="text">', '    <textarea></textarea>', '  </div>', '</div>'].join('');
      var triggerDropdown = fixtureEl.querySelector('[data-bs-toggle="dropdown"]');
      var input = fixtureEl.querySelector('input');
      var textarea = fixtureEl.querySelector('textarea');
      triggerDropdown.addEventListener('shown.bs.dropdown', function () {
        input.focus();
        var keydown = (0, _fixture.createEvent)('keydown');
        keydown.key = 'ArrowUp';
        input.dispatchEvent(keydown);
        expect(document.activeElement).toEqual(input, 'input still focused');
        textarea.focus();
        textarea.dispatchEvent(keydown);
        expect(document.activeElement).toEqual(textarea, 'textarea still focused');
        done();
      });
      triggerDropdown.click();
    });
    it('should skip disabled element when using keyboard navigation', function (done) {
      fixtureEl.innerHTML = ['<div class="dropdown">', '  <button class="btn dropdown-toggle" data-bs-toggle="dropdown">Dropdown</button>', '  <div class="dropdown-menu">', '    <a class="dropdown-item disabled" href="#sub1">Submenu 1</a>', '    <button class="dropdown-item" type="button" disabled>Disabled button</button>', '    <a id="item1" class="dropdown-item" href="#">Another link</a>', '  </div>', '</div>'].join('');
      var triggerDropdown = fixtureEl.querySelector('[data-bs-toggle="dropdown"]');
      triggerDropdown.addEventListener('shown.bs.dropdown', function () {
        var keydown = (0, _fixture.createEvent)('keydown');
        keydown.key = 'ArrowDown';
        triggerDropdown.dispatchEvent(keydown);
        triggerDropdown.dispatchEvent(keydown);
        expect(document.activeElement.classList.contains('disabled')).toEqual(false, '.disabled not focused');
        expect(document.activeElement.hasAttribute('disabled')).toEqual(false, ':disabled not focused');
        done();
      });
      triggerDropdown.click();
    });
    it('should skip hidden element when using keyboard navigation', function (done) {
      fixtureEl.innerHTML = ['<style>', '  .d-none {', '    display: none;', '  }', '</style>', '<div class="dropdown">', '  <button class="btn dropdown-toggle" data-bs-toggle="dropdown">Dropdown</button>', '  <div class="dropdown-menu">', '    <button class="dropdown-item d-none" type="button">Hidden button by class</button>', '    <a class="dropdown-item" href="#sub1" style="display: none">Hidden link</a>', '    <a class="dropdown-item" href="#sub1" style="visibility: hidden">Hidden link</a>', '    <a id="item1" class="dropdown-item" href="#">Another link</a>', '  </div>', '</div>'].join('');
      var triggerDropdown = fixtureEl.querySelector('[data-bs-toggle="dropdown"]');
      triggerDropdown.addEventListener('shown.bs.dropdown', function () {
        var keydown = (0, _fixture.createEvent)('keydown');
        keydown.key = 'ArrowDown';
        triggerDropdown.dispatchEvent(keydown);
        expect(document.activeElement.classList.contains('d-none')).toEqual(false, '.d-none not focused');
        expect(document.activeElement.style.display).not.toBe('none', '"display: none" not focused');
        expect(document.activeElement.style.visibility).not.toBe('hidden', '"visibility: hidden" not focused');
        done();
      });
      triggerDropdown.click();
    });
    it('should focus next/previous element when using keyboard navigation', function (done) {
      fixtureEl.innerHTML = ['<div class="dropdown">', '  <button class="btn dropdown-toggle" data-bs-toggle="dropdown">Dropdown</button>', '  <div class="dropdown-menu">', '    <a id="item1" class="dropdown-item" href="#">A link</a>', '    <a id="item2" class="dropdown-item" href="#">Another link</a>', '  </div>', '</div>'].join('');
      var triggerDropdown = fixtureEl.querySelector('[data-bs-toggle="dropdown"]');
      var item1 = fixtureEl.querySelector('#item1');
      var item2 = fixtureEl.querySelector('#item2');
      triggerDropdown.addEventListener('shown.bs.dropdown', function () {
        var keydownArrowDown = (0, _fixture.createEvent)('keydown');
        keydownArrowDown.key = 'ArrowDown';
        triggerDropdown.dispatchEvent(keydownArrowDown);
        expect(document.activeElement).toEqual(item1, 'item1 is focused');
        document.activeElement.dispatchEvent(keydownArrowDown);
        expect(document.activeElement).toEqual(item2, 'item2 is focused');
        var keydownArrowUp = (0, _fixture.createEvent)('keydown');
        keydownArrowUp.key = 'ArrowUp';
        document.activeElement.dispatchEvent(keydownArrowUp);
        expect(document.activeElement).toEqual(item1, 'item1 is focused');
        done();
      });
      triggerDropdown.click();
    });
    it('should open the dropdown and focus on the last item when using ArrowUp for the first time', function (done) {
      fixtureEl.innerHTML = ['<div class="dropdown">', '  <button class="btn dropdown-toggle" data-bs-toggle="dropdown">Dropdown</button>', '  <div class="dropdown-menu">', '    <a id="item1" class="dropdown-item" href="#">A link</a>', '    <a id="item2" class="dropdown-item" href="#">Another link</a>', '  </div>', '</div>'].join('');
      var triggerDropdown = fixtureEl.querySelector('[data-bs-toggle="dropdown"]');
      var lastItem = fixtureEl.querySelector('#item2');
      triggerDropdown.addEventListener('shown.bs.dropdown', function () {
        setTimeout(function () {
          expect(document.activeElement).toEqual(lastItem, 'item2 is focused');
          done();
        });
      });
      var keydown = (0, _fixture.createEvent)('keydown');
      keydown.key = 'ArrowUp';
      triggerDropdown.dispatchEvent(keydown);
    });
    it('should open the dropdown and focus on the first item when using ArrowDown for the first time', function (done) {
      fixtureEl.innerHTML = ['<div class="dropdown">', '  <button class="btn dropdown-toggle" data-bs-toggle="dropdown">Dropdown</button>', '  <div class="dropdown-menu">', '    <a id="item1" class="dropdown-item" href="#">A link</a>', '    <a id="item2" class="dropdown-item" href="#">Another link</a>', '  </div>', '</div>'].join('');
      var triggerDropdown = fixtureEl.querySelector('[data-bs-toggle="dropdown"]');
      var firstItem = fixtureEl.querySelector('#item1');
      triggerDropdown.addEventListener('shown.bs.dropdown', function () {
        setTimeout(function () {
          expect(document.activeElement).toEqual(firstItem, 'item1 is focused');
          done();
        });
      });
      var keydown = (0, _fixture.createEvent)('keydown');
      keydown.key = 'ArrowDown';
      triggerDropdown.dispatchEvent(keydown);
    });
    it('should not close the dropdown if the user clicks on a text field within dropdown-menu', function (done) {
      fixtureEl.innerHTML = ['<div class="dropdown">', '  <button class="btn dropdown-toggle" data-bs-toggle="dropdown">Dropdown</button>', '  <div class="dropdown-menu">', '    <input type="text">', '  </div>', '</div>'].join('');
      var triggerDropdown = fixtureEl.querySelector('[data-bs-toggle="dropdown"]');
      var input = fixtureEl.querySelector('input');
      input.addEventListener('click', function () {
        expect(triggerDropdown.classList.contains('show')).toEqual(true, 'dropdown menu is shown');
        done();
      });
      triggerDropdown.addEventListener('shown.bs.dropdown', function () {
        expect(triggerDropdown.classList.contains('show')).toEqual(true, 'dropdown menu is shown');
        input.dispatchEvent((0, _fixture.createEvent)('click'));
      });
      triggerDropdown.click();
    });
    it('should not close the dropdown if the user clicks on a textarea within dropdown-menu', function (done) {
      fixtureEl.innerHTML = ['<div class="dropdown">', '  <button class="btn dropdown-toggle" data-bs-toggle="dropdown">Dropdown</button>', '  <div class="dropdown-menu">', '    <textarea></textarea>', '  </div>', '</div>'].join('');
      var triggerDropdown = fixtureEl.querySelector('[data-bs-toggle="dropdown"]');
      var textarea = fixtureEl.querySelector('textarea');
      textarea.addEventListener('click', function () {
        expect(triggerDropdown.classList.contains('show')).toEqual(true, 'dropdown menu is shown');
        done();
      });
      triggerDropdown.addEventListener('shown.bs.dropdown', function () {
        expect(triggerDropdown.classList.contains('show')).toEqual(true, 'dropdown menu is shown');
        textarea.dispatchEvent((0, _fixture.createEvent)('click'));
      });
      triggerDropdown.click();
    });
    it('should close the dropdown if the user clicks on a text field that is not contained within dropdown-menu', function (done) {
      fixtureEl.innerHTML = ['<div class="dropdown">', '  <button class="btn dropdown-toggle" data-bs-toggle="dropdown">Dropdown</button>', '  <div class="dropdown-menu">', '  </div>', '</div>', '<input type="text">'];
      var triggerDropdown = fixtureEl.querySelector('[data-bs-toggle="dropdown"]');
      var input = fixtureEl.querySelector('input');
      triggerDropdown.addEventListener('hidden.bs.dropdown', function () {
        expect().nothing();
        done();
      });
      triggerDropdown.addEventListener('shown.bs.dropdown', function () {
        input.dispatchEvent((0, _fixture.createEvent)('click', {
          bubbles: true
        }));
      });
      triggerDropdown.click();
    });
    it('should ignore keyboard events for <input>s and <textarea>s within dropdown-menu, except for escape key', function (done) {
      fixtureEl.innerHTML = ['<div class="dropdown">', '  <button class="btn dropdown-toggle" data-bs-toggle="dropdown">Dropdown</button>', '  <div class="dropdown-menu">', '    <a class="dropdown-item" href="#sub1">Submenu 1</a>', '    <input type="text">', '    <textarea></textarea>', '  </div>', '</div>'].join('');
      var triggerDropdown = fixtureEl.querySelector('[data-bs-toggle="dropdown"]');
      var input = fixtureEl.querySelector('input');
      var textarea = fixtureEl.querySelector('textarea');
      var keydownSpace = (0, _fixture.createEvent)('keydown');
      keydownSpace.key = 'Space';
      var keydownArrowUp = (0, _fixture.createEvent)('keydown');
      keydownArrowUp.key = 'ArrowUp';
      var keydownArrowDown = (0, _fixture.createEvent)('keydown');
      keydownArrowDown.key = 'ArrowDown';
      var keydownEscape = (0, _fixture.createEvent)('keydown');
      keydownEscape.key = 'Escape';
      triggerDropdown.addEventListener('shown.bs.dropdown', function () {
        // Key Space
        input.focus();
        input.dispatchEvent(keydownSpace);
        expect(document.activeElement).toEqual(input, 'input still focused');
        textarea.focus();
        textarea.dispatchEvent(keydownSpace);
        expect(document.activeElement).toEqual(textarea, 'textarea still focused'); // Key ArrowUp

        input.focus();
        input.dispatchEvent(keydownArrowUp);
        expect(document.activeElement).toEqual(input, 'input still focused');
        textarea.focus();
        textarea.dispatchEvent(keydownArrowUp);
        expect(document.activeElement).toEqual(textarea, 'textarea still focused'); // Key ArrowDown

        input.focus();
        input.dispatchEvent(keydownArrowDown);
        expect(document.activeElement).toEqual(input, 'input still focused');
        textarea.focus();
        textarea.dispatchEvent(keydownArrowDown);
        expect(document.activeElement).toEqual(textarea, 'textarea still focused'); // Key Escape

        input.focus();
        input.dispatchEvent(keydownEscape);
        expect(triggerDropdown.classList.contains('show')).toEqual(false, 'dropdown menu is not shown');
        done();
      });
      triggerDropdown.click();
    });
    it('should not open dropdown if escape key was pressed on the toggle', function (done) {
      fixtureEl.innerHTML = ['<div class="tabs">', '  <div class="dropdown">', '    <button disabled class="btn dropdown-toggle" data-bs-toggle="dropdown">Dropdown</button>', '    <div class="dropdown-menu">', '      <a class="dropdown-item" href="#">Secondary link</a>', '      <a class="dropdown-item" href="#">Something else here</a>', '      <div class="divider"></div>', '     <a class="dropdown-item" href="#">Another link</a>', '   </div>', '  </div>', '</div>'];
      var triggerDropdown = fixtureEl.querySelector('[data-bs-toggle="dropdown"]');
      var dropdown = new _dropdown["default"](triggerDropdown);
      var button = fixtureEl.querySelector('button[data-bs-toggle="dropdown"]');
      spyOn(dropdown, 'toggle'); // Key escape

      button.focus(); // Key escape

      var keydownEscape = (0, _fixture.createEvent)('keydown');
      keydownEscape.key = 'Escape';
      button.dispatchEvent(keydownEscape);
      setTimeout(function () {
        expect(dropdown.toggle).not.toHaveBeenCalled();
        expect(triggerDropdown.classList.contains('show')).toEqual(false);
        done();
      }, 20);
    });
    it('should propagate escape key events if dropdown is closed', function (done) {
      fixtureEl.innerHTML = ['<div class="parent">', '  <div class="dropdown">', '    <button class="btn dropdown-toggle" data-bs-toggle="dropdown">Dropdown</button>', '    <div class="dropdown-menu">', '      <a class="dropdown-item" href="#">Some Item</a>', '   </div>', '  </div>', '</div>'];
      var parent = fixtureEl.querySelector('.parent');
      var toggle = fixtureEl.querySelector('[data-bs-toggle="dropdown"]');
      var parentKeyHandler = jasmine.createSpy('parentKeyHandler');
      parent.addEventListener('keydown', parentKeyHandler);
      parent.addEventListener('keyup', function () {
        expect(parentKeyHandler).toHaveBeenCalled();
        done();
      });
      var keydownEscape = (0, _fixture.createEvent)('keydown', {
        bubbles: true
      });
      keydownEscape.key = 'Escape';
      var keyupEscape = (0, _fixture.createEvent)('keyup', {
        bubbles: true
      });
      keyupEscape.key = 'Escape';
      toggle.focus();
      toggle.dispatchEvent(keydownEscape);
      toggle.dispatchEvent(keyupEscape);
    });
    it('should close dropdown (only) by clicking inside the dropdown menu when it has data-attribute `data-bs-auto-close="inside"`', function (done) {
      fixtureEl.innerHTML = ['<div class="dropdown">', '  <button class="btn dropdown-toggle" data-bs-toggle="dropdown" data-bs-auto-close="inside">Dropdown toggle</button>', '  <div class="dropdown-menu">', '    <a class="dropdown-item" href="#">Dropdown item</a>', ' </div>', '</div>'];
      var dropdownToggle = fixtureEl.querySelector('[data-bs-toggle="dropdown"]');
      var dropdownMenu = fixtureEl.querySelector('.dropdown-menu');

      var expectDropdownToBeOpened = function expectDropdownToBeOpened() {
        return setTimeout(function () {
          expect(dropdownToggle.classList.contains('show')).toEqual(true);
          dropdownMenu.click();
        }, 150);
      };

      dropdownToggle.addEventListener('shown.bs.dropdown', function () {
        document.documentElement.click();
        expectDropdownToBeOpened();
      });
      dropdownToggle.addEventListener('hidden.bs.dropdown', function () {
        return setTimeout(function () {
          expect(dropdownToggle.classList.contains('show')).toEqual(false);
          done();
        });
      });
      dropdownToggle.click();
    });
    it('should close dropdown (only) by clicking outside the dropdown menu when it has data-attribute `data-bs-auto-close="outside"`', function (done) {
      fixtureEl.innerHTML = ['<div class="dropdown">', '  <button class="btn dropdown-toggle" data-bs-toggle="dropdown" data-bs-auto-close="outside">Dropdown toggle</button>', '  <div class="dropdown-menu">', '    <a class="dropdown-item" href="#">Dropdown item</a>', ' </div>', '</div>'];
      var dropdownToggle = fixtureEl.querySelector('[data-bs-toggle="dropdown"]');
      var dropdownMenu = fixtureEl.querySelector('.dropdown-menu');

      var expectDropdownToBeOpened = function expectDropdownToBeOpened() {
        return setTimeout(function () {
          expect(dropdownToggle.classList.contains('show')).toEqual(true);
          document.documentElement.click();
        }, 150);
      };

      dropdownToggle.addEventListener('shown.bs.dropdown', function () {
        dropdownMenu.click();
        expectDropdownToBeOpened();
      });
      dropdownToggle.addEventListener('hidden.bs.dropdown', function () {
        expect(dropdownToggle.classList.contains('show')).toEqual(false);
        done();
      });
      dropdownToggle.click();
    });
    it('should not close dropdown by clicking inside or outside the dropdown menu when it has data-attribute `data-bs-auto-close="false"`', function (done) {
      fixtureEl.innerHTML = ['<div class="dropdown">', '  <button class="btn dropdown-toggle" data-bs-toggle="dropdown" data-bs-auto-close="false">Dropdown toggle</button>', '  <div class="dropdown-menu">', '    <a class="dropdown-item" href="#">Dropdown item</a>', ' </div>', '</div>'];
      var dropdownToggle = fixtureEl.querySelector('[data-bs-toggle="dropdown"]');
      var dropdownMenu = fixtureEl.querySelector('.dropdown-menu');

      var expectDropdownToBeOpened = function expectDropdownToBeOpened() {
        var shouldTriggerClick = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
        return setTimeout(function () {
          expect(dropdownToggle.classList.contains('show')).toEqual(true);

          if (shouldTriggerClick) {
            document.documentElement.click();
          } else {
            done();
          }

          expectDropdownToBeOpened(false);
        }, 150);
      };

      dropdownToggle.addEventListener('shown.bs.dropdown', function () {
        dropdownMenu.click();
        expectDropdownToBeOpened();
      });
      dropdownToggle.click();
    });
  });
  describe('jQueryInterface', function () {
    it('should create a dropdown', function () {
      fixtureEl.innerHTML = '<div></div>';
      var div = fixtureEl.querySelector('div');
      _fixture.jQueryMock.fn.dropdown = _dropdown["default"].jQueryInterface;
      _fixture.jQueryMock.elements = [div];

      _fixture.jQueryMock.fn.dropdown.call(_fixture.jQueryMock);

      expect(_dropdown["default"].getInstance(div)).not.toBeNull();
    });
    it('should not re create a dropdown', function () {
      fixtureEl.innerHTML = '<div></div>';
      var div = fixtureEl.querySelector('div');
      var dropdown = new _dropdown["default"](div);
      _fixture.jQueryMock.fn.dropdown = _dropdown["default"].jQueryInterface;
      _fixture.jQueryMock.elements = [div];

      _fixture.jQueryMock.fn.dropdown.call(_fixture.jQueryMock);

      expect(_dropdown["default"].getInstance(div)).toEqual(dropdown);
    });
    it('should throw error on undefined method', function () {
      fixtureEl.innerHTML = '<div></div>';
      var div = fixtureEl.querySelector('div');
      var action = 'undefinedMethod';
      _fixture.jQueryMock.fn.dropdown = _dropdown["default"].jQueryInterface;
      _fixture.jQueryMock.elements = [div];
      expect(function () {
        _fixture.jQueryMock.fn.dropdown.call(_fixture.jQueryMock, action);
      }).toThrowError(TypeError, "No method named \"".concat(action, "\""));
    });
  });
  describe('getInstance', function () {
    it('should return dropdown instance', function () {
      fixtureEl.innerHTML = '<div></div>';
      var div = fixtureEl.querySelector('div');
      var dropdown = new _dropdown["default"](div);
      expect(_dropdown["default"].getInstance(div)).toEqual(dropdown);
      expect(_dropdown["default"].getInstance(div)).toBeInstanceOf(_dropdown["default"]);
    });
    it('should return null when there is no dropdown instance', function () {
      fixtureEl.innerHTML = '<div></div>';
      var div = fixtureEl.querySelector('div');
      expect(_dropdown["default"].getInstance(div)).toEqual(null);
    });
  });
  describe('getOrCreateInstance', function () {
    it('should return dropdown instance', function () {
      fixtureEl.innerHTML = '<div></div>';
      var div = fixtureEl.querySelector('div');
      var dropdown = new _dropdown["default"](div);
      expect(_dropdown["default"].getOrCreateInstance(div)).toEqual(dropdown);
      expect(_dropdown["default"].getInstance(div)).toEqual(_dropdown["default"].getOrCreateInstance(div, {}));
      expect(_dropdown["default"].getOrCreateInstance(div)).toBeInstanceOf(_dropdown["default"]);
    });
    it('should return new instance when there is no dropdown instance', function () {
      fixtureEl.innerHTML = '<div></div>';
      var div = fixtureEl.querySelector('div');
      expect(_dropdown["default"].getInstance(div)).toEqual(null);
      expect(_dropdown["default"].getOrCreateInstance(div)).toBeInstanceOf(_dropdown["default"]);
    });
    it('should return new instance when there is no dropdown instance with given configuration', function () {
      fixtureEl.innerHTML = '<div></div>';
      var div = fixtureEl.querySelector('div');
      expect(_dropdown["default"].getInstance(div)).toEqual(null);

      var dropdown = _dropdown["default"].getOrCreateInstance(div, {
        display: 'dynamic'
      });

      expect(dropdown).toBeInstanceOf(_dropdown["default"]);
      expect(dropdown._config.display).toEqual('dynamic');
    });
    it('should return the instance when exists without given configuration', function () {
      fixtureEl.innerHTML = '<div></div>';
      var div = fixtureEl.querySelector('div');
      var dropdown = new _dropdown["default"](div, {
        display: 'dynamic'
      });
      expect(_dropdown["default"].getInstance(div)).toEqual(dropdown);

      var dropdown2 = _dropdown["default"].getOrCreateInstance(div, {
        display: 'static'
      });

      expect(dropdown).toBeInstanceOf(_dropdown["default"]);
      expect(dropdown2).toEqual(dropdown);
      expect(dropdown2._config.display).toEqual('dynamic');
    });
  });
  it('should open dropdown when pressing keydown or keyup', function (done) {
    fixtureEl.innerHTML = ['<div class="dropdown">', '  <button class="btn dropdown-toggle" data-bs-toggle="dropdown">Dropdown</button>', '  <div class="dropdown-menu">', '    <a class="dropdown-item disabled" href="#sub1">Submenu 1</a>', '    <button class="dropdown-item" type="button" disabled>Disabled button</button>', '    <a id="item1" class="dropdown-item" href="#">Another link</a>', '  </div>', '</div>'].join('');
    var triggerDropdown = fixtureEl.querySelector('[data-bs-toggle="dropdown"]');
    var dropdown = fixtureEl.querySelector('.dropdown');
    var keydown = (0, _fixture.createEvent)('keydown');
    keydown.key = 'ArrowDown';
    var keyup = (0, _fixture.createEvent)('keyup');
    keyup.key = 'ArrowUp';

    var handleArrowDown = function handleArrowDown() {
      expect(triggerDropdown.classList.contains('show')).toEqual(true);
      expect(triggerDropdown.getAttribute('aria-expanded')).toEqual('true');
      setTimeout(function () {
        dropdown.hide();
        keydown.key = 'ArrowUp';
        triggerDropdown.dispatchEvent(keyup);
      }, 20);
    };

    var handleArrowUp = function handleArrowUp() {
      expect(triggerDropdown.classList.contains('show')).toEqual(true);
      expect(triggerDropdown.getAttribute('aria-expanded')).toEqual('true');
      done();
    };

    dropdown.addEventListener('shown.bs.dropdown', function (event) {
      if (event.target.key === 'ArrowDown') {
        handleArrowDown();
      } else {
        handleArrowUp();
      }
    });
    triggerDropdown.dispatchEvent(keydown);
  });
  it('should allow `data-bs-toggle="dropdown"` click events to bubble up', function () {
    fixtureEl.innerHTML = ['<div class="dropdown">', '  <button class="btn dropdown-toggle" data-bs-toggle="dropdown">Dropdown</button>', '  <div class="dropdown-menu">', '    <a class="dropdown-item" href="#">Secondary link</a>', '  </div>', '</div>'].join('');
    var btnDropdown = fixtureEl.querySelector('[data-bs-toggle="dropdown"]');
    var clickListener = jasmine.createSpy('clickListener');
    var delegatedClickListener = jasmine.createSpy('delegatedClickListener');
    btnDropdown.addEventListener('click', clickListener);
    document.addEventListener('click', delegatedClickListener);
    btnDropdown.click();
    expect(clickListener).toHaveBeenCalled();
    expect(delegatedClickListener).toHaveBeenCalled();
  });
  it('should open the dropdown when clicking the child element inside `data-bs-toggle="dropdown"`', function (done) {
    fixtureEl.innerHTML = ['<div class="container">', '  <div class="dropdown">', '    <button class="btn dropdown-toggle" data-bs-toggle="dropdown"><span id="childElement">Dropdown</span></button>', '    <div class="dropdown-menu">', '      <a class="dropdown-item" href="#subMenu">Sub menu</a>', '    </div>', '  </div>', '</div>'].join('');
    var btnDropdown = fixtureEl.querySelector('[data-bs-toggle="dropdown"]');
    var childElement = fixtureEl.querySelector('#childElement');
    btnDropdown.addEventListener('shown.bs.dropdown', function () {
      return setTimeout(function () {
        expect(btnDropdown.classList.contains('show')).toEqual(true);
        expect(btnDropdown.getAttribute('aria-expanded')).toEqual('true');
        done();
      });
    });
    childElement.click();
  });
});
"use strict";

var _alert = _interopRequireDefault(require("../../src/alert"));

var _button = _interopRequireDefault(require("../../src/button"));

var _carousel = _interopRequireDefault(require("../../src/carousel"));

var _collapse = _interopRequireDefault(require("../../src/collapse"));

var _dropdown = _interopRequireDefault(require("../../src/dropdown"));

var _modal = _interopRequireDefault(require("../../src/modal"));

var _offcanvas = _interopRequireDefault(require("../../src/offcanvas"));

var _popover = _interopRequireDefault(require("../../src/popover"));

var _scrollspy = _interopRequireDefault(require("../../src/scrollspy"));

var _tab = _interopRequireDefault(require("../../src/tab"));

var _toast = _interopRequireDefault(require("../../src/toast"));

var _tooltip = _interopRequireDefault(require("../../src/tooltip"));

var _fixture = require("../helpers/fixture");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/* eslint-env jquery */

/** Test helpers */
describe('jQuery', function () {
  var fixtureEl;
  beforeAll(function () {
    fixtureEl = (0, _fixture.getFixture)();
  });
  afterEach(function () {
    (0, _fixture.clearFixture)();
  });
  it('should add all plugins in jQuery', function () {
    expect(_alert["default"].jQueryInterface).toEqual(jQuery.fn.alert);
    expect(_button["default"].jQueryInterface).toEqual(jQuery.fn.button);
    expect(_carousel["default"].jQueryInterface).toEqual(jQuery.fn.carousel);
    expect(_collapse["default"].jQueryInterface).toEqual(jQuery.fn.collapse);
    expect(_dropdown["default"].jQueryInterface).toEqual(jQuery.fn.dropdown);
    expect(_modal["default"].jQueryInterface).toEqual(jQuery.fn.modal);
    expect(_offcanvas["default"].jQueryInterface).toEqual(jQuery.fn.offcanvas);
    expect(_popover["default"].jQueryInterface).toEqual(jQuery.fn.popover);
    expect(_scrollspy["default"].jQueryInterface).toEqual(jQuery.fn.scrollspy);
    expect(_tab["default"].jQueryInterface).toEqual(jQuery.fn.tab);
    expect(_toast["default"].jQueryInterface).toEqual(jQuery.fn.toast);
    expect(_tooltip["default"].jQueryInterface).toEqual(jQuery.fn.tooltip);
  });
  it('should use jQuery event system', function (done) {
    fixtureEl.innerHTML = ['<div class="alert">', '  <button type="button" data-bs-dismiss="alert">x</button>', '</div>'].join('');
    $(fixtureEl).find('.alert').one('closed.bs.alert', function () {
      expect($(fixtureEl).find('.alert').length).toEqual(0);
      done();
    });
    $(fixtureEl).find('button').trigger('click');
  });
});
"use strict";

var _modal = _interopRequireDefault(require("../../src/modal"));

var _eventHandler = _interopRequireDefault(require("../../src/dom/event-handler"));

var _scrollbar = _interopRequireDefault(require("../../src/util/scrollbar"));

var _fixture = require("../helpers/fixture");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/** Test helpers */
describe('Modal', function () {
  var fixtureEl;
  beforeAll(function () {
    fixtureEl = (0, _fixture.getFixture)();
  });
  afterEach(function () {
    (0, _fixture.clearFixture)();
    (0, _fixture.clearBodyAndDocument)();
    document.body.classList.remove('modal-open');
    document.querySelectorAll('.modal-backdrop').forEach(function (backdrop) {
      backdrop.remove();
    });
  });
  beforeEach(function () {
    (0, _fixture.clearBodyAndDocument)();
  });
  describe('VERSION', function () {
    it('should return plugin version', function () {
      expect(_modal["default"].VERSION).toEqual(jasmine.any(String));
    });
  });
  describe('Default', function () {
    it('should return plugin default config', function () {
      expect(_modal["default"].Default).toEqual(jasmine.any(Object));
    });
  });
  describe('DATA_KEY', function () {
    it('should return plugin data key', function () {
      expect(_modal["default"].DATA_KEY).toEqual('bs.modal');
    });
  });
  describe('constructor', function () {
    it('should take care of element either passed as a CSS selector or DOM element', function () {
      fixtureEl.innerHTML = '<div class="modal"><div class="modal-dialog"></div></div>';
      var modalEl = fixtureEl.querySelector('.modal');
      var modalBySelector = new _modal["default"]('.modal');
      var modalByElement = new _modal["default"](modalEl);
      expect(modalBySelector._element).toEqual(modalEl);
      expect(modalByElement._element).toEqual(modalEl);
    });
  });
  describe('toggle', function () {
    it('should call ScrollBarHelper to handle scrollBar on body', function (done) {
      fixtureEl.innerHTML = ['<div class="modal"><div class="modal-dialog"></div></div>'].join('');
      spyOn(_scrollbar["default"].prototype, 'hide').and.callThrough();
      spyOn(_scrollbar["default"].prototype, 'reset').and.callThrough();
      var modalEl = fixtureEl.querySelector('.modal');
      var modal = new _modal["default"](modalEl);
      modalEl.addEventListener('shown.bs.modal', function () {
        expect(_scrollbar["default"].prototype.hide).toHaveBeenCalled();
        modal.toggle();
      });
      modalEl.addEventListener('hidden.bs.modal', function () {
        expect(_scrollbar["default"].prototype.reset).toHaveBeenCalled();
        done();
      });
      modal.toggle();
    });
  });
  describe('show', function () {
    it('should show a modal', function (done) {
      fixtureEl.innerHTML = '<div class="modal"><div class="modal-dialog"></div></div>';
      var modalEl = fixtureEl.querySelector('.modal');
      var modal = new _modal["default"](modalEl);
      modalEl.addEventListener('show.bs.modal', function (event) {
        expect(event).toBeDefined();
      });
      modalEl.addEventListener('shown.bs.modal', function () {
        expect(modalEl.getAttribute('aria-modal')).toEqual('true');
        expect(modalEl.getAttribute('role')).toEqual('dialog');
        expect(modalEl.getAttribute('aria-hidden')).toBeNull();
        expect(modalEl.style.display).toEqual('block');
        expect(document.querySelector('.modal-backdrop')).not.toBeNull();
        done();
      });
      modal.show();
    });
    it('should show a modal without backdrop', function (done) {
      fixtureEl.innerHTML = '<div class="modal"><div class="modal-dialog"></div></div>';
      var modalEl = fixtureEl.querySelector('.modal');
      var modal = new _modal["default"](modalEl, {
        backdrop: false
      });
      modalEl.addEventListener('show.bs.modal', function (event) {
        expect(event).toBeDefined();
      });
      modalEl.addEventListener('shown.bs.modal', function () {
        expect(modalEl.getAttribute('aria-modal')).toEqual('true');
        expect(modalEl.getAttribute('role')).toEqual('dialog');
        expect(modalEl.getAttribute('aria-hidden')).toBeNull();
        expect(modalEl.style.display).toEqual('block');
        expect(document.querySelector('.modal-backdrop')).toBeNull();
        done();
      });
      modal.show();
    });
    it('should show a modal and append the element', function (done) {
      var modalEl = document.createElement('div');
      var id = 'dynamicModal';
      modalEl.setAttribute('id', id);
      modalEl.classList.add('modal');
      modalEl.innerHTML = '<div class="modal-dialog"></div>';
      var modal = new _modal["default"](modalEl);
      modalEl.addEventListener('shown.bs.modal', function () {
        var dynamicModal = document.getElementById(id);
        expect(dynamicModal).not.toBeNull();
        dynamicModal.remove();
        done();
      });
      modal.show();
    });
    it('should do nothing if a modal is shown', function () {
      fixtureEl.innerHTML = '<div class="modal"><div class="modal-dialog"></div></div>';
      var modalEl = fixtureEl.querySelector('.modal');
      var modal = new _modal["default"](modalEl);
      spyOn(_eventHandler["default"], 'trigger');
      modal._isShown = true;
      modal.show();
      expect(_eventHandler["default"].trigger).not.toHaveBeenCalled();
    });
    it('should do nothing if a modal is transitioning', function () {
      fixtureEl.innerHTML = '<div class="modal"><div class="modal-dialog"></div></div>';
      var modalEl = fixtureEl.querySelector('.modal');
      var modal = new _modal["default"](modalEl);
      spyOn(_eventHandler["default"], 'trigger');
      modal._isTransitioning = true;
      modal.show();
      expect(_eventHandler["default"].trigger).not.toHaveBeenCalled();
    });
    it('should not fire shown event when show is prevented', function (done) {
      fixtureEl.innerHTML = '<div class="modal"><div class="modal-dialog"></div></div>';
      var modalEl = fixtureEl.querySelector('.modal');
      var modal = new _modal["default"](modalEl);
      modalEl.addEventListener('show.bs.modal', function (event) {
        event.preventDefault();

        var expectedDone = function expectedDone() {
          expect().nothing();
          done();
        };

        setTimeout(expectedDone, 10);
      });
      modalEl.addEventListener('shown.bs.modal', function () {
        throw new Error('shown event triggered');
      });
      modal.show();
    });
    it('should be shown after the first call to show() has been prevented while fading is enabled ', function (done) {
      fixtureEl.innerHTML = '<div class="modal fade"><div class="modal-dialog"></div></div>';
      var modalEl = fixtureEl.querySelector('.modal');
      var modal = new _modal["default"](modalEl);
      var prevented = false;
      modalEl.addEventListener('show.bs.modal', function (event) {
        if (!prevented) {
          event.preventDefault();
          prevented = true;
          setTimeout(function () {
            modal.show();
          });
        }
      });
      modalEl.addEventListener('shown.bs.modal', function () {
        expect(prevented).toBeTrue();
        expect(modal._isAnimated()).toBeTrue();
        done();
      });
      modal.show();
    });
    it('should set is transitioning if fade class is present', function (done) {
      fixtureEl.innerHTML = '<div class="modal fade"><div class="modal-dialog"></div></div>';
      var modalEl = fixtureEl.querySelector('.modal');
      var modal = new _modal["default"](modalEl);
      modalEl.addEventListener('show.bs.modal', function () {
        setTimeout(function () {
          expect(modal._isTransitioning).toEqual(true);
        });
      });
      modalEl.addEventListener('shown.bs.modal', function () {
        expect(modal._isTransitioning).toEqual(false);
        done();
      });
      modal.show();
    });
    it('should close modal when a click occurred on data-bs-dismiss="modal" inside modal', function (done) {
      fixtureEl.innerHTML = ['<div class="modal fade">', '  <div class="modal-dialog">', '    <div class="modal-header">', '      <button type="button" data-bs-dismiss="modal"></button>', '    </div>', '  </div>', '</div>'].join('');
      var modalEl = fixtureEl.querySelector('.modal');
      var btnClose = fixtureEl.querySelector('[data-bs-dismiss="modal"]');
      var modal = new _modal["default"](modalEl);
      spyOn(modal, 'hide').and.callThrough();
      modalEl.addEventListener('shown.bs.modal', function () {
        btnClose.click();
      });
      modalEl.addEventListener('hidden.bs.modal', function () {
        expect(modal.hide).toHaveBeenCalled();
        done();
      });
      modal.show();
    });
    it('should close modal when a click occurred on a data-bs-dismiss="modal" with "bs-target" outside of modal element', function (done) {
      fixtureEl.innerHTML = ['<button type="button" data-bs-dismiss="modal" data-bs-target="#modal1"></button>', '<div id="modal1" class="modal fade">', '  <div class="modal-dialog">', '  </div>', '</div>'].join('');
      var modalEl = fixtureEl.querySelector('.modal');
      var btnClose = fixtureEl.querySelector('[data-bs-dismiss="modal"]');
      var modal = new _modal["default"](modalEl);
      spyOn(modal, 'hide').and.callThrough();
      modalEl.addEventListener('shown.bs.modal', function () {
        btnClose.click();
      });
      modalEl.addEventListener('hidden.bs.modal', function () {
        expect(modal.hide).toHaveBeenCalled();
        done();
      });
      modal.show();
    });
    it('should set .modal\'s scroll top to 0', function (done) {
      fixtureEl.innerHTML = ['<div class="modal fade">', '  <div class="modal-dialog">', '  </div>', '</div>'].join('');
      var modalEl = fixtureEl.querySelector('.modal');
      var modal = new _modal["default"](modalEl);
      modalEl.addEventListener('shown.bs.modal', function () {
        expect(modalEl.scrollTop).toEqual(0);
        done();
      });
      modal.show();
    });
    it('should set modal body scroll top to 0 if modal body do not exists', function (done) {
      fixtureEl.innerHTML = ['<div class="modal fade">', '  <div class="modal-dialog">', '    <div class="modal-body"></div>', '  </div>', '</div>'].join('');
      var modalEl = fixtureEl.querySelector('.modal');
      var modalBody = modalEl.querySelector('.modal-body');
      var modal = new _modal["default"](modalEl);
      modalEl.addEventListener('shown.bs.modal', function () {
        expect(modalBody.scrollTop).toEqual(0);
        done();
      });
      modal.show();
    });
    it('should not trap focus if focus equal to false', function (done) {
      fixtureEl.innerHTML = '<div class="modal fade"><div class="modal-dialog"></div></div>';
      var modalEl = fixtureEl.querySelector('.modal');
      var modal = new _modal["default"](modalEl, {
        focus: false
      });
      spyOn(modal._focustrap, 'activate').and.callThrough();
      modalEl.addEventListener('shown.bs.modal', function () {
        expect(modal._focustrap.activate).not.toHaveBeenCalled();
        done();
      });
      modal.show();
    });
    it('should add listener when escape touch is pressed', function (done) {
      fixtureEl.innerHTML = '<div class="modal"><div class="modal-dialog"></div></div>';
      var modalEl = fixtureEl.querySelector('.modal');
      var modal = new _modal["default"](modalEl);
      spyOn(modal, 'hide').and.callThrough();
      modalEl.addEventListener('shown.bs.modal', function () {
        var keydownEscape = (0, _fixture.createEvent)('keydown');
        keydownEscape.key = 'Escape';
        modalEl.dispatchEvent(keydownEscape);
      });
      modalEl.addEventListener('hidden.bs.modal', function () {
        expect(modal.hide).toHaveBeenCalled();
        done();
      });
      modal.show();
    });
    it('should do nothing when the pressed key is not escape', function (done) {
      fixtureEl.innerHTML = '<div class="modal"><div class="modal-dialog"></div></div>';
      var modalEl = fixtureEl.querySelector('.modal');
      var modal = new _modal["default"](modalEl);
      spyOn(modal, 'hide');

      var expectDone = function expectDone() {
        expect(modal.hide).not.toHaveBeenCalled();
        done();
      };

      modalEl.addEventListener('shown.bs.modal', function () {
        var keydownTab = (0, _fixture.createEvent)('keydown');
        keydownTab.key = 'Tab';
        modalEl.dispatchEvent(keydownTab);
        setTimeout(expectDone, 30);
      });
      modal.show();
    });
    it('should adjust dialog on resize', function (done) {
      fixtureEl.innerHTML = '<div class="modal"><div class="modal-dialog"></div></div>';
      var modalEl = fixtureEl.querySelector('.modal');
      var modal = new _modal["default"](modalEl);
      spyOn(modal, '_adjustDialog').and.callThrough();

      var expectDone = function expectDone() {
        expect(modal._adjustDialog).toHaveBeenCalled();
        done();
      };

      modalEl.addEventListener('shown.bs.modal', function () {
        var resizeEvent = (0, _fixture.createEvent)('resize');
        window.dispatchEvent(resizeEvent);
        setTimeout(expectDone, 10);
      });
      modal.show();
    });
    it('should not close modal when clicking outside of modal-content if backdrop = false', function (done) {
      fixtureEl.innerHTML = '<div class="modal"><div class="modal-dialog"></div></div>';
      var modalEl = fixtureEl.querySelector('.modal');
      var modal = new _modal["default"](modalEl, {
        backdrop: false
      });

      var shownCallback = function shownCallback() {
        setTimeout(function () {
          expect(modal._isShown).toEqual(true);
          done();
        }, 10);
      };

      modalEl.addEventListener('shown.bs.modal', function () {
        modalEl.click();
        shownCallback();
      });
      modalEl.addEventListener('hidden.bs.modal', function () {
        throw new Error('Should not hide a modal');
      });
      modal.show();
    });
    it('should not close modal when clicking outside of modal-content if backdrop = static', function (done) {
      fixtureEl.innerHTML = '<div class="modal"><div class="modal-dialog"></div></div>';
      var modalEl = fixtureEl.querySelector('.modal');
      var modal = new _modal["default"](modalEl, {
        backdrop: 'static'
      });

      var shownCallback = function shownCallback() {
        setTimeout(function () {
          expect(modal._isShown).toEqual(true);
          done();
        }, 10);
      };

      modalEl.addEventListener('shown.bs.modal', function () {
        modalEl.click();
        shownCallback();
      });
      modalEl.addEventListener('hidden.bs.modal', function () {
        throw new Error('Should not hide a modal');
      });
      modal.show();
    });
    it('should close modal when escape key is pressed with keyboard = true and backdrop is static', function (done) {
      fixtureEl.innerHTML = '<div class="modal"><div class="modal-dialog"></div></div>';
      var modalEl = fixtureEl.querySelector('.modal');
      var modal = new _modal["default"](modalEl, {
        backdrop: 'static',
        keyboard: true
      });

      var shownCallback = function shownCallback() {
        setTimeout(function () {
          expect(modal._isShown).toEqual(false);
          done();
        }, 10);
      };

      modalEl.addEventListener('shown.bs.modal', function () {
        var keydownEscape = (0, _fixture.createEvent)('keydown');
        keydownEscape.key = 'Escape';
        modalEl.dispatchEvent(keydownEscape);
        shownCallback();
      });
      modal.show();
    });
    it('should not close modal when escape key is pressed with keyboard = false', function (done) {
      fixtureEl.innerHTML = '<div class="modal"><div class="modal-dialog"></div></div>';
      var modalEl = fixtureEl.querySelector('.modal');
      var modal = new _modal["default"](modalEl, {
        keyboard: false
      });

      var shownCallback = function shownCallback() {
        setTimeout(function () {
          expect(modal._isShown).toEqual(true);
          done();
        }, 10);
      };

      modalEl.addEventListener('shown.bs.modal', function () {
        var keydownEscape = (0, _fixture.createEvent)('keydown');
        keydownEscape.key = 'Escape';
        modalEl.dispatchEvent(keydownEscape);
        shownCallback();
      });
      modalEl.addEventListener('hidden.bs.modal', function () {
        throw new Error('Should not hide a modal');
      });
      modal.show();
    });
    it('should not overflow when clicking outside of modal-content if backdrop = static', function (done) {
      fixtureEl.innerHTML = '<div class="modal"><div class="modal-dialog" style="transition-duration: 20ms;"></div></div>';
      var modalEl = fixtureEl.querySelector('.modal');
      var modal = new _modal["default"](modalEl, {
        backdrop: 'static'
      });
      modalEl.addEventListener('shown.bs.modal', function () {
        modalEl.click();
        setTimeout(function () {
          expect(modalEl.clientHeight).toEqual(modalEl.scrollHeight);
          done();
        }, 20);
      });
      modal.show();
    });
    it('should not queue multiple callbacks when clicking outside of modal-content and backdrop = static', function (done) {
      fixtureEl.innerHTML = '<div class="modal"><div class="modal-dialog" style="transition-duration: 50ms;"></div></div>';
      var modalEl = fixtureEl.querySelector('.modal');
      var modal = new _modal["default"](modalEl, {
        backdrop: 'static'
      });
      modalEl.addEventListener('shown.bs.modal', function () {
        var spy = spyOn(modal, '_queueCallback').and.callThrough();
        modalEl.click();
        modalEl.click();
        setTimeout(function () {
          expect(spy).toHaveBeenCalledTimes(1);
          done();
        }, 20);
      });
      modal.show();
    });
    it('should trap focus', function (done) {
      fixtureEl.innerHTML = '<div class="modal"><div class="modal-dialog"></div></div>';
      var modalEl = fixtureEl.querySelector('.modal');
      var modal = new _modal["default"](modalEl);
      spyOn(modal._focustrap, 'activate').and.callThrough();
      modalEl.addEventListener('shown.bs.modal', function () {
        expect(modal._focustrap.activate).toHaveBeenCalled();
        done();
      });
      modal.show();
    });
  });
  describe('hide', function () {
    it('should hide a modal', function (done) {
      fixtureEl.innerHTML = '<div class="modal"><div class="modal-dialog"></div></div>';
      var modalEl = fixtureEl.querySelector('.modal');
      var modal = new _modal["default"](modalEl);
      modalEl.addEventListener('shown.bs.modal', function () {
        modal.hide();
      });
      modalEl.addEventListener('hide.bs.modal', function (event) {
        expect(event).toBeDefined();
      });
      modalEl.addEventListener('hidden.bs.modal', function () {
        expect(modalEl.getAttribute('aria-modal')).toBeNull();
        expect(modalEl.getAttribute('role')).toBeNull();
        expect(modalEl.getAttribute('aria-hidden')).toEqual('true');
        expect(modalEl.style.display).toEqual('none');
        expect(document.querySelector('.modal-backdrop')).toBeNull();
        done();
      });
      modal.show();
    });
    it('should close modal when clicking outside of modal-content', function (done) {
      fixtureEl.innerHTML = '<div class="modal"><div class="modal-dialog"></div></div>';
      var modalEl = fixtureEl.querySelector('.modal');
      var modal = new _modal["default"](modalEl);
      modalEl.addEventListener('shown.bs.modal', function () {
        modalEl.click();
      });
      modalEl.addEventListener('hidden.bs.modal', function () {
        expect(modalEl.getAttribute('aria-modal')).toBeNull();
        expect(modalEl.getAttribute('role')).toBeNull();
        expect(modalEl.getAttribute('aria-hidden')).toEqual('true');
        expect(modalEl.style.display).toEqual('none');
        expect(document.querySelector('.modal-backdrop')).toBeNull();
        done();
      });
      modal.show();
    });
    it('should do nothing is the modal is not shown', function () {
      fixtureEl.innerHTML = '<div class="modal"><div class="modal-dialog"></div></div>';
      var modalEl = fixtureEl.querySelector('.modal');
      var modal = new _modal["default"](modalEl);
      modal.hide();
      expect().nothing();
    });
    it('should do nothing is the modal is transitioning', function () {
      fixtureEl.innerHTML = '<div class="modal"><div class="modal-dialog"></div></div>';
      var modalEl = fixtureEl.querySelector('.modal');
      var modal = new _modal["default"](modalEl);
      modal._isTransitioning = true;
      modal.hide();
      expect().nothing();
    });
    it('should not hide a modal if hide is prevented', function (done) {
      fixtureEl.innerHTML = '<div class="modal"><div class="modal-dialog"></div></div>';
      var modalEl = fixtureEl.querySelector('.modal');
      var modal = new _modal["default"](modalEl);
      modalEl.addEventListener('shown.bs.modal', function () {
        modal.hide();
      });

      var hideCallback = function hideCallback() {
        setTimeout(function () {
          expect(modal._isShown).toEqual(true);
          done();
        }, 10);
      };

      modalEl.addEventListener('hide.bs.modal', function (event) {
        event.preventDefault();
        hideCallback();
      });
      modalEl.addEventListener('hidden.bs.modal', function () {
        throw new Error('should not trigger hidden');
      });
      modal.show();
    });
    it('should release focus trap', function (done) {
      fixtureEl.innerHTML = '<div class="modal"><div class="modal-dialog"></div></div>';
      var modalEl = fixtureEl.querySelector('.modal');
      var modal = new _modal["default"](modalEl);
      spyOn(modal._focustrap, 'deactivate').and.callThrough();
      modalEl.addEventListener('shown.bs.modal', function () {
        modal.hide();
      });
      modalEl.addEventListener('hidden.bs.modal', function () {
        expect(modal._focustrap.deactivate).toHaveBeenCalled();
        done();
      });
      modal.show();
    });
  });
  describe('dispose', function () {
    it('should dispose a modal', function () {
      fixtureEl.innerHTML = '<div id="exampleModal" class="modal"><div class="modal-dialog"></div></div>';
      var modalEl = fixtureEl.querySelector('.modal');
      var modal = new _modal["default"](modalEl);
      var focustrap = modal._focustrap;
      spyOn(focustrap, 'deactivate').and.callThrough();
      expect(_modal["default"].getInstance(modalEl)).toEqual(modal);
      spyOn(_eventHandler["default"], 'off');
      modal.dispose();
      expect(_modal["default"].getInstance(modalEl)).toBeNull();
      expect(_eventHandler["default"].off).toHaveBeenCalledTimes(3);
      expect(focustrap.deactivate).toHaveBeenCalled();
    });
  });
  describe('handleUpdate', function () {
    it('should call adjust dialog', function () {
      fixtureEl.innerHTML = '<div id="exampleModal" class="modal"><div class="modal-dialog"></div></div>';
      var modalEl = fixtureEl.querySelector('.modal');
      var modal = new _modal["default"](modalEl);
      spyOn(modal, '_adjustDialog');
      modal.handleUpdate();
      expect(modal._adjustDialog).toHaveBeenCalled();
    });
  });
  describe('data-api', function () {
    it('should toggle modal', function (done) {
      fixtureEl.innerHTML = ['<button type="button" data-bs-toggle="modal" data-bs-target="#exampleModal"></button>', '<div id="exampleModal" class="modal"><div class="modal-dialog"></div></div>'].join('');
      var modalEl = fixtureEl.querySelector('.modal');
      var trigger = fixtureEl.querySelector('[data-bs-toggle="modal"]');
      modalEl.addEventListener('shown.bs.modal', function () {
        expect(modalEl.getAttribute('aria-modal')).toEqual('true');
        expect(modalEl.getAttribute('role')).toEqual('dialog');
        expect(modalEl.getAttribute('aria-hidden')).toBeNull();
        expect(modalEl.style.display).toEqual('block');
        expect(document.querySelector('.modal-backdrop')).not.toBeNull();
        setTimeout(function () {
          return trigger.click();
        }, 10);
      });
      modalEl.addEventListener('hidden.bs.modal', function () {
        expect(modalEl.getAttribute('aria-modal')).toBeNull();
        expect(modalEl.getAttribute('role')).toBeNull();
        expect(modalEl.getAttribute('aria-hidden')).toEqual('true');
        expect(modalEl.style.display).toEqual('none');
        expect(document.querySelector('.modal-backdrop')).toBeNull();
        done();
      });
      trigger.click();
    });
    it('should not recreate a new modal', function (done) {
      fixtureEl.innerHTML = ['<button type="button" data-bs-toggle="modal" data-bs-target="#exampleModal"></button>', '<div id="exampleModal" class="modal"><div class="modal-dialog"></div></div>'].join('');
      var modalEl = fixtureEl.querySelector('.modal');
      var modal = new _modal["default"](modalEl);
      var trigger = fixtureEl.querySelector('[data-bs-toggle="modal"]');
      spyOn(modal, 'show').and.callThrough();
      modalEl.addEventListener('shown.bs.modal', function () {
        expect(modal.show).toHaveBeenCalled();
        done();
      });
      trigger.click();
    });
    it('should prevent default when the trigger is <a> or <area>', function (done) {
      fixtureEl.innerHTML = ['<a data-bs-toggle="modal" href="#" data-bs-target="#exampleModal"></a>', '<div id="exampleModal" class="modal"><div class="modal-dialog"></div></div>'].join('');
      var modalEl = fixtureEl.querySelector('.modal');
      var trigger = fixtureEl.querySelector('[data-bs-toggle="modal"]');
      spyOn(Event.prototype, 'preventDefault').and.callThrough();
      modalEl.addEventListener('shown.bs.modal', function () {
        expect(modalEl.getAttribute('aria-modal')).toEqual('true');
        expect(modalEl.getAttribute('role')).toEqual('dialog');
        expect(modalEl.getAttribute('aria-hidden')).toBeNull();
        expect(modalEl.style.display).toEqual('block');
        expect(document.querySelector('.modal-backdrop')).not.toBeNull();
        expect(Event.prototype.preventDefault).toHaveBeenCalled();
        done();
      });
      trigger.click();
    });
    it('should focus the trigger on hide', function (done) {
      fixtureEl.innerHTML = ['<a data-bs-toggle="modal" href="#" data-bs-target="#exampleModal"></a>', '<div id="exampleModal" class="modal"><div class="modal-dialog"></div></div>'].join('');
      var modalEl = fixtureEl.querySelector('.modal');
      var trigger = fixtureEl.querySelector('[data-bs-toggle="modal"]');
      spyOn(trigger, 'focus');
      modalEl.addEventListener('shown.bs.modal', function () {
        var modal = _modal["default"].getInstance(modalEl);

        modal.hide();
      });

      var hideListener = function hideListener() {
        setTimeout(function () {
          expect(trigger.focus).toHaveBeenCalled();
          done();
        }, 20);
      };

      modalEl.addEventListener('hidden.bs.modal', function () {
        hideListener();
      });
      trigger.click();
    });
    it('should not prevent default when a click occurred on data-bs-dismiss="modal" where tagName is DIFFERENT than <a> or <area>', function (done) {
      fixtureEl.innerHTML = ['<div class="modal">', '  <div class="modal-dialog">', '    <button type="button" data-bs-dismiss="modal"></button>', '  </div>', '</div>'].join('');
      var modalEl = fixtureEl.querySelector('.modal');
      var btnClose = fixtureEl.querySelector('button[data-bs-dismiss="modal"]');
      var modal = new _modal["default"](modalEl);
      spyOn(Event.prototype, 'preventDefault').and.callThrough();
      modalEl.addEventListener('shown.bs.modal', function () {
        btnClose.click();
      });
      modalEl.addEventListener('hidden.bs.modal', function () {
        expect(Event.prototype.preventDefault).not.toHaveBeenCalled();
        done();
      });
      modal.show();
    });
    it('should prevent default when a click occurred on data-bs-dismiss="modal" where tagName is <a> or <area>', function (done) {
      fixtureEl.innerHTML = ['<div class="modal">', '  <div class="modal-dialog">', '    <a type="button" data-bs-dismiss="modal"></a>', '  </div>', '</div>'].join('');
      var modalEl = fixtureEl.querySelector('.modal');
      var btnClose = fixtureEl.querySelector('a[data-bs-dismiss="modal"]');
      var modal = new _modal["default"](modalEl);
      spyOn(Event.prototype, 'preventDefault').and.callThrough();
      modalEl.addEventListener('shown.bs.modal', function () {
        btnClose.click();
      });
      modalEl.addEventListener('hidden.bs.modal', function () {
        expect(Event.prototype.preventDefault).toHaveBeenCalled();
        done();
      });
      modal.show();
    });
    it('should not focus the trigger if the modal is not visible', function (done) {
      fixtureEl.innerHTML = ['<a data-bs-toggle="modal" href="#" data-bs-target="#exampleModal" style="display: none;"></a>', '<div id="exampleModal" class="modal" style="display: none;"><div class="modal-dialog"></div></div>'].join('');
      var modalEl = fixtureEl.querySelector('.modal');
      var trigger = fixtureEl.querySelector('[data-bs-toggle="modal"]');
      spyOn(trigger, 'focus');
      modalEl.addEventListener('shown.bs.modal', function () {
        var modal = _modal["default"].getInstance(modalEl);

        modal.hide();
      });

      var hideListener = function hideListener() {
        setTimeout(function () {
          expect(trigger.focus).not.toHaveBeenCalled();
          done();
        }, 20);
      };

      modalEl.addEventListener('hidden.bs.modal', function () {
        hideListener();
      });
      trigger.click();
    });
    it('should not focus the trigger if the modal is not shown', function (done) {
      fixtureEl.innerHTML = ['<a data-bs-toggle="modal" href="#" data-bs-target="#exampleModal"></a>', '<div id="exampleModal" class="modal"><div class="modal-dialog"></div></div>'].join('');
      var modalEl = fixtureEl.querySelector('.modal');
      var trigger = fixtureEl.querySelector('[data-bs-toggle="modal"]');
      spyOn(trigger, 'focus');

      var showListener = function showListener() {
        setTimeout(function () {
          expect(trigger.focus).not.toHaveBeenCalled();
          done();
        }, 10);
      };

      modalEl.addEventListener('show.bs.modal', function (event) {
        event.preventDefault();
        showListener();
      });
      trigger.click();
    });
    it('should call hide first, if another modal is open', function (done) {
      fixtureEl.innerHTML = ['<button data-bs-toggle="modal"  data-bs-target="#modal2"></button>', '<div id="modal1" class="modal fade"><div class="modal-dialog"></div></div>', '<div id="modal2" class="modal"><div class="modal-dialog"></div></div>'].join('');
      var trigger2 = fixtureEl.querySelector('button');
      var modalEl1 = document.querySelector('#modal1');
      var modalEl2 = document.querySelector('#modal2');
      var modal1 = new _modal["default"](modalEl1);
      modalEl1.addEventListener('shown.bs.modal', function () {
        trigger2.click();
      });
      modalEl1.addEventListener('hidden.bs.modal', function () {
        expect(_modal["default"].getInstance(modalEl2)).not.toBeNull();
        expect(modalEl2.classList.contains('show')).toBeTrue();
        done();
      });
      modal1.show();
    });
  });
  describe('jQueryInterface', function () {
    it('should create a modal', function () {
      fixtureEl.innerHTML = '<div class="modal"><div class="modal-dialog"></div></div>';
      var div = fixtureEl.querySelector('div');
      _fixture.jQueryMock.fn.modal = _modal["default"].jQueryInterface;
      _fixture.jQueryMock.elements = [div];

      _fixture.jQueryMock.fn.modal.call(_fixture.jQueryMock);

      expect(_modal["default"].getInstance(div)).not.toBeNull();
    });
    it('should create a modal with given config', function () {
      fixtureEl.innerHTML = '<div class="modal"><div class="modal-dialog"></div></div>';
      var div = fixtureEl.querySelector('div');
      _fixture.jQueryMock.fn.modal = _modal["default"].jQueryInterface;
      _fixture.jQueryMock.elements = [div];

      _fixture.jQueryMock.fn.modal.call(_fixture.jQueryMock, {
        keyboard: false
      });

      spyOn(_modal["default"].prototype, 'constructor');
      expect(_modal["default"].prototype.constructor).not.toHaveBeenCalledWith(div, {
        keyboard: false
      });

      var modal = _modal["default"].getInstance(div);

      expect(modal).not.toBeNull();
      expect(modal._config.keyboard).toBe(false);
    });
    it('should not re create a modal', function () {
      fixtureEl.innerHTML = '<div class="modal"><div class="modal-dialog"></div></div>';
      var div = fixtureEl.querySelector('div');
      var modal = new _modal["default"](div);
      _fixture.jQueryMock.fn.modal = _modal["default"].jQueryInterface;
      _fixture.jQueryMock.elements = [div];

      _fixture.jQueryMock.fn.modal.call(_fixture.jQueryMock);

      expect(_modal["default"].getInstance(div)).toEqual(modal);
    });
    it('should throw error on undefined method', function () {
      fixtureEl.innerHTML = '<div class="modal"><div class="modal-dialog"></div></div>';
      var div = fixtureEl.querySelector('div');
      var action = 'undefinedMethod';
      _fixture.jQueryMock.fn.modal = _modal["default"].jQueryInterface;
      _fixture.jQueryMock.elements = [div];
      expect(function () {
        _fixture.jQueryMock.fn.modal.call(_fixture.jQueryMock, action);
      }).toThrowError(TypeError, "No method named \"".concat(action, "\""));
    });
    it('should call show method', function () {
      fixtureEl.innerHTML = '<div class="modal"><div class="modal-dialog"></div></div>';
      var div = fixtureEl.querySelector('div');
      var modal = new _modal["default"](div);
      _fixture.jQueryMock.fn.modal = _modal["default"].jQueryInterface;
      _fixture.jQueryMock.elements = [div];
      spyOn(modal, 'show');

      _fixture.jQueryMock.fn.modal.call(_fixture.jQueryMock, 'show');

      expect(modal.show).toHaveBeenCalled();
    });
    it('should not call show method', function () {
      fixtureEl.innerHTML = '<div class="modal" data-bs-show="false"><div class="modal-dialog"></div></div>';
      var div = fixtureEl.querySelector('div');
      _fixture.jQueryMock.fn.modal = _modal["default"].jQueryInterface;
      _fixture.jQueryMock.elements = [div];
      spyOn(_modal["default"].prototype, 'show');

      _fixture.jQueryMock.fn.modal.call(_fixture.jQueryMock);

      expect(_modal["default"].prototype.show).not.toHaveBeenCalled();
    });
  });
  describe('getInstance', function () {
    it('should return modal instance', function () {
      fixtureEl.innerHTML = '<div class="modal"><div class="modal-dialog"></div></div>';
      var div = fixtureEl.querySelector('div');
      var modal = new _modal["default"](div);
      expect(_modal["default"].getInstance(div)).toEqual(modal);
      expect(_modal["default"].getInstance(div)).toBeInstanceOf(_modal["default"]);
    });
    it('should return null when there is no modal instance', function () {
      fixtureEl.innerHTML = '<div class="modal"><div class="modal-dialog"></div></div>';
      var div = fixtureEl.querySelector('div');
      expect(_modal["default"].getInstance(div)).toBeNull();
    });
  });
  describe('getOrCreateInstance', function () {
    it('should return modal instance', function () {
      fixtureEl.innerHTML = '<div></div>';
      var div = fixtureEl.querySelector('div');
      var modal = new _modal["default"](div);
      expect(_modal["default"].getOrCreateInstance(div)).toEqual(modal);
      expect(_modal["default"].getInstance(div)).toEqual(_modal["default"].getOrCreateInstance(div, {}));
      expect(_modal["default"].getOrCreateInstance(div)).toBeInstanceOf(_modal["default"]);
    });
    it('should return new instance when there is no modal instance', function () {
      fixtureEl.innerHTML = '<div></div>';
      var div = fixtureEl.querySelector('div');
      expect(_modal["default"].getInstance(div)).toEqual(null);
      expect(_modal["default"].getOrCreateInstance(div)).toBeInstanceOf(_modal["default"]);
    });
    it('should return new instance when there is no modal instance with given configuration', function () {
      fixtureEl.innerHTML = '<div></div>';
      var div = fixtureEl.querySelector('div');
      expect(_modal["default"].getInstance(div)).toEqual(null);

      var modal = _modal["default"].getOrCreateInstance(div, {
        backdrop: true
      });

      expect(modal).toBeInstanceOf(_modal["default"]);
      expect(modal._config.backdrop).toEqual(true);
    });
    it('should return the instance when exists without given configuration', function () {
      fixtureEl.innerHTML = '<div></div>';
      var div = fixtureEl.querySelector('div');
      var modal = new _modal["default"](div, {
        backdrop: true
      });
      expect(_modal["default"].getInstance(div)).toEqual(modal);

      var modal2 = _modal["default"].getOrCreateInstance(div, {
        backdrop: false
      });

      expect(modal).toBeInstanceOf(_modal["default"]);
      expect(modal2).toEqual(modal);
      expect(modal2._config.backdrop).toEqual(true);
    });
  });
});
"use strict";

var _offcanvas = _interopRequireDefault(require("../../src/offcanvas"));

var _eventHandler = _interopRequireDefault(require("../../src/dom/event-handler"));

var _fixture = require("../helpers/fixture");

var _util = require("../../src/util");

var _scrollbar = _interopRequireDefault(require("../../src/util/scrollbar"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

describe('Offcanvas', function () {
  var fixtureEl;
  beforeAll(function () {
    fixtureEl = (0, _fixture.getFixture)();
  });
  afterEach(function () {
    (0, _fixture.clearFixture)();
    document.body.classList.remove('offcanvas-open');
    (0, _fixture.clearBodyAndDocument)();
  });
  beforeEach(function () {
    (0, _fixture.clearBodyAndDocument)();
  });
  describe('VERSION', function () {
    it('should return plugin version', function () {
      expect(_offcanvas["default"].VERSION).toEqual(jasmine.any(String));
    });
  });
  describe('Default', function () {
    it('should return plugin default config', function () {
      expect(_offcanvas["default"].Default).toEqual(jasmine.any(Object));
    });
  });
  describe('DATA_KEY', function () {
    it('should return plugin data key', function () {
      expect(_offcanvas["default"].DATA_KEY).toEqual('bs.offcanvas');
    });
  });
  describe('constructor', function () {
    it('should call hide when a element with data-bs-dismiss="offcanvas" is clicked', function () {
      fixtureEl.innerHTML = ['<div class="offcanvas">', '  <a href="#" data-bs-dismiss="offcanvas">Close</a>', '</div>'].join('');
      var offCanvasEl = fixtureEl.querySelector('.offcanvas');
      var closeEl = fixtureEl.querySelector('a');
      var offCanvas = new _offcanvas["default"](offCanvasEl);
      spyOn(offCanvas, 'hide');
      closeEl.click();
      expect(offCanvas._config.keyboard).toBe(true);
      expect(offCanvas.hide).toHaveBeenCalled();
    });
    it('should hide if esc is pressed', function () {
      fixtureEl.innerHTML = '<div class="offcanvas"></div>';
      var offCanvasEl = fixtureEl.querySelector('.offcanvas');
      var offCanvas = new _offcanvas["default"](offCanvasEl);
      var keyDownEsc = (0, _fixture.createEvent)('keydown');
      keyDownEsc.key = 'Escape';
      spyOn(offCanvas, 'hide');
      offCanvasEl.dispatchEvent(keyDownEsc);
      expect(offCanvas.hide).toHaveBeenCalled();
    });
    it('should not hide if esc is not pressed', function () {
      fixtureEl.innerHTML = '<div class="offcanvas"></div>';
      var offCanvasEl = fixtureEl.querySelector('.offcanvas');
      var offCanvas = new _offcanvas["default"](offCanvasEl);
      var keydownTab = (0, _fixture.createEvent)('keydown');
      keydownTab.key = 'Tab';
      spyOn(offCanvas, 'hide');
      document.dispatchEvent(keydownTab);
      expect(offCanvas.hide).not.toHaveBeenCalled();
    });
    it('should not hide if esc is pressed but with keyboard = false', function () {
      fixtureEl.innerHTML = '<div class="offcanvas"></div>';
      var offCanvasEl = fixtureEl.querySelector('.offcanvas');
      var offCanvas = new _offcanvas["default"](offCanvasEl, {
        keyboard: false
      });
      var keyDownEsc = (0, _fixture.createEvent)('keydown');
      keyDownEsc.key = 'Escape';
      spyOn(offCanvas, 'hide');
      document.dispatchEvent(keyDownEsc);
      expect(offCanvas._config.keyboard).toBe(false);
      expect(offCanvas.hide).not.toHaveBeenCalled();
    });
  });
  describe('config', function () {
    it('should have default values', function () {
      fixtureEl.innerHTML = ['<div class="offcanvas">', '</div>'].join('');
      var offCanvasEl = fixtureEl.querySelector('.offcanvas');
      var offCanvas = new _offcanvas["default"](offCanvasEl);
      expect(offCanvas._config.backdrop).toEqual(true);
      expect(offCanvas._backdrop._config.isVisible).toEqual(true);
      expect(offCanvas._config.keyboard).toEqual(true);
      expect(offCanvas._config.scroll).toEqual(false);
    });
    it('should read data attributes and override default config', function () {
      fixtureEl.innerHTML = ['<div class="offcanvas" data-bs-scroll="true" data-bs-backdrop="false"  data-bs-keyboard="false">', '</div>'].join('');
      var offCanvasEl = fixtureEl.querySelector('.offcanvas');
      var offCanvas = new _offcanvas["default"](offCanvasEl);
      expect(offCanvas._config.backdrop).toEqual(false);
      expect(offCanvas._backdrop._config.isVisible).toEqual(false);
      expect(offCanvas._config.keyboard).toEqual(false);
      expect(offCanvas._config.scroll).toEqual(true);
    });
    it('given a config object must override data attributes', function () {
      fixtureEl.innerHTML = ['<div class="offcanvas" data-bs-scroll="true" data-bs-backdrop="false"  data-bs-keyboard="false">', '</div>'].join('');
      var offCanvasEl = fixtureEl.querySelector('.offcanvas');
      var offCanvas = new _offcanvas["default"](offCanvasEl, {
        backdrop: true,
        keyboard: true,
        scroll: false
      });
      expect(offCanvas._config.backdrop).toEqual(true);
      expect(offCanvas._config.keyboard).toEqual(true);
      expect(offCanvas._config.scroll).toEqual(false);
    });
  });
  describe('options', function () {
    it('if scroll is enabled, should allow body to scroll while offcanvas is open', function (done) {
      fixtureEl.innerHTML = '<div class="offcanvas"></div>';
      spyOn(_scrollbar["default"].prototype, 'hide').and.callThrough();
      spyOn(_scrollbar["default"].prototype, 'reset').and.callThrough();
      var offCanvasEl = fixtureEl.querySelector('.offcanvas');
      var offCanvas = new _offcanvas["default"](offCanvasEl, {
        scroll: true
      });
      offCanvasEl.addEventListener('shown.bs.offcanvas', function () {
        expect(_scrollbar["default"].prototype.hide).not.toHaveBeenCalled();
        offCanvas.hide();
      });
      offCanvasEl.addEventListener('hidden.bs.offcanvas', function () {
        expect(_scrollbar["default"].prototype.reset).not.toHaveBeenCalled();
        done();
      });
      offCanvas.show();
    });
    it('if scroll is disabled, should call ScrollBarHelper to handle scrollBar on body', function (done) {
      fixtureEl.innerHTML = '<div class="offcanvas"></div>';
      spyOn(_scrollbar["default"].prototype, 'hide').and.callThrough();
      spyOn(_scrollbar["default"].prototype, 'reset').and.callThrough();
      var offCanvasEl = fixtureEl.querySelector('.offcanvas');
      var offCanvas = new _offcanvas["default"](offCanvasEl, {
        scroll: false
      });
      offCanvasEl.addEventListener('shown.bs.offcanvas', function () {
        expect(_scrollbar["default"].prototype.hide).toHaveBeenCalled();
        offCanvas.hide();
      });
      offCanvasEl.addEventListener('hidden.bs.offcanvas', function () {
        expect(_scrollbar["default"].prototype.reset).toHaveBeenCalled();
        done();
      });
      offCanvas.show();
    });
    it('should hide a shown element if user click on backdrop', function (done) {
      fixtureEl.innerHTML = '<div class="offcanvas"></div>';
      var offCanvasEl = fixtureEl.querySelector('div');
      var offCanvas = new _offcanvas["default"](offCanvasEl, {
        backdrop: true
      });
      var clickEvent = document.createEvent('MouseEvents');
      clickEvent.initEvent('mousedown', true, true);
      spyOn(offCanvas._backdrop._config, 'clickCallback').and.callThrough();
      offCanvasEl.addEventListener('shown.bs.offcanvas', function () {
        expect(_typeof(offCanvas._backdrop._config.clickCallback)).toBe('function');

        offCanvas._backdrop._getElement().dispatchEvent(clickEvent);
      });
      offCanvasEl.addEventListener('hidden.bs.offcanvas', function () {
        expect(offCanvas._backdrop._config.clickCallback).toHaveBeenCalled();
        done();
      });
      offCanvas.show();
    });
    it('should not trap focus if scroll is allowed', function (done) {
      fixtureEl.innerHTML = '<div class="offcanvas"></div>';
      var offCanvasEl = fixtureEl.querySelector('.offcanvas');
      var offCanvas = new _offcanvas["default"](offCanvasEl, {
        scroll: true
      });
      spyOn(offCanvas._focustrap, 'activate').and.callThrough();
      offCanvasEl.addEventListener('shown.bs.offcanvas', function () {
        expect(offCanvas._focustrap.activate).not.toHaveBeenCalled();
        done();
      });
      offCanvas.show();
    });
  });
  describe('toggle', function () {
    it('should call show method if show class is not present', function () {
      fixtureEl.innerHTML = '<div class="offcanvas"></div>';
      var offCanvasEl = fixtureEl.querySelector('.offcanvas');
      var offCanvas = new _offcanvas["default"](offCanvasEl);
      spyOn(offCanvas, 'show');
      offCanvas.toggle();
      expect(offCanvas.show).toHaveBeenCalled();
    });
    it('should call hide method if show class is present', function () {
      fixtureEl.innerHTML = '<div class="offcanvas"></div>';
      var offCanvasEl = fixtureEl.querySelector('.offcanvas');
      var offCanvas = new _offcanvas["default"](offCanvasEl);
      offCanvas.show();
      expect(offCanvasEl.classList.contains('show')).toBe(true);
      spyOn(offCanvas, 'hide');
      offCanvas.toggle();
      expect(offCanvas.hide).toHaveBeenCalled();
    });
  });
  describe('show', function () {
    it('should do nothing if already shown', function () {
      fixtureEl.innerHTML = '<div class="offcanvas show"></div>';
      var offCanvasEl = fixtureEl.querySelector('div');
      var offCanvas = new _offcanvas["default"](offCanvasEl);
      offCanvas.show();
      expect(offCanvasEl.classList.contains('show')).toBe(true);
      spyOn(offCanvas._backdrop, 'show').and.callThrough();
      spyOn(_eventHandler["default"], 'trigger').and.callThrough();
      offCanvas.show();
      expect(_eventHandler["default"].trigger).not.toHaveBeenCalled();
      expect(offCanvas._backdrop.show).not.toHaveBeenCalled();
    });
    it('should show a hidden element', function (done) {
      fixtureEl.innerHTML = '<div class="offcanvas"></div>';
      var offCanvasEl = fixtureEl.querySelector('div');
      var offCanvas = new _offcanvas["default"](offCanvasEl);
      spyOn(offCanvas._backdrop, 'show').and.callThrough();
      offCanvasEl.addEventListener('shown.bs.offcanvas', function () {
        expect(offCanvasEl.classList.contains('show')).toEqual(true);
        expect(offCanvas._backdrop.show).toHaveBeenCalled();
        done();
      });
      offCanvas.show();
    });
    it('should not fire shown when show is prevented', function (done) {
      fixtureEl.innerHTML = '<div class="offcanvas"></div>';
      var offCanvasEl = fixtureEl.querySelector('div');
      var offCanvas = new _offcanvas["default"](offCanvasEl);
      spyOn(offCanvas._backdrop, 'show').and.callThrough();

      var expectEnd = function expectEnd() {
        setTimeout(function () {
          expect(offCanvas._backdrop.show).not.toHaveBeenCalled();
          done();
        }, 10);
      };

      offCanvasEl.addEventListener('show.bs.offcanvas', function (event) {
        event.preventDefault();
        expectEnd();
      });
      offCanvasEl.addEventListener('shown.bs.offcanvas', function () {
        throw new Error('should not fire shown event');
      });
      offCanvas.show();
    });
    it('on window load, should make visible an offcanvas element, if its markup contains class "show"', function (done) {
      fixtureEl.innerHTML = '<div class="offcanvas show"></div>';
      var offCanvasEl = fixtureEl.querySelector('div');
      spyOn(_offcanvas["default"].prototype, 'show').and.callThrough();
      offCanvasEl.addEventListener('shown.bs.offcanvas', function () {
        done();
      });
      window.dispatchEvent((0, _fixture.createEvent)('load'));

      var instance = _offcanvas["default"].getInstance(offCanvasEl);

      expect(instance).not.toBeNull();
      expect(_offcanvas["default"].prototype.show).toHaveBeenCalled();
    });
    it('should trap focus', function (done) {
      fixtureEl.innerHTML = '<div class="offcanvas"></div>';
      var offCanvasEl = fixtureEl.querySelector('.offcanvas');
      var offCanvas = new _offcanvas["default"](offCanvasEl);
      spyOn(offCanvas._focustrap, 'activate').and.callThrough();
      offCanvasEl.addEventListener('shown.bs.offcanvas', function () {
        expect(offCanvas._focustrap.activate).toHaveBeenCalled();
        done();
      });
      offCanvas.show();
    });
  });
  describe('hide', function () {
    it('should do nothing if already shown', function () {
      fixtureEl.innerHTML = '<div class="offcanvas"></div>';
      spyOn(_eventHandler["default"], 'trigger').and.callThrough();
      var offCanvasEl = fixtureEl.querySelector('div');
      var offCanvas = new _offcanvas["default"](offCanvasEl);
      spyOn(offCanvas._backdrop, 'hide').and.callThrough();
      offCanvas.hide();
      expect(offCanvas._backdrop.hide).not.toHaveBeenCalled();
      expect(_eventHandler["default"].trigger).not.toHaveBeenCalled();
    });
    it('should hide a shown element', function (done) {
      fixtureEl.innerHTML = '<div class="offcanvas"></div>';
      var offCanvasEl = fixtureEl.querySelector('div');
      var offCanvas = new _offcanvas["default"](offCanvasEl);
      spyOn(offCanvas._backdrop, 'hide').and.callThrough();
      offCanvas.show();
      offCanvasEl.addEventListener('hidden.bs.offcanvas', function () {
        expect(offCanvasEl.classList.contains('show')).toEqual(false);
        expect(offCanvas._backdrop.hide).toHaveBeenCalled();
        done();
      });
      offCanvas.hide();
    });
    it('should not fire hidden when hide is prevented', function (done) {
      fixtureEl.innerHTML = '<div class="offcanvas"></div>';
      var offCanvasEl = fixtureEl.querySelector('div');
      var offCanvas = new _offcanvas["default"](offCanvasEl);
      spyOn(offCanvas._backdrop, 'hide').and.callThrough();
      offCanvas.show();

      var expectEnd = function expectEnd() {
        setTimeout(function () {
          expect(offCanvas._backdrop.hide).not.toHaveBeenCalled();
          done();
        }, 10);
      };

      offCanvasEl.addEventListener('hide.bs.offcanvas', function (event) {
        event.preventDefault();
        expectEnd();
      });
      offCanvasEl.addEventListener('hidden.bs.offcanvas', function () {
        throw new Error('should not fire hidden event');
      });
      offCanvas.hide();
    });
    it('should release focus trap', function (done) {
      fixtureEl.innerHTML = '<div class="offcanvas"></div>';
      var offCanvasEl = fixtureEl.querySelector('div');
      var offCanvas = new _offcanvas["default"](offCanvasEl);
      spyOn(offCanvas._focustrap, 'deactivate').and.callThrough();
      offCanvas.show();
      offCanvasEl.addEventListener('hidden.bs.offcanvas', function () {
        expect(offCanvas._focustrap.deactivate).toHaveBeenCalled();
        done();
      });
      offCanvas.hide();
    });
  });
  describe('dispose', function () {
    it('should dispose an offcanvas', function () {
      fixtureEl.innerHTML = '<div class="offcanvas"></div>';
      var offCanvasEl = fixtureEl.querySelector('div');
      var offCanvas = new _offcanvas["default"](offCanvasEl);
      var backdrop = offCanvas._backdrop;
      spyOn(backdrop, 'dispose').and.callThrough();
      var focustrap = offCanvas._focustrap;
      spyOn(focustrap, 'deactivate').and.callThrough();
      expect(_offcanvas["default"].getInstance(offCanvasEl)).toEqual(offCanvas);
      spyOn(_eventHandler["default"], 'off');
      offCanvas.dispose();
      expect(backdrop.dispose).toHaveBeenCalled();
      expect(offCanvas._backdrop).toBeNull();
      expect(focustrap.deactivate).toHaveBeenCalled();
      expect(offCanvas._focustrap).toBeNull();
      expect(_offcanvas["default"].getInstance(offCanvasEl)).toEqual(null);
    });
  });
  describe('data-api', function () {
    it('should not prevent event for input', function (done) {
      fixtureEl.innerHTML = ['<input type="checkbox" data-bs-toggle="offcanvas" data-bs-target="#offcanvasdiv1" />', '<div id="offcanvasdiv1" class="offcanvas"></div>'].join('');
      var target = fixtureEl.querySelector('input');
      var offCanvasEl = fixtureEl.querySelector('#offcanvasdiv1');
      offCanvasEl.addEventListener('shown.bs.offcanvas', function () {
        expect(offCanvasEl.classList.contains('show')).toEqual(true);
        expect(target.checked).toEqual(true);
        done();
      });
      target.click();
    });
    it('should not call toggle on disabled elements', function () {
      fixtureEl.innerHTML = ['<a href="#" data-bs-toggle="offcanvas" data-bs-target="#offcanvasdiv1" class="disabled"></a>', '<div id="offcanvasdiv1" class="offcanvas"></div>'].join('');
      var target = fixtureEl.querySelector('a');
      spyOn(_offcanvas["default"].prototype, 'toggle');
      target.click();
      expect(_offcanvas["default"].prototype.toggle).not.toHaveBeenCalled();
    });
    it('should call hide first, if another offcanvas is open', function (done) {
      fixtureEl.innerHTML = ['<button id="btn2" data-bs-toggle="offcanvas" data-bs-target="#offcanvas2" ></button>', '<div id="offcanvas1" class="offcanvas"></div>', '<div id="offcanvas2" class="offcanvas"></div>'].join('');
      var trigger2 = fixtureEl.querySelector('#btn2');
      var offcanvasEl1 = document.querySelector('#offcanvas1');
      var offcanvasEl2 = document.querySelector('#offcanvas2');
      var offcanvas1 = new _offcanvas["default"](offcanvasEl1);
      offcanvasEl1.addEventListener('shown.bs.offcanvas', function () {
        trigger2.click();
      });
      offcanvasEl1.addEventListener('hidden.bs.offcanvas', function () {
        expect(_offcanvas["default"].getInstance(offcanvasEl2)).not.toBeNull();
        done();
      });
      offcanvas1.show();
    });
    it('should focus on trigger element after closing offcanvas', function (done) {
      fixtureEl.innerHTML = ['<button id="btn" data-bs-toggle="offcanvas" data-bs-target="#offcanvas" ></button>', '<div id="offcanvas" class="offcanvas"></div>'].join('');
      var trigger = fixtureEl.querySelector('#btn');
      var offcanvasEl = fixtureEl.querySelector('#offcanvas');
      var offcanvas = new _offcanvas["default"](offcanvasEl);
      spyOn(trigger, 'focus');
      offcanvasEl.addEventListener('shown.bs.offcanvas', function () {
        offcanvas.hide();
      });
      offcanvasEl.addEventListener('hidden.bs.offcanvas', function () {
        setTimeout(function () {
          expect(trigger.focus).toHaveBeenCalled();
          done();
        }, 5);
      });
      trigger.click();
    });
    it('should not focus on trigger element after closing offcanvas, if it is not visible', function (done) {
      fixtureEl.innerHTML = ['<button id="btn" data-bs-toggle="offcanvas" data-bs-target="#offcanvas" ></button>', '<div id="offcanvas" class="offcanvas"></div>'].join('');
      var trigger = fixtureEl.querySelector('#btn');
      var offcanvasEl = fixtureEl.querySelector('#offcanvas');
      var offcanvas = new _offcanvas["default"](offcanvasEl);
      spyOn(trigger, 'focus');
      offcanvasEl.addEventListener('shown.bs.offcanvas', function () {
        trigger.style.display = 'none';
        offcanvas.hide();
      });
      offcanvasEl.addEventListener('hidden.bs.offcanvas', function () {
        setTimeout(function () {
          expect((0, _util.isVisible)(trigger)).toBe(false);
          expect(trigger.focus).not.toHaveBeenCalled();
          done();
        }, 5);
      });
      trigger.click();
    });
  });
  describe('jQueryInterface', function () {
    it('should create an offcanvas', function () {
      fixtureEl.innerHTML = '<div></div>';
      var div = fixtureEl.querySelector('div');
      _fixture.jQueryMock.fn.offcanvas = _offcanvas["default"].jQueryInterface;
      _fixture.jQueryMock.elements = [div];

      _fixture.jQueryMock.fn.offcanvas.call(_fixture.jQueryMock);

      expect(_offcanvas["default"].getInstance(div)).not.toBeNull();
    });
    it('should not re create an offcanvas', function () {
      fixtureEl.innerHTML = '<div></div>';
      var div = fixtureEl.querySelector('div');
      var offCanvas = new _offcanvas["default"](div);
      _fixture.jQueryMock.fn.offcanvas = _offcanvas["default"].jQueryInterface;
      _fixture.jQueryMock.elements = [div];

      _fixture.jQueryMock.fn.offcanvas.call(_fixture.jQueryMock);

      expect(_offcanvas["default"].getInstance(div)).toEqual(offCanvas);
    });
    it('should throw error on undefined method', function () {
      fixtureEl.innerHTML = '<div></div>';
      var div = fixtureEl.querySelector('div');
      var action = 'undefinedMethod';
      _fixture.jQueryMock.fn.offcanvas = _offcanvas["default"].jQueryInterface;
      _fixture.jQueryMock.elements = [div];
      expect(function () {
        _fixture.jQueryMock.fn.offcanvas.call(_fixture.jQueryMock, action);
      }).toThrowError(TypeError, "No method named \"".concat(action, "\""));
    });
    it('should throw error on protected method', function () {
      fixtureEl.innerHTML = '<div></div>';
      var div = fixtureEl.querySelector('div');
      var action = '_getConfig';
      _fixture.jQueryMock.fn.offcanvas = _offcanvas["default"].jQueryInterface;
      _fixture.jQueryMock.elements = [div];
      expect(function () {
        _fixture.jQueryMock.fn.offcanvas.call(_fixture.jQueryMock, action);
      }).toThrowError(TypeError, "No method named \"".concat(action, "\""));
    });
    it('should throw error if method "constructor" is being called', function () {
      fixtureEl.innerHTML = '<div></div>';
      var div = fixtureEl.querySelector('div');
      var action = 'constructor';
      _fixture.jQueryMock.fn.offcanvas = _offcanvas["default"].jQueryInterface;
      _fixture.jQueryMock.elements = [div];
      expect(function () {
        _fixture.jQueryMock.fn.offcanvas.call(_fixture.jQueryMock, action);
      }).toThrowError(TypeError, "No method named \"".concat(action, "\""));
    });
    it('should call offcanvas method', function () {
      fixtureEl.innerHTML = '<div></div>';
      var div = fixtureEl.querySelector('div');
      spyOn(_offcanvas["default"].prototype, 'show');
      _fixture.jQueryMock.fn.offcanvas = _offcanvas["default"].jQueryInterface;
      _fixture.jQueryMock.elements = [div];

      _fixture.jQueryMock.fn.offcanvas.call(_fixture.jQueryMock, 'show');

      expect(_offcanvas["default"].prototype.show).toHaveBeenCalled();
    });
    it('should create a offcanvas with given config', function () {
      fixtureEl.innerHTML = '<div></div>';
      var div = fixtureEl.querySelector('div');
      _fixture.jQueryMock.fn.offcanvas = _offcanvas["default"].jQueryInterface;
      _fixture.jQueryMock.elements = [div];

      _fixture.jQueryMock.fn.offcanvas.call(_fixture.jQueryMock, {
        scroll: true
      });

      var offcanvas = _offcanvas["default"].getInstance(div);

      expect(offcanvas).not.toBeNull();
      expect(offcanvas._config.scroll).toBe(true);
    });
  });
  describe('getInstance', function () {
    it('should return offcanvas instance', function () {
      fixtureEl.innerHTML = '<div></div>';
      var div = fixtureEl.querySelector('div');
      var offCanvas = new _offcanvas["default"](div);
      expect(_offcanvas["default"].getInstance(div)).toEqual(offCanvas);
      expect(_offcanvas["default"].getInstance(div)).toBeInstanceOf(_offcanvas["default"]);
    });
    it('should return null when there is no offcanvas instance', function () {
      fixtureEl.innerHTML = '<div></div>';
      var div = fixtureEl.querySelector('div');
      expect(_offcanvas["default"].getInstance(div)).toBeNull();
    });
  });
  describe('getOrCreateInstance', function () {
    it('should return offcanvas instance', function () {
      fixtureEl.innerHTML = '<div></div>';
      var div = fixtureEl.querySelector('div');
      var offcanvas = new _offcanvas["default"](div);
      expect(_offcanvas["default"].getOrCreateInstance(div)).toEqual(offcanvas);
      expect(_offcanvas["default"].getInstance(div)).toEqual(_offcanvas["default"].getOrCreateInstance(div, {}));
      expect(_offcanvas["default"].getOrCreateInstance(div)).toBeInstanceOf(_offcanvas["default"]);
    });
    it('should return new instance when there is no Offcanvas instance', function () {
      fixtureEl.innerHTML = '<div></div>';
      var div = fixtureEl.querySelector('div');
      expect(_offcanvas["default"].getInstance(div)).toEqual(null);
      expect(_offcanvas["default"].getOrCreateInstance(div)).toBeInstanceOf(_offcanvas["default"]);
    });
    it('should return new instance when there is no offcanvas instance with given configuration', function () {
      fixtureEl.innerHTML = '<div></div>';
      var div = fixtureEl.querySelector('div');
      expect(_offcanvas["default"].getInstance(div)).toEqual(null);

      var offcanvas = _offcanvas["default"].getOrCreateInstance(div, {
        scroll: true
      });

      expect(offcanvas).toBeInstanceOf(_offcanvas["default"]);
      expect(offcanvas._config.scroll).toEqual(true);
    });
    it('should return the instance when exists without given configuration', function () {
      fixtureEl.innerHTML = '<div></div>';
      var div = fixtureEl.querySelector('div');
      var offcanvas = new _offcanvas["default"](div, {
        scroll: true
      });
      expect(_offcanvas["default"].getInstance(div)).toEqual(offcanvas);

      var offcanvas2 = _offcanvas["default"].getOrCreateInstance(div, {
        scroll: false
      });

      expect(offcanvas).toBeInstanceOf(_offcanvas["default"]);
      expect(offcanvas2).toEqual(offcanvas);
      expect(offcanvas2._config.scroll).toEqual(true);
    });
  });
});
"use strict";

var _popover = _interopRequireDefault(require("../../src/popover"));

var _fixture = require("../helpers/fixture");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/** Test helpers */
describe('Popover', function () {
  var fixtureEl;
  beforeAll(function () {
    fixtureEl = (0, _fixture.getFixture)();
  });
  afterEach(function () {
    (0, _fixture.clearFixture)();
    var popoverList = document.querySelectorAll('.popover');
    popoverList.forEach(function (popoverEl) {
      popoverEl.remove();
    });
  });
  describe('VERSION', function () {
    it('should return plugin version', function () {
      expect(_popover["default"].VERSION).toEqual(jasmine.any(String));
    });
  });
  describe('Default', function () {
    it('should return plugin default config', function () {
      expect(_popover["default"].Default).toEqual(jasmine.any(Object));
    });
  });
  describe('NAME', function () {
    it('should return plugin name', function () {
      expect(_popover["default"].NAME).toEqual(jasmine.any(String));
    });
  });
  describe('DATA_KEY', function () {
    it('should return plugin data key', function () {
      expect(_popover["default"].DATA_KEY).toEqual('bs.popover');
    });
  });
  describe('Event', function () {
    it('should return plugin events', function () {
      expect(_popover["default"].Event).toEqual(jasmine.any(Object));
    });
  });
  describe('EVENT_KEY', function () {
    it('should return plugin event key', function () {
      expect(_popover["default"].EVENT_KEY).toEqual('.bs.popover');
    });
  });
  describe('DefaultType', function () {
    it('should return plugin default type', function () {
      expect(_popover["default"].DefaultType).toEqual(jasmine.any(Object));
    });
  });
  describe('show', function () {
    it('should show a popover', function (done) {
      fixtureEl.innerHTML = '<a href="#" title="Popover" data-bs-content="https://twitter.com/getbootstrap">BS twitter</a>';
      var popoverEl = fixtureEl.querySelector('a');
      var popover = new _popover["default"](popoverEl);
      popoverEl.addEventListener('shown.bs.popover', function () {
        expect(document.querySelector('.popover')).not.toBeNull();
        done();
      });
      popover.show();
    });
    it('should set title and content from functions', function (done) {
      fixtureEl.innerHTML = '<a href="#">BS twitter</a>';
      var popoverEl = fixtureEl.querySelector('a');
      var popover = new _popover["default"](popoverEl, {
        title: function title() {
          return 'Bootstrap';
        },
        content: function content() {
          return 'loves writing tests （╯°□°）╯︵ ┻━┻';
        }
      });
      popoverEl.addEventListener('shown.bs.popover', function () {
        var popoverDisplayed = document.querySelector('.popover');
        expect(popoverDisplayed).not.toBeNull();
        expect(popoverDisplayed.querySelector('.popover-header').textContent).toEqual('Bootstrap');
        expect(popoverDisplayed.querySelector('.popover-body').textContent).toEqual('loves writing tests （╯°□°）╯︵ ┻━┻');
        done();
      });
      popover.show();
    });
    it('should show a popover with just content', function (done) {
      fixtureEl.innerHTML = '<a href="#">BS twitter</a>';
      var popoverEl = fixtureEl.querySelector('a');
      var popover = new _popover["default"](popoverEl, {
        content: 'Popover content'
      });
      popoverEl.addEventListener('shown.bs.popover', function () {
        var popoverDisplayed = document.querySelector('.popover');
        expect(popoverDisplayed).not.toBeNull();
        expect(popoverDisplayed.querySelector('.popover-body').textContent).toEqual('Popover content');
        done();
      });
      popover.show();
    });
    it('should show a popover with just content without having header', function (done) {
      fixtureEl.innerHTML = '<a href="#">Nice link</a>';
      var popoverEl = fixtureEl.querySelector('a');
      var popover = new _popover["default"](popoverEl, {
        content: 'Some beautiful content :)'
      });
      popoverEl.addEventListener('shown.bs.popover', function () {
        var popoverDisplayed = document.querySelector('.popover');
        expect(popoverDisplayed).not.toBeNull();
        expect(popoverDisplayed.querySelector('.popover-header')).toBeNull();
        expect(popoverDisplayed.querySelector('.popover-body').textContent).toEqual('Some beautiful content :)');
        done();
      });
      popover.show();
    });
    it('should show a popover with just title without having body', function (done) {
      fixtureEl.innerHTML = '<a href="#">Nice link</a>';
      var popoverEl = fixtureEl.querySelector('a');
      var popover = new _popover["default"](popoverEl, {
        title: 'Title, which does not require content'
      });
      popoverEl.addEventListener('shown.bs.popover', function () {
        var popoverDisplayed = document.querySelector('.popover');
        expect(popoverDisplayed).not.toBeNull();
        expect(popoverDisplayed.querySelector('.popover-body')).toBeNull();
        expect(popoverDisplayed.querySelector('.popover-header').textContent).toEqual('Title, which does not require content');
        done();
      });
      popover.show();
    });
    it('should call setContent once', function (done) {
      fixtureEl.innerHTML = '<a href="#">BS twitter</a>';
      var popoverEl = fixtureEl.querySelector('a');
      var popover = new _popover["default"](popoverEl, {
        content: 'Popover content'
      });
      var spy = spyOn(popover, 'setContent').and.callThrough();
      var times = 1;
      popoverEl.addEventListener('hidden.bs.popover', function () {
        popover.show();
      });
      popoverEl.addEventListener('shown.bs.popover', function () {
        var popoverDisplayed = document.querySelector('.popover');
        expect(popoverDisplayed).not.toBeNull();
        expect(popoverDisplayed.querySelector('.popover-body').textContent).toEqual('Popover content');
        expect(spy).toHaveBeenCalledTimes(1);

        if (times > 1) {
          done();
        }

        times++;
        popover.hide();
      });
      popover.show();
    });
    it('should show a popover with provided custom class', function (done) {
      fixtureEl.innerHTML = '<a href="#" title="Popover" data-bs-content="https://twitter.com/getbootstrap" data-bs-custom-class="custom-class">BS twitter</a>';
      var popoverEl = fixtureEl.querySelector('a');
      var popover = new _popover["default"](popoverEl);
      popoverEl.addEventListener('shown.bs.popover', function () {
        var tip = document.querySelector('.popover');
        expect(tip).not.toBeNull();
        expect(tip.classList.contains('custom-class')).toBeTrue();
        done();
      });
      popover.show();
    });
  });
  describe('hide', function () {
    it('should hide a popover', function (done) {
      fixtureEl.innerHTML = '<a href="#" title="Popover" data-bs-content="https://twitter.com/getbootstrap">BS twitter</a>';
      var popoverEl = fixtureEl.querySelector('a');
      var popover = new _popover["default"](popoverEl);
      popoverEl.addEventListener('shown.bs.popover', function () {
        popover.hide();
      });
      popoverEl.addEventListener('hidden.bs.popover', function () {
        expect(document.querySelector('.popover')).toBeNull();
        done();
      });
      popover.show();
    });
  });
  describe('jQueryInterface', function () {
    it('should create a popover', function () {
      fixtureEl.innerHTML = '<a href="#" title="Popover" data-bs-content="https://twitter.com/getbootstrap">BS twitter</a>';
      var popoverEl = fixtureEl.querySelector('a');
      _fixture.jQueryMock.fn.popover = _popover["default"].jQueryInterface;
      _fixture.jQueryMock.elements = [popoverEl];

      _fixture.jQueryMock.fn.popover.call(_fixture.jQueryMock);

      expect(_popover["default"].getInstance(popoverEl)).not.toBeNull();
    });
    it('should create a popover with a config object', function () {
      fixtureEl.innerHTML = '<a href="#" title="Popover">BS twitter</a>';
      var popoverEl = fixtureEl.querySelector('a');
      _fixture.jQueryMock.fn.popover = _popover["default"].jQueryInterface;
      _fixture.jQueryMock.elements = [popoverEl];

      _fixture.jQueryMock.fn.popover.call(_fixture.jQueryMock, {
        content: 'Popover content'
      });

      expect(_popover["default"].getInstance(popoverEl)).not.toBeNull();
    });
    it('should not re create a popover', function () {
      fixtureEl.innerHTML = '<a href="#" title="Popover" data-bs-content="https://twitter.com/getbootstrap">BS twitter</a>';
      var popoverEl = fixtureEl.querySelector('a');
      var popover = new _popover["default"](popoverEl);
      _fixture.jQueryMock.fn.popover = _popover["default"].jQueryInterface;
      _fixture.jQueryMock.elements = [popoverEl];

      _fixture.jQueryMock.fn.popover.call(_fixture.jQueryMock);

      expect(_popover["default"].getInstance(popoverEl)).toEqual(popover);
    });
    it('should throw error on undefined method', function () {
      fixtureEl.innerHTML = '<a href="#" title="Popover" data-bs-content="https://twitter.com/getbootstrap">BS twitter</a>';
      var popoverEl = fixtureEl.querySelector('a');
      var action = 'undefinedMethod';
      _fixture.jQueryMock.fn.popover = _popover["default"].jQueryInterface;
      _fixture.jQueryMock.elements = [popoverEl];
      expect(function () {
        _fixture.jQueryMock.fn.popover.call(_fixture.jQueryMock, action);
      }).toThrowError(TypeError, "No method named \"".concat(action, "\""));
    });
    it('should should call show method', function () {
      fixtureEl.innerHTML = '<a href="#" title="Popover" data-bs-content="https://twitter.com/getbootstrap">BS twitter</a>';
      var popoverEl = fixtureEl.querySelector('a');
      var popover = new _popover["default"](popoverEl);
      _fixture.jQueryMock.fn.popover = _popover["default"].jQueryInterface;
      _fixture.jQueryMock.elements = [popoverEl];
      spyOn(popover, 'show');

      _fixture.jQueryMock.fn.popover.call(_fixture.jQueryMock, 'show');

      expect(popover.show).toHaveBeenCalled();
    });
  });
  describe('getInstance', function () {
    it('should return popover instance', function () {
      fixtureEl.innerHTML = '<a href="#" title="Popover" data-bs-content="https://twitter.com/getbootstrap">BS twitter</a>';
      var popoverEl = fixtureEl.querySelector('a');
      var popover = new _popover["default"](popoverEl);
      expect(_popover["default"].getInstance(popoverEl)).toEqual(popover);
      expect(_popover["default"].getInstance(popoverEl)).toBeInstanceOf(_popover["default"]);
    });
    it('should return null when there is no popover instance', function () {
      fixtureEl.innerHTML = '<a href="#" title="Popover" data-bs-content="https://twitter.com/getbootstrap">BS twitter</a>';
      var popoverEl = fixtureEl.querySelector('a');
      expect(_popover["default"].getInstance(popoverEl)).toEqual(null);
    });
  });
  describe('getOrCreateInstance', function () {
    it('should return popover instance', function () {
      fixtureEl.innerHTML = '<div></div>';
      var div = fixtureEl.querySelector('div');
      var popover = new _popover["default"](div);
      expect(_popover["default"].getOrCreateInstance(div)).toEqual(popover);
      expect(_popover["default"].getInstance(div)).toEqual(_popover["default"].getOrCreateInstance(div, {}));
      expect(_popover["default"].getOrCreateInstance(div)).toBeInstanceOf(_popover["default"]);
    });
    it('should return new instance when there is no popover instance', function () {
      fixtureEl.innerHTML = '<div></div>';
      var div = fixtureEl.querySelector('div');
      expect(_popover["default"].getInstance(div)).toEqual(null);
      expect(_popover["default"].getOrCreateInstance(div)).toBeInstanceOf(_popover["default"]);
    });
    it('should return new instance when there is no popover instance with given configuration', function () {
      fixtureEl.innerHTML = '<div></div>';
      var div = fixtureEl.querySelector('div');
      expect(_popover["default"].getInstance(div)).toEqual(null);

      var popover = _popover["default"].getOrCreateInstance(div, {
        placement: 'top'
      });

      expect(popover).toBeInstanceOf(_popover["default"]);
      expect(popover._config.placement).toEqual('top');
    });
    it('should return the instance when exists without given configuration', function () {
      fixtureEl.innerHTML = '<div></div>';
      var div = fixtureEl.querySelector('div');
      var popover = new _popover["default"](div, {
        placement: 'top'
      });
      expect(_popover["default"].getInstance(div)).toEqual(popover);

      var popover2 = _popover["default"].getOrCreateInstance(div, {
        placement: 'bottom'
      });

      expect(popover).toBeInstanceOf(_popover["default"]);
      expect(popover2).toEqual(popover);
      expect(popover2._config.placement).toEqual('top');
    });
  });
});
"use strict";

var _scrollspy = _interopRequireDefault(require("../../src/scrollspy"));

var _manipulator = _interopRequireDefault(require("../../src/dom/manipulator"));

var _fixture = require("../helpers/fixture");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/** Test helpers */
describe('ScrollSpy', function () {
  var fixtureEl;

  var testElementIsActiveAfterScroll = function testElementIsActiveAfterScroll(_ref) {
    var elementSelector = _ref.elementSelector,
        targetSelector = _ref.targetSelector,
        contentEl = _ref.contentEl,
        scrollSpy = _ref.scrollSpy,
        spy = _ref.spy,
        cb = _ref.cb;
    var element = fixtureEl.querySelector(elementSelector);
    var target = fixtureEl.querySelector(targetSelector); // add top padding to fix Chrome on Android failures

    var paddingTop = 5;
    var scrollHeight = Math.ceil(contentEl.scrollTop + _manipulator["default"].position(target).top) + paddingTop;

    function listener() {
      expect(element.classList.contains('active')).toEqual(true);
      contentEl.removeEventListener('scroll', listener);
      expect(scrollSpy._process).toHaveBeenCalled();
      spy.calls.reset();
      cb();
    }

    contentEl.addEventListener('scroll', listener);
    contentEl.scrollTop = scrollHeight;
  };

  beforeAll(function () {
    fixtureEl = (0, _fixture.getFixture)();
  });
  afterEach(function () {
    (0, _fixture.clearFixture)();
  });
  describe('VERSION', function () {
    it('should return plugin version', function () {
      expect(_scrollspy["default"].VERSION).toEqual(jasmine.any(String));
    });
  });
  describe('Default', function () {
    it('should return plugin default config', function () {
      expect(_scrollspy["default"].Default).toEqual(jasmine.any(Object));
    });
  });
  describe('DATA_KEY', function () {
    it('should return plugin data key', function () {
      expect(_scrollspy["default"].DATA_KEY).toEqual('bs.scrollspy');
    });
  });
  describe('constructor', function () {
    it('should take care of element either passed as a CSS selector or DOM element', function () {
      fixtureEl.innerHTML = '<nav id="navigation"></nav><div class="content"></div>';
      var sSpyEl = fixtureEl.querySelector('#navigation');
      var sSpyBySelector = new _scrollspy["default"]('#navigation');
      var sSpyByElement = new _scrollspy["default"](sSpyEl);
      expect(sSpyBySelector._element).toEqual(sSpyEl);
      expect(sSpyByElement._element).toEqual(sSpyEl);
    });
    it('should not process element without target', function () {
      fixtureEl.innerHTML = ['<nav id="navigation" class="navbar">', '  <ul class="navbar-nav">', '    <li class="nav-item"><a class="nav-link active" id="one-link" href="#">One</a></li>', '    <li class="nav-item"><a class="nav-link" id="two-link" href="#two">Two</a></li>', '    <li class="nav-item"><a class="nav-link" id="three-link" href="#three">Three</a></li>', '  </ul>', '</nav>', '<div id="content" style="height: 200px; overflow-y: auto;">', ' <div id="two" style="height: 300px;"></div>', ' <div id="three" style="height: 10px;"></div>', '</div>'].join('');
      var scrollSpy = new _scrollspy["default"](fixtureEl.querySelector('#content'), {
        target: '#navigation'
      });
      expect(scrollSpy._targets.length).toEqual(2);
    });
    it('should only switch "active" class on current target', function (done) {
      fixtureEl.innerHTML = ['<div id="root" class="active" style="display: block">', '  <div class="topbar">', '    <div class="topbar-inner">', '      <div class="container" id="ss-target">', '        <ul class="nav">', '          <li class="nav-item"><a href="#masthead">Overview</a></li>', '          <li class="nav-item"><a href="#detail">Detail</a></li>', '        </ul>', '      </div>', '    </div>', '  </div>', '  <div id="scrollspy-example" style="height: 100px; overflow: auto;">', '    <div style="height: 200px;">', '      <h4 id="masthead">Overview</h4>', '      <p style="height: 200px;"></p>', '    </div>', '    <div style="height: 200px;">', '      <h4 id="detail">Detail</h4>', '      <p style="height: 200px;"></p>', '    </div>', '  </div>', '</div>'].join('');
      var scrollSpyEl = fixtureEl.querySelector('#scrollspy-example');
      var rootEl = fixtureEl.querySelector('#root');
      var scrollSpy = new _scrollspy["default"](scrollSpyEl, {
        target: 'ss-target'
      });
      spyOn(scrollSpy, '_process').and.callThrough();
      scrollSpyEl.addEventListener('scroll', function () {
        expect(rootEl.classList.contains('active')).toEqual(true);
        expect(scrollSpy._process).toHaveBeenCalled();
        done();
      });
      scrollSpyEl.scrollTop = 350;
    });
    it('should only switch "active" class on current target specified w element', function (done) {
      fixtureEl.innerHTML = ['<div id="root" class="active" style="display: block">', '  <div class="topbar">', '    <div class="topbar-inner">', '      <div class="container" id="ss-target">', '        <ul class="nav">', '          <li class="nav-item"><a href="#masthead">Overview</a></li>', '          <li class="nav-item"><a href="#detail">Detail</a></li>', '        </ul>', '      </div>', '    </div>', '  </div>', '  <div id="scrollspy-example" style="height: 100px; overflow: auto;">', '    <div style="height: 200px;">', '      <h4 id="masthead">Overview</h4>', '      <p style="height: 200px;"></p>', '    </div>', '    <div style="height: 200px;">', '      <h4 id="detail">Detail</h4>', '      <p style="height: 200px;"></p>', '    </div>', '  </div>', '</div>'].join('');
      var scrollSpyEl = fixtureEl.querySelector('#scrollspy-example');
      var rootEl = fixtureEl.querySelector('#root');
      var scrollSpy = new _scrollspy["default"](scrollSpyEl, {
        target: fixtureEl.querySelector('#ss-target')
      });
      spyOn(scrollSpy, '_process').and.callThrough();
      scrollSpyEl.addEventListener('scroll', function () {
        expect(rootEl.classList.contains('active')).toEqual(true);
        expect(scrollSpy._process).toHaveBeenCalled();
        done();
      });
      scrollSpyEl.scrollTop = 350;
    });
    it('should correctly select middle navigation option when large offset is used', function (done) {
      fixtureEl.innerHTML = ['<div id="header" style="height: 500px;"></div>', '<nav id="navigation" class="navbar">', ' <ul class="navbar-nav">', '   <li class="nav-item"><a class="nav-link active" id="one-link" href="#one">One</a></li>', '   <li class="nav-item"><a class="nav-link" id="two-link" href="#two">Two</a></li>', '   <li class="nav-item"><a class="nav-link" id="three-link" href="#three">Three</a></li>', ' </ul>', '</nav>', '<div id="content" style="height: 200px; overflow-y: auto;">', ' <div id="one" style="height: 500px;"></div>', ' <div id="two" style="height: 300px;"></div>', ' <div id="three" style="height: 10px;"></div>', '</div>'].join('');
      var contentEl = fixtureEl.querySelector('#content');
      var scrollSpy = new _scrollspy["default"](contentEl, {
        target: '#navigation',
        offset: _manipulator["default"].position(contentEl).top
      });
      spyOn(scrollSpy, '_process').and.callThrough();
      contentEl.addEventListener('scroll', function () {
        expect(fixtureEl.querySelector('#one-link').classList.contains('active')).toEqual(false);
        expect(fixtureEl.querySelector('#two-link').classList.contains('active')).toEqual(true);
        expect(fixtureEl.querySelector('#three-link').classList.contains('active')).toEqual(false);
        expect(scrollSpy._process).toHaveBeenCalled();
        done();
      });
      contentEl.scrollTop = 550;
    });
    it('should add the active class to the correct element', function (done) {
      fixtureEl.innerHTML = ['<nav class="navbar">', '  <ul class="nav">', '    <li class="nav-item"><a class="nav-link" id="a-1" href="#div-1">div 1</a></li>', '    <li class="nav-item"><a class="nav-link" id="a-2" href="#div-2">div 2</a></li>', '  </ul>', '</nav>', '<div class="content" style="overflow: auto; height: 50px">', '  <div id="div-1" style="height: 100px; padding: 0; margin: 0">div 1</div>', '  <div id="div-2" style="height: 200px; padding: 0; margin: 0">div 2</div>', '</div>'].join('');
      var contentEl = fixtureEl.querySelector('.content');
      var scrollSpy = new _scrollspy["default"](contentEl, {
        offset: 0,
        target: '.navbar'
      });
      var spy = spyOn(scrollSpy, '_process').and.callThrough();
      testElementIsActiveAfterScroll({
        elementSelector: '#a-1',
        targetSelector: '#div-1',
        contentEl: contentEl,
        scrollSpy: scrollSpy,
        spy: spy,
        cb: function cb() {
          testElementIsActiveAfterScroll({
            elementSelector: '#a-2',
            targetSelector: '#div-2',
            contentEl: contentEl,
            scrollSpy: scrollSpy,
            spy: spy,
            cb: function cb() {
              return done();
            }
          });
        }
      });
    });
    it('should add the active class to the correct element (nav markup)', function (done) {
      fixtureEl.innerHTML = ['<nav class="navbar">', '  <nav class="nav">', '    <a class="nav-link" id="a-1" href="#div-1">div 1</a>', '    <a class="nav-link" id="a-2" href="#div-2">div 2</a>', '  </nav>', '</nav>', '<div class="content" style="overflow: auto; height: 50px">', '  <div id="div-1" style="height: 100px; padding: 0; margin: 0">div 1</div>', '  <div id="div-2" style="height: 200px; padding: 0; margin: 0">div 2</div>', '</div>'].join('');
      var contentEl = fixtureEl.querySelector('.content');
      var scrollSpy = new _scrollspy["default"](contentEl, {
        offset: 0,
        target: '.navbar'
      });
      var spy = spyOn(scrollSpy, '_process').and.callThrough();
      testElementIsActiveAfterScroll({
        elementSelector: '#a-1',
        targetSelector: '#div-1',
        contentEl: contentEl,
        scrollSpy: scrollSpy,
        spy: spy,
        cb: function cb() {
          testElementIsActiveAfterScroll({
            elementSelector: '#a-2',
            targetSelector: '#div-2',
            contentEl: contentEl,
            scrollSpy: scrollSpy,
            spy: spy,
            cb: function cb() {
              return done();
            }
          });
        }
      });
    });
    it('should add the active class to the correct element (list-group markup)', function (done) {
      fixtureEl.innerHTML = ['<nav class="navbar">', '  <div class="list-group">', '    <a class="list-group-item" id="a-1" href="#div-1">div 1</a>', '    <a class="list-group-item" id="a-2" href="#div-2">div 2</a>', '  </div>', '</nav>', '<div class="content" style="overflow: auto; height: 50px">', '  <div id="div-1" style="height: 100px; padding: 0; margin: 0">div 1</div>', '  <div id="div-2" style="height: 200px; padding: 0; margin: 0">div 2</div>', '</div>'].join('');
      var contentEl = fixtureEl.querySelector('.content');
      var scrollSpy = new _scrollspy["default"](contentEl, {
        offset: 0,
        target: '.navbar'
      });
      var spy = spyOn(scrollSpy, '_process').and.callThrough();
      testElementIsActiveAfterScroll({
        elementSelector: '#a-1',
        targetSelector: '#div-1',
        contentEl: contentEl,
        scrollSpy: scrollSpy,
        spy: spy,
        cb: function cb() {
          testElementIsActiveAfterScroll({
            elementSelector: '#a-2',
            targetSelector: '#div-2',
            contentEl: contentEl,
            scrollSpy: scrollSpy,
            spy: spy,
            cb: function cb() {
              return done();
            }
          });
        }
      });
    });
    it('should clear selection if above the first section', function (done) {
      fixtureEl.innerHTML = ['<div id="header" style="height: 500px;"></div>', '<nav id="navigation" class="navbar">', '  <ul class="navbar-nav">', '    <li class="nav-item"><a id="one-link"   class="nav-link active" href="#one">One</a></li>', '    <li class="nav-item"><a id="two-link"   class="nav-link" href="#two">Two</a></li>', '    <li class="nav-item"><a id="three-link" class="nav-link" href="#three">Three</a></li>', '  </ul>', '</nav>', '<div id="content" style="height: 200px; overflow-y: auto;">', '  <div id="spacer" style="height: 100px;"></div>', '  <div id="one" style="height: 100px;"></div>', '  <div id="two" style="height: 100px;"></div>', '  <div id="three" style="height: 100px;"></div>', '  <div id="spacer" style="height: 100px;"></div>', '</div>'].join('');
      var contentEl = fixtureEl.querySelector('#content');
      var scrollSpy = new _scrollspy["default"](contentEl, {
        target: '#navigation',
        offset: _manipulator["default"].position(contentEl).top
      });
      var spy = spyOn(scrollSpy, '_process').and.callThrough();
      var firstTime = true;
      contentEl.addEventListener('scroll', function () {
        var active = fixtureEl.querySelector('.active');
        expect(spy).toHaveBeenCalled();
        spy.calls.reset();

        if (firstTime) {
          expect(fixtureEl.querySelectorAll('.active').length).toEqual(1);
          expect(active.getAttribute('id')).toEqual('two-link');
          firstTime = false;
          contentEl.scrollTop = 0;
        } else {
          expect(active).toBeNull();
          done();
        }
      });
      contentEl.scrollTop = 201;
    });
    it('should not clear selection if above the first section and first section is at the top', function (done) {
      fixtureEl.innerHTML = ['<div id="header" style="height: 500px;"></div>', '<nav id="navigation" class="navbar">', '  <ul class="navbar-nav">', '    <li class="nav-item"><a id="one-link" class="nav-link active" href="#one">One</a></li>', '    <li class="nav-item"><a id="two-link" class="nav-link" href="#two">Two</a></li>', '    <li class="nav-item"><a id="three-link" class="nav-link" href="#three">Three</a></li>', '  </ul>', '</nav>', '<div id="content" style="height: 200px; overflow-y: auto;">', '  <div id="one" style="height: 100px;"></div>', '  <div id="two" style="height: 100px;"></div>', '  <div id="three" style="height: 100px;"></div>', '  <div id="spacer" style="height: 100px;"></div>', '</div>'].join('');
      var negativeHeight = -10;
      var startOfSectionTwo = 101;
      var contentEl = fixtureEl.querySelector('#content');
      var scrollSpy = new _scrollspy["default"](contentEl, {
        target: '#navigation',
        offset: contentEl.offsetTop
      });
      var spy = spyOn(scrollSpy, '_process').and.callThrough();
      var firstTime = true;
      contentEl.addEventListener('scroll', function () {
        var active = fixtureEl.querySelector('.active');
        expect(spy).toHaveBeenCalled();
        spy.calls.reset();

        if (firstTime) {
          expect(fixtureEl.querySelectorAll('.active').length).toEqual(1);
          expect(active.getAttribute('id')).toEqual('two-link');
          firstTime = false;
          contentEl.scrollTop = negativeHeight;
        } else {
          expect(fixtureEl.querySelectorAll('.active').length).toEqual(1);
          expect(active.getAttribute('id')).toEqual('one-link');
          done();
        }
      });
      contentEl.scrollTop = startOfSectionTwo;
    });
    it('should correctly select navigation element on backward scrolling when each target section height is 100%', function (done) {
      fixtureEl.innerHTML = ['<nav class="navbar">', '  <ul class="nav">', '    <li class="nav-item"><a id="li-100-1" class="nav-link" href="#div-100-1">div 1</a></li>', '    <li class="nav-item"><a id="li-100-2" class="nav-link" href="#div-100-2">div 2</a></li>', '    <li class="nav-item"><a id="li-100-3" class="nav-link" href="#div-100-3">div 3</a></li>', '    <li class="nav-item"><a id="li-100-4" class="nav-link" href="#div-100-4">div 4</a></li>', '    <li class="nav-item"><a id="li-100-5" class="nav-link" href="#div-100-5">div 5</a></li>', '  </ul>', '</nav>', '<div class="content" style="position: relative; overflow: auto; height: 100px">', '  <div id="div-100-1" style="position: relative; height: 100%; padding: 0; margin: 0">div 1</div>', '  <div id="div-100-2" style="position: relative; height: 100%; padding: 0; margin: 0">div 2</div>', '  <div id="div-100-3" style="position: relative; height: 100%; padding: 0; margin: 0">div 3</div>', '  <div id="div-100-4" style="position: relative; height: 100%; padding: 0; margin: 0">div 4</div>', '  <div id="div-100-5" style="position: relative; height: 100%; padding: 0; margin: 0">div 5</div>', '</div>'].join('');
      var contentEl = fixtureEl.querySelector('.content');
      var scrollSpy = new _scrollspy["default"](contentEl, {
        offset: 0,
        target: '.navbar'
      });
      var spy = spyOn(scrollSpy, '_process').and.callThrough();
      testElementIsActiveAfterScroll({
        elementSelector: '#li-100-5',
        targetSelector: '#div-100-5',
        scrollSpy: scrollSpy,
        spy: spy,
        contentEl: contentEl,
        cb: function cb() {
          contentEl.scrollTop = 0;
          testElementIsActiveAfterScroll({
            elementSelector: '#li-100-4',
            targetSelector: '#div-100-4',
            scrollSpy: scrollSpy,
            spy: spy,
            contentEl: contentEl,
            cb: function cb() {
              contentEl.scrollTop = 0;
              testElementIsActiveAfterScroll({
                elementSelector: '#li-100-3',
                targetSelector: '#div-100-3',
                scrollSpy: scrollSpy,
                spy: spy,
                contentEl: contentEl,
                cb: function cb() {
                  contentEl.scrollTop = 0;
                  testElementIsActiveAfterScroll({
                    elementSelector: '#li-100-2',
                    targetSelector: '#div-100-2',
                    scrollSpy: scrollSpy,
                    spy: spy,
                    contentEl: contentEl,
                    cb: function cb() {
                      contentEl.scrollTop = 0;
                      testElementIsActiveAfterScroll({
                        elementSelector: '#li-100-1',
                        targetSelector: '#div-100-1',
                        scrollSpy: scrollSpy,
                        spy: spy,
                        contentEl: contentEl,
                        cb: done
                      });
                    }
                  });
                }
              });
            }
          });
        }
      });
    });
    it('should allow passed in option offset method: offset', function () {
      fixtureEl.innerHTML = ['<nav class="navbar">', '  <ul class="nav">', '    <li class="nav-item"><a id="li-jsm-1" class="nav-link" href="#div-jsm-1">div 1</a></li>', '    <li class="nav-item"><a id="li-jsm-2" class="nav-link" href="#div-jsm-2">div 2</a></li>', '    <li class="nav-item"><a id="li-jsm-3" class="nav-link" href="#div-jsm-3">div 3</a></li>', '  </ul>', '</nav>', '<div class="content"  style="position: relative; overflow: auto; height: 100px">', '  <div id="div-jsm-1" style="position: relative; height: 200px; padding: 0; margin: 0">div 1</div>', '  <div id="div-jsm-2" style="position: relative; height: 150px; padding: 0; margin: 0">div 2</div>', '  <div id="div-jsm-3" style="position: relative; height: 250px; padding: 0; margin: 0">div 3</div>', '</div>'].join('');
      var contentEl = fixtureEl.querySelector('.content');
      var targetEl = fixtureEl.querySelector('#div-jsm-2');
      var scrollSpy = new _scrollspy["default"](contentEl, {
        target: '.navbar',
        offset: 0,
        method: 'offset'
      });
      expect(scrollSpy._offsets[1]).toEqual(_manipulator["default"].offset(targetEl).top);
      expect(scrollSpy._offsets[1]).not.toEqual(_manipulator["default"].position(targetEl).top);
    });
    it('should allow passed in option offset method: position', function () {
      fixtureEl.innerHTML = ['<nav class="navbar">', '  <ul class="nav">', '    <li class="nav-item"><a id="li-jsm-1" class="nav-link" href="#div-jsm-1">div 1</a></li>', '    <li class="nav-item"><a id="li-jsm-2" class="nav-link" href="#div-jsm-2">div 2</a></li>', '    <li class="nav-item"><a id="li-jsm-3" class="nav-link" href="#div-jsm-3">div 3</a></li>', '  </ul>', '</nav>', '<div class="content"  style="position: relative; overflow: auto; height: 100px">', '  <div id="div-jsm-1" style="position: relative; height: 200px; padding: 0; margin: 0">div 1</div>', '  <div id="div-jsm-2" style="position: relative; height: 150px; padding: 0; margin: 0">div 2</div>', '  <div id="div-jsm-3" style="position: relative; height: 250px; padding: 0; margin: 0">div 3</div>', '</div>'].join('');
      var contentEl = fixtureEl.querySelector('.content');
      var targetEl = fixtureEl.querySelector('#div-jsm-2');
      var scrollSpy = new _scrollspy["default"](contentEl, {
        target: '.navbar',
        offset: 0,
        method: 'position'
      });
      expect(scrollSpy._offsets[1]).not.toEqual(_manipulator["default"].offset(targetEl).top);
      expect(scrollSpy._offsets[1]).toEqual(_manipulator["default"].position(targetEl).top);
    });
  });
  describe('dispose', function () {
    it('should dispose a scrollspy', function () {
      fixtureEl.innerHTML = '<div style="display: none;"></div>';
      var divEl = fixtureEl.querySelector('div');
      spyOn(divEl, 'addEventListener').and.callThrough();
      spyOn(divEl, 'removeEventListener').and.callThrough();
      var scrollSpy = new _scrollspy["default"](divEl);
      expect(divEl.addEventListener).toHaveBeenCalledWith('scroll', jasmine.any(Function), jasmine.any(Boolean));
      scrollSpy.dispose();
      expect(divEl.removeEventListener).toHaveBeenCalledWith('scroll', jasmine.any(Function), jasmine.any(Boolean));
    });
  });
  describe('jQueryInterface', function () {
    it('should create a scrollspy', function () {
      fixtureEl.innerHTML = '<div></div>';
      var div = fixtureEl.querySelector('div');
      _fixture.jQueryMock.fn.scrollspy = _scrollspy["default"].jQueryInterface;
      _fixture.jQueryMock.elements = [div];

      _fixture.jQueryMock.fn.scrollspy.call(_fixture.jQueryMock);

      expect(_scrollspy["default"].getInstance(div)).not.toBeNull();
    });
    it('should create a scrollspy with given config', function () {
      fixtureEl.innerHTML = '<div></div>';
      var div = fixtureEl.querySelector('div');
      _fixture.jQueryMock.fn.scrollspy = _scrollspy["default"].jQueryInterface;
      _fixture.jQueryMock.elements = [div];

      _fixture.jQueryMock.fn.scrollspy.call(_fixture.jQueryMock, {
        offset: 15
      });

      spyOn(_scrollspy["default"].prototype, 'constructor');
      expect(_scrollspy["default"].prototype.constructor).not.toHaveBeenCalledWith(div, {
        offset: 15
      });

      var scrollspy = _scrollspy["default"].getInstance(div);

      expect(scrollspy).not.toBeNull();
      expect(scrollspy._config.offset).toBe(15);
    });
    it('should not re create a scrollspy', function () {
      fixtureEl.innerHTML = '<div></div>';
      var div = fixtureEl.querySelector('div');
      var scrollSpy = new _scrollspy["default"](div);
      _fixture.jQueryMock.fn.scrollspy = _scrollspy["default"].jQueryInterface;
      _fixture.jQueryMock.elements = [div];

      _fixture.jQueryMock.fn.scrollspy.call(_fixture.jQueryMock);

      expect(_scrollspy["default"].getInstance(div)).toEqual(scrollSpy);
    });
    it('should call a scrollspy method', function () {
      fixtureEl.innerHTML = '<div></div>';
      var div = fixtureEl.querySelector('div');
      var scrollSpy = new _scrollspy["default"](div);
      spyOn(scrollSpy, 'refresh');
      _fixture.jQueryMock.fn.scrollspy = _scrollspy["default"].jQueryInterface;
      _fixture.jQueryMock.elements = [div];

      _fixture.jQueryMock.fn.scrollspy.call(_fixture.jQueryMock, 'refresh');

      expect(_scrollspy["default"].getInstance(div)).toEqual(scrollSpy);
      expect(scrollSpy.refresh).toHaveBeenCalled();
    });
    it('should throw error on undefined method', function () {
      fixtureEl.innerHTML = '<div></div>';
      var div = fixtureEl.querySelector('div');
      var action = 'undefinedMethod';
      _fixture.jQueryMock.fn.scrollspy = _scrollspy["default"].jQueryInterface;
      _fixture.jQueryMock.elements = [div];
      expect(function () {
        _fixture.jQueryMock.fn.scrollspy.call(_fixture.jQueryMock, action);
      }).toThrowError(TypeError, "No method named \"".concat(action, "\""));
    });
  });
  describe('getInstance', function () {
    it('should return scrollspy instance', function () {
      fixtureEl.innerHTML = '<div></div>';
      var div = fixtureEl.querySelector('div');
      var scrollSpy = new _scrollspy["default"](div);
      expect(_scrollspy["default"].getInstance(div)).toEqual(scrollSpy);
      expect(_scrollspy["default"].getInstance(div)).toBeInstanceOf(_scrollspy["default"]);
    });
    it('should return null if there is no instance', function () {
      expect(_scrollspy["default"].getInstance(fixtureEl)).toEqual(null);
    });
  });
  describe('getOrCreateInstance', function () {
    it('should return scrollspy instance', function () {
      fixtureEl.innerHTML = '<div></div>';
      var div = fixtureEl.querySelector('div');
      var scrollspy = new _scrollspy["default"](div);
      expect(_scrollspy["default"].getOrCreateInstance(div)).toEqual(scrollspy);
      expect(_scrollspy["default"].getInstance(div)).toEqual(_scrollspy["default"].getOrCreateInstance(div, {}));
      expect(_scrollspy["default"].getOrCreateInstance(div)).toBeInstanceOf(_scrollspy["default"]);
    });
    it('should return new instance when there is no scrollspy instance', function () {
      fixtureEl.innerHTML = '<div></div>';
      var div = fixtureEl.querySelector('div');
      expect(_scrollspy["default"].getInstance(div)).toEqual(null);
      expect(_scrollspy["default"].getOrCreateInstance(div)).toBeInstanceOf(_scrollspy["default"]);
    });
    it('should return new instance when there is no scrollspy instance with given configuration', function () {
      fixtureEl.innerHTML = '<div></div>';
      var div = fixtureEl.querySelector('div');
      expect(_scrollspy["default"].getInstance(div)).toEqual(null);

      var scrollspy = _scrollspy["default"].getOrCreateInstance(div, {
        offset: 1
      });

      expect(scrollspy).toBeInstanceOf(_scrollspy["default"]);
      expect(scrollspy._config.offset).toEqual(1);
    });
    it('should return the instance when exists without given configuration', function () {
      fixtureEl.innerHTML = '<div></div>';
      var div = fixtureEl.querySelector('div');
      var scrollspy = new _scrollspy["default"](div, {
        offset: 1
      });
      expect(_scrollspy["default"].getInstance(div)).toEqual(scrollspy);

      var scrollspy2 = _scrollspy["default"].getOrCreateInstance(div, {
        offset: 2
      });

      expect(scrollspy).toBeInstanceOf(_scrollspy["default"]);
      expect(scrollspy2).toEqual(scrollspy);
      expect(scrollspy2._config.offset).toEqual(1);
    });
  });
  describe('event handler', function () {
    it('should create scrollspy on window load event', function () {
      fixtureEl.innerHTML = '<div data-bs-spy="scroll"></div>';
      var scrollSpyEl = fixtureEl.querySelector('div');
      window.dispatchEvent((0, _fixture.createEvent)('load'));
      expect(_scrollspy["default"].getInstance(scrollSpyEl)).not.toBeNull();
    });
  });
});
"use strict";

var _tab = _interopRequireDefault(require("../../src/tab"));

var _fixture = require("../helpers/fixture");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/** Test helpers */
describe('Tab', function () {
  var fixtureEl;
  beforeAll(function () {
    fixtureEl = (0, _fixture.getFixture)();
  });
  afterEach(function () {
    (0, _fixture.clearFixture)();
  });
  describe('VERSION', function () {
    it('should return plugin version', function () {
      expect(_tab["default"].VERSION).toEqual(jasmine.any(String));
    });
  });
  describe('constructor', function () {
    it('should take care of element either passed as a CSS selector or DOM element', function () {
      fixtureEl.innerHTML = ['<ul class="nav"><li><a href="#home" role="tab">Home</a></li></ul>', '<ul><li id="home"></li></ul>'].join('');
      var tabEl = fixtureEl.querySelector('[href="#home"]');
      var tabBySelector = new _tab["default"]('[href="#home"]');
      var tabByElement = new _tab["default"](tabEl);
      expect(tabBySelector._element).toEqual(tabEl);
      expect(tabByElement._element).toEqual(tabEl);
    });
  });
  describe('show', function () {
    it('should activate element by tab id (using buttons, the preferred semantic way)', function (done) {
      fixtureEl.innerHTML = ['<ul class="nav" role="tablist">', '  <li><button type="button" data-bs-target="#home" role="tab">Home</button></li>', '  <li><button type="button" id="triggerProfile" data-bs-target="#profile" role="tab">Profile</button></li>', '</ul>', '<ul>', '  <li id="home" role="tabpanel"></li>', '  <li id="profile" role="tabpanel"></li>', '</ul>'].join('');
      var profileTriggerEl = fixtureEl.querySelector('#triggerProfile');
      var tab = new _tab["default"](profileTriggerEl);
      profileTriggerEl.addEventListener('shown.bs.tab', function () {
        expect(fixtureEl.querySelector('#profile').classList.contains('active')).toEqual(true);
        expect(profileTriggerEl.getAttribute('aria-selected')).toEqual('true');
        done();
      });
      tab.show();
    });
    it('should activate element by tab id (using links for tabs - not ideal, but still supported)', function (done) {
      fixtureEl.innerHTML = ['<ul class="nav" role="tablist">', '  <li><a href="#home" role="tab">Home</a></li>', '  <li><a id="triggerProfile" href="#profile" role="tab">Profile</a></li>', '</ul>', '<ul>', '  <li id="home" role="tabpanel"></li>', '  <li id="profile" role="tabpanel"></li>', '</ul>'].join('');
      var profileTriggerEl = fixtureEl.querySelector('#triggerProfile');
      var tab = new _tab["default"](profileTriggerEl);
      profileTriggerEl.addEventListener('shown.bs.tab', function () {
        expect(fixtureEl.querySelector('#profile').classList.contains('active')).toEqual(true);
        expect(profileTriggerEl.getAttribute('aria-selected')).toEqual('true');
        done();
      });
      tab.show();
    });
    it('should activate element by tab id in ordered list', function (done) {
      fixtureEl.innerHTML = ['<ol class="nav nav-pills">', '  <li><button type="button" data-bs-target="#home" role="tab">Home</button></li>', '  <li><button type="button" id="triggerProfile" href="#profile" role="tab">Profile</button></li>', '</ol>', '<ol>', '  <li id="home" role="tabpanel"></li>', '  <li id="profile" role="tabpanel"></li>', '</ol>'].join('');
      var profileTriggerEl = fixtureEl.querySelector('#triggerProfile');
      var tab = new _tab["default"](profileTriggerEl);
      profileTriggerEl.addEventListener('shown.bs.tab', function () {
        expect(fixtureEl.querySelector('#profile').classList.contains('active')).toEqual(true);
        done();
      });
      tab.show();
    });
    it('should activate element by tab id in nav list', function (done) {
      fixtureEl.innerHTML = ['<nav class="nav">', '  <button type="button" data-bs-target="#home" role="tab">Home</button>', '  <button type="button" id="triggerProfile" data-bs-target="#profile" role="tab">Profile</a>', '</nav>', '<div><div id="home" role="tabpanel"></div><div id="profile" role="tabpanel"></div></div>'].join('');
      var profileTriggerEl = fixtureEl.querySelector('#triggerProfile');
      var tab = new _tab["default"](profileTriggerEl);
      profileTriggerEl.addEventListener('shown.bs.tab', function () {
        expect(fixtureEl.querySelector('#profile').classList.contains('active')).toEqual(true);
        done();
      });
      tab.show();
    });
    it('should activate element by tab id in list group', function (done) {
      fixtureEl.innerHTML = ['<div class="list-group" role="tablist">', '  <button type="button" data-bs-target="#home" role="tab">Home</button>', '  <button type="button" id="triggerProfile" data-bs-target="#profile" role="tab">Profile</button>', '</div>', '<div><div id="home" role="tabpanel"></div><div id="profile" role="tabpanel"></div></div>'].join('');
      var profileTriggerEl = fixtureEl.querySelector('#triggerProfile');
      var tab = new _tab["default"](profileTriggerEl);
      profileTriggerEl.addEventListener('shown.bs.tab', function () {
        expect(fixtureEl.querySelector('#profile').classList.contains('active')).toEqual(true);
        done();
      });
      tab.show();
    });
    it('should not fire shown when show is prevented', function (done) {
      fixtureEl.innerHTML = '<div class="nav"></div>';
      var navEl = fixtureEl.querySelector('div');
      var tab = new _tab["default"](navEl);

      var expectDone = function expectDone() {
        setTimeout(function () {
          expect().nothing();
          done();
        }, 30);
      };

      navEl.addEventListener('show.bs.tab', function (ev) {
        ev.preventDefault();
        expectDone();
      });
      navEl.addEventListener('shown.bs.tab', function () {
        throw new Error('should not trigger shown event');
      });
      tab.show();
    });
    it('should not fire shown when tab is already active', function (done) {
      fixtureEl.innerHTML = ['<ul class="nav nav-tabs" role="tablist">', '  <li class="nav-item" role="presentation"><button type="button" data-bs-target="#home" class="nav-link active" role="tab" aria-selected="true">Home</button></li>', '  <li class="nav-item" role="presentation"><button type="button" data-bs-target="#profile" class="nav-link" role="tab">Profile</button></li>', '</ul>', '<div class="tab-content">', '  <div class="tab-pane active" id="home" role="tabpanel"></div>', '  <div class="tab-pane" id="profile" role="tabpanel"></div>', '</div>'].join('');
      var triggerActive = fixtureEl.querySelector('button.active');
      var tab = new _tab["default"](triggerActive);
      triggerActive.addEventListener('shown.bs.tab', function () {
        throw new Error('should not trigger shown event');
      });
      tab.show();
      setTimeout(function () {
        expect().nothing();
        done();
      }, 30);
    });
    it('show and shown events should reference correct relatedTarget', function (done) {
      fixtureEl.innerHTML = ['<ul class="nav nav-tabs" role="tablist">', '  <li class="nav-item" role="presentation"><button type="button" data-bs-target="#home" class="nav-link active" role="tab" aria-selected="true">Home</button></li>', '  <li class="nav-item" role="presentation"><button type="button" id="triggerProfile" data-bs-target="#profile" class="nav-link" role="tab">Profile</button></li>', '</ul>', '<div class="tab-content">', '  <div class="tab-pane active" id="home" role="tabpanel"></div>', '  <div class="tab-pane" id="profile" role="tabpanel"></div>', '</div>'].join('');
      var secondTabTrigger = fixtureEl.querySelector('#triggerProfile');
      var secondTab = new _tab["default"](secondTabTrigger);
      secondTabTrigger.addEventListener('show.bs.tab', function (ev) {
        expect(ev.relatedTarget.getAttribute('data-bs-target')).toEqual('#home');
      });
      secondTabTrigger.addEventListener('shown.bs.tab', function (ev) {
        expect(ev.relatedTarget.getAttribute('data-bs-target')).toEqual('#home');
        expect(secondTabTrigger.getAttribute('aria-selected')).toEqual('true');
        expect(fixtureEl.querySelector('button:not(.active)').getAttribute('aria-selected')).toEqual('false');
        done();
      });
      secondTab.show();
    });
    it('should fire hide and hidden events', function (done) {
      fixtureEl.innerHTML = ['<ul class="nav" role="tablist">', '  <li><button type="button" data-bs-target="#home" role="tab">Home</button></li>', '  <li><button type="button" data-bs-target="#profile">Profile</button></li>', '</ul>'].join('');
      var triggerList = fixtureEl.querySelectorAll('button');
      var firstTab = new _tab["default"](triggerList[0]);
      var secondTab = new _tab["default"](triggerList[1]);
      var hideCalled = false;
      triggerList[0].addEventListener('shown.bs.tab', function () {
        secondTab.show();
      });
      triggerList[0].addEventListener('hide.bs.tab', function (ev) {
        hideCalled = true;
        expect(ev.relatedTarget.getAttribute('data-bs-target')).toEqual('#profile');
      });
      triggerList[0].addEventListener('hidden.bs.tab', function (ev) {
        expect(hideCalled).toEqual(true);
        expect(ev.relatedTarget.getAttribute('data-bs-target')).toEqual('#profile');
        done();
      });
      firstTab.show();
    });
    it('should not fire hidden when hide is prevented', function (done) {
      fixtureEl.innerHTML = ['<ul class="nav" role="tablist">', '  <li><button type="button" data-bs-target="#home" role="tab">Home</button></li>', '  <li><button type="button" data-bs-target="#profile" role="tab">Profile</button></li>', '</ul>'].join('');
      var triggerList = fixtureEl.querySelectorAll('button');
      var firstTab = new _tab["default"](triggerList[0]);
      var secondTab = new _tab["default"](triggerList[1]);

      var expectDone = function expectDone() {
        setTimeout(function () {
          expect().nothing();
          done();
        }, 30);
      };

      triggerList[0].addEventListener('shown.bs.tab', function () {
        secondTab.show();
      });
      triggerList[0].addEventListener('hide.bs.tab', function (ev) {
        ev.preventDefault();
        expectDone();
      });
      triggerList[0].addEventListener('hidden.bs.tab', function () {
        throw new Error('should not trigger hidden');
      });
      firstTab.show();
    });
    it('should handle removed tabs', function (done) {
      fixtureEl.innerHTML = ['<ul class="nav nav-tabs" role="tablist">', '  <li class="nav-item" role="presentation">', '    <a class="nav-link nav-tab" href="#profile" role="tab" data-bs-toggle="tab">', '      <button class="btn-close" aria-label="Close"></button>', '    </a>', '  </li>', '  <li class="nav-item" role="presentation">', '    <a id="secondNav" class="nav-link nav-tab" href="#buzz" role="tab" data-bs-toggle="tab">', '      <button class="btn-close" aria-label="Close"></button>', '    </a>', '  </li>', '  <li class="nav-item" role="presentation">', '    <a class="nav-link nav-tab" href="#references" role="tab" data-bs-toggle="tab">', '      <button id="btnClose" class="btn-close" aria-label="Close"></button>', '    </a>', '  </li>', '</ul>', '<div class="tab-content">', '  <div role="tabpanel" class="tab-pane fade show active" id="profile">test 1</div>', '  <div role="tabpanel" class="tab-pane fade" id="buzz">test 2</div>', '  <div role="tabpanel" class="tab-pane fade" id="references">test 3</div>', '</div>'].join('');
      var secondNavEl = fixtureEl.querySelector('#secondNav');
      var btnCloseEl = fixtureEl.querySelector('#btnClose');
      var secondNavTab = new _tab["default"](secondNavEl);
      secondNavEl.addEventListener('shown.bs.tab', function () {
        expect(fixtureEl.querySelectorAll('.nav-tab').length).toEqual(2);
        done();
      });
      btnCloseEl.addEventListener('click', function () {
        var linkEl = btnCloseEl.parentNode;
        var liEl = linkEl.parentNode;
        var tabId = linkEl.getAttribute('href');
        var tabIdEl = fixtureEl.querySelector(tabId);
        liEl.remove();
        tabIdEl.remove();
        secondNavTab.show();
      });
      btnCloseEl.click();
    });
  });
  describe('dispose', function () {
    it('should dispose a tab', function () {
      fixtureEl.innerHTML = '<div></div>';
      var el = fixtureEl.querySelector('div');
      var tab = new _tab["default"](fixtureEl.querySelector('div'));
      expect(_tab["default"].getInstance(el)).not.toBeNull();
      tab.dispose();
      expect(_tab["default"].getInstance(el)).toBeNull();
    });
  });
  describe('jQueryInterface', function () {
    it('should create a tab', function () {
      fixtureEl.innerHTML = '<div></div>';
      var div = fixtureEl.querySelector('div');
      _fixture.jQueryMock.fn.tab = _tab["default"].jQueryInterface;
      _fixture.jQueryMock.elements = [div];

      _fixture.jQueryMock.fn.tab.call(_fixture.jQueryMock);

      expect(_tab["default"].getInstance(div)).not.toBeNull();
    });
    it('should not re create a tab', function () {
      fixtureEl.innerHTML = '<div></div>';
      var div = fixtureEl.querySelector('div');
      var tab = new _tab["default"](div);
      _fixture.jQueryMock.fn.tab = _tab["default"].jQueryInterface;
      _fixture.jQueryMock.elements = [div];

      _fixture.jQueryMock.fn.tab.call(_fixture.jQueryMock);

      expect(_tab["default"].getInstance(div)).toEqual(tab);
    });
    it('should call a tab method', function () {
      fixtureEl.innerHTML = '<div></div>';
      var div = fixtureEl.querySelector('div');
      var tab = new _tab["default"](div);
      spyOn(tab, 'show');
      _fixture.jQueryMock.fn.tab = _tab["default"].jQueryInterface;
      _fixture.jQueryMock.elements = [div];

      _fixture.jQueryMock.fn.tab.call(_fixture.jQueryMock, 'show');

      expect(_tab["default"].getInstance(div)).toEqual(tab);
      expect(tab.show).toHaveBeenCalled();
    });
    it('should throw error on undefined method', function () {
      fixtureEl.innerHTML = '<div></div>';
      var div = fixtureEl.querySelector('div');
      var action = 'undefinedMethod';
      _fixture.jQueryMock.fn.tab = _tab["default"].jQueryInterface;
      _fixture.jQueryMock.elements = [div];
      expect(function () {
        _fixture.jQueryMock.fn.tab.call(_fixture.jQueryMock, action);
      }).toThrowError(TypeError, "No method named \"".concat(action, "\""));
    });
  });
  describe('getInstance', function () {
    it('should return null if there is no instance', function () {
      expect(_tab["default"].getInstance(fixtureEl)).toEqual(null);
    });
    it('should return this instance', function () {
      fixtureEl.innerHTML = '<div></div>';
      var divEl = fixtureEl.querySelector('div');
      var tab = new _tab["default"](divEl);
      expect(_tab["default"].getInstance(divEl)).toEqual(tab);
      expect(_tab["default"].getInstance(divEl)).toBeInstanceOf(_tab["default"]);
    });
  });
  describe('getOrCreateInstance', function () {
    it('should return tab instance', function () {
      fixtureEl.innerHTML = '<div></div>';
      var div = fixtureEl.querySelector('div');
      var tab = new _tab["default"](div);
      expect(_tab["default"].getOrCreateInstance(div)).toEqual(tab);
      expect(_tab["default"].getInstance(div)).toEqual(_tab["default"].getOrCreateInstance(div, {}));
      expect(_tab["default"].getOrCreateInstance(div)).toBeInstanceOf(_tab["default"]);
    });
    it('should return new instance when there is no tab instance', function () {
      fixtureEl.innerHTML = '<div></div>';
      var div = fixtureEl.querySelector('div');
      expect(_tab["default"].getInstance(div)).toEqual(null);
      expect(_tab["default"].getOrCreateInstance(div)).toBeInstanceOf(_tab["default"]);
    });
  });
  describe('data-api', function () {
    it('should create dynamically a tab', function (done) {
      fixtureEl.innerHTML = ['<ul class="nav nav-tabs" role="tablist">', '  <li class="nav-item" role="presentation"><button type="button" data-bs-target="#home" class="nav-link active" role="tab" aria-selected="true">Home</button></li>', '  <li class="nav-item" role="presentation"><button type="button" id="triggerProfile" data-bs-toggle="tab" data-bs-target="#profile" class="nav-link" role="tab">Profile</button></li>', '</ul>', '<div class="tab-content">', '  <div class="tab-pane active" id="home" role="tabpanel"></div>', '  <div class="tab-pane" id="profile" role="tabpanel"></div>', '</div>'].join('');
      var secondTabTrigger = fixtureEl.querySelector('#triggerProfile');
      secondTabTrigger.addEventListener('shown.bs.tab', function () {
        expect(secondTabTrigger.classList.contains('active')).toEqual(true);
        expect(fixtureEl.querySelector('#profile').classList.contains('active')).toEqual(true);
        done();
      });
      secondTabTrigger.click();
    });
    it('selected tab should deactivate previous selected link in dropdown', function () {
      fixtureEl.innerHTML = ['<ul class="nav nav-tabs">', '  <li class="nav-item"><a class="nav-link" href="#home" data-bs-toggle="tab">Home</a></li>', '  <li class="nav-item"><a class="nav-link" href="#profile" data-bs-toggle="tab">Profile</a></li>', '  <li class="nav-item dropdown">', '    <a class="nav-link dropdown-toggle active" data-bs-toggle="dropdown" href="#">Dropdown</a>', '    <div class="dropdown-menu">', '      <a class="dropdown-item active" href="#dropdown1" id="dropdown1-tab" data-bs-toggle="tab">@fat</a>', '      <a class="dropdown-item" href="#dropdown2" id="dropdown2-tab" data-bs-toggle="tab">@mdo</a>', '    </div>', '  </li>', '</ul>'].join('');
      var firstLiLinkEl = fixtureEl.querySelector('li:first-child a');
      firstLiLinkEl.click();
      expect(firstLiLinkEl.classList.contains('active')).toEqual(true);
      expect(fixtureEl.querySelector('li:last-child a').classList.contains('active')).toEqual(false);
      expect(fixtureEl.querySelector('li:last-child .dropdown-menu a:first-child').classList.contains('active')).toEqual(false);
    });
    it('selecting a dropdown tab does not activate another', function () {
      var nav1 = ['<ul class="nav nav-tabs" id="nav1">', '  <li class="nav-item active"><a class="nav-link" href="#home" data-bs-toggle="tab">Home</a></li>', '  <li class="nav-item dropdown">', '    <a class="nav-link dropdown-toggle" data-bs-toggle="dropdown" href="#">Dropdown</a>', '    <div class="dropdown-menu">', '      <a class="dropdown-item" href="#dropdown1" id="dropdown1-tab" data-bs-toggle="tab">@fat</a>', '    </div>', '  </li>', '</ul>'].join('');
      var nav2 = ['<ul class="nav nav-tabs" id="nav2">', '  <li class="nav-item active"><a class="nav-link" href="#home" data-bs-toggle="tab">Home</a></li>', '  <li class="nav-item dropdown">', '    <a class="nav-link dropdown-toggle" data-bs-toggle="dropdown" href="#">Dropdown</a>', '    <div class="dropdown-menu">', '      <a class="dropdown-item" href="#dropdown1" id="dropdown1-tab" data-bs-toggle="tab">@fat</a>', '    </div>', '  </li>', '</ul>'].join('');
      fixtureEl.innerHTML = nav1 + nav2;
      var firstDropItem = fixtureEl.querySelector('#nav1 .dropdown-item');
      firstDropItem.click();
      expect(firstDropItem.classList.contains('active')).toEqual(true);
      expect(fixtureEl.querySelector('#nav1 .dropdown-toggle').classList.contains('active')).toEqual(true);
      expect(fixtureEl.querySelector('#nav2 .dropdown-toggle').classList.contains('active')).toEqual(false);
      expect(fixtureEl.querySelector('#nav2 .dropdown-item').classList.contains('active')).toEqual(false);
    });
    it('should support li > .dropdown-item', function () {
      fixtureEl.innerHTML = ['<ul class="nav nav-tabs">', '  <li class="nav-item"><a class="nav-link active" href="#home" data-bs-toggle="tab">Home</a></li>', '  <li class="nav-item"><a class="nav-link" href="#profile" data-bs-toggle="tab">Profile</a></li>', '  <li class="nav-item dropdown">', '    <a class="nav-link dropdown-toggle" data-bs-toggle="dropdown" href="#">Dropdown</a>', '    <ul class="dropdown-menu">', '      <li><a class="dropdown-item" href="#dropdown1" id="dropdown1-tab" data-bs-toggle="tab">@fat</a></li>', '      <li><a class="dropdown-item" href="#dropdown2" id="dropdown2-tab" data-bs-toggle="tab">@mdo</a></li>', '    </ul>', '  </li>', '</ul>'].join('');
      var firstDropItem = fixtureEl.querySelector('.dropdown-item');
      firstDropItem.click();
      expect(firstDropItem.classList.contains('active')).toEqual(true);
      expect(fixtureEl.querySelector('.nav-link').classList.contains('active')).toEqual(false);
    });
    it('should handle nested tabs', function (done) {
      fixtureEl.innerHTML = ['<nav class="nav nav-tabs" role="tablist">', '  <button type="button" id="tab1" data-bs-target="#x-tab1" class="nav-link" data-bs-toggle="tab" role="tab" aria-controls="x-tab1">Tab 1</button>', '  <button type="button" data-bs-target="#x-tab2" class="nav-link active" data-bs-toggle="tab" role="tab" aria-controls="x-tab2" aria-selected="true">Tab 2</button>', '  <button type="button" data-bs-target="#x-tab3" class="nav-link" data-bs-toggle="tab" role="tab" aria-controls="x-tab3">Tab 3</button>', '</nav>', '<div class="tab-content">', '  <div class="tab-pane" id="x-tab1" role="tabpanel">', '    <nav class="nav nav-tabs" role="tablist">', '      <button type="button" data-bs-target="#nested-tab1" class="nav-link active" data-bs-toggle="tab" role="tab" aria-controls="x-tab1" aria-selected="true">Nested Tab 1</button>', '      <button type="button" id="tabNested2" data-bs-target="#nested-tab2" class="nav-link" data-bs-toggle="tab" role="tab" aria-controls="x-profile">Nested Tab2</button>', '    </nav>', '    <div class="tab-content">', '      <div class="tab-pane active" id="nested-tab1" role="tabpanel">Nested Tab1 Content</div>', '      <div class="tab-pane" id="nested-tab2" role="tabpanel">Nested Tab2 Content</div>', '    </div>', '  </div>', '  <div class="tab-pane active" id="x-tab2" role="tabpanel">Tab2 Content</div>', '  <div class="tab-pane" id="x-tab3" role="tabpanel">Tab3 Content</div>', '</div>'].join('');
      var tab1El = fixtureEl.querySelector('#tab1');
      var tabNested2El = fixtureEl.querySelector('#tabNested2');
      var xTab1El = fixtureEl.querySelector('#x-tab1');
      tabNested2El.addEventListener('shown.bs.tab', function () {
        expect(xTab1El.classList.contains('active')).toEqual(true);
        done();
      });
      tab1El.addEventListener('shown.bs.tab', function () {
        expect(xTab1El.classList.contains('active')).toEqual(true);
        tabNested2El.click();
      });
      tab1El.click();
    });
    it('should not remove fade class if no active pane is present', function (done) {
      fixtureEl.innerHTML = ['<ul class="nav nav-tabs" role="tablist">', '  <li class="nav-item" role="presentation"><button type="button" id="tab-home" data-bs-target="#home" class="nav-link" data-bs-toggle="tab" role="tab">Home</button></li>', '  <li class="nav-item" role="presentation"><button type="button" id="tab-profile" data-bs-target="#profile" class="nav-link" data-bs-toggle="tab" role="tab">Profile</button></li>', '</ul>', '<div class="tab-content">', '  <div class="tab-pane fade" id="home" role="tabpanel"></div>', '  <div class="tab-pane fade" id="profile" role="tabpanel"></div>', '</div>'].join('');
      var triggerTabProfileEl = fixtureEl.querySelector('#tab-profile');
      var triggerTabHomeEl = fixtureEl.querySelector('#tab-home');
      var tabProfileEl = fixtureEl.querySelector('#profile');
      var tabHomeEl = fixtureEl.querySelector('#home');
      triggerTabProfileEl.addEventListener('shown.bs.tab', function () {
        expect(tabProfileEl.classList.contains('fade')).toEqual(true);
        expect(tabProfileEl.classList.contains('show')).toEqual(true);
        triggerTabHomeEl.addEventListener('shown.bs.tab', function () {
          expect(tabProfileEl.classList.contains('fade')).toEqual(true);
          expect(tabProfileEl.classList.contains('show')).toEqual(false);
          expect(tabHomeEl.classList.contains('fade')).toEqual(true);
          expect(tabHomeEl.classList.contains('show')).toEqual(true);
          done();
        });
        triggerTabHomeEl.click();
      });
      triggerTabProfileEl.click();
    });
    it('should not add show class to tab panes if there is no `.fade` class', function (done) {
      fixtureEl.innerHTML = ['<ul class="nav nav-tabs" role="tablist">', '  <li class="nav-item" role="presentation">', '    <button type="button" class="nav-link nav-tab" data-bs-target="#home" role="tab" data-bs-toggle="tab">Home</button>', '  </li>', '  <li class="nav-item" role="presentation">', '    <button type="button" id="secondNav" class="nav-link nav-tab" data-bs-target="#profile" role="tab" data-bs-toggle="tab">Profile</button>', '  </li>', '</ul>', '<div class="tab-content">', '  <div role="tabpanel" class="tab-pane" id="home">test 1</div>', '  <div role="tabpanel" class="tab-pane" id="profile">test 2</div>', '</div>'].join('');
      var secondNavEl = fixtureEl.querySelector('#secondNav');
      secondNavEl.addEventListener('shown.bs.tab', function () {
        expect(fixtureEl.querySelectorAll('.show').length).toEqual(0);
        done();
      });
      secondNavEl.click();
    });
    it('should add show class to tab panes if there is a `.fade` class', function (done) {
      fixtureEl.innerHTML = ['<ul class="nav nav-tabs" role="tablist">', '  <li class="nav-item" role="presentation">', '    <button type="button" class="nav-link nav-tab" data-bs-target="#home" role="tab" data-bs-toggle="tab">Home</button>', '  </li>', '  <li class="nav-item" role="presentation">', '    <button type="button" id="secondNav" class="nav-link nav-tab" data-bs-target="#profile" role="tab" data-bs-toggle="tab">Profile</button>', '  </li>', '</ul>', '<div class="tab-content">', '  <div role="tabpanel" class="tab-pane fade" id="home">test 1</div>', '  <div role="tabpanel" class="tab-pane fade" id="profile">test 2</div>', '</div>'].join('');
      var secondNavEl = fixtureEl.querySelector('#secondNav');
      secondNavEl.addEventListener('shown.bs.tab', function () {
        expect(fixtureEl.querySelectorAll('.show').length).toEqual(1);
        done();
      });
      secondNavEl.click();
    });
    it('should prevent default when the trigger is <a> or <area>', function (done) {
      fixtureEl.innerHTML = ['<ul class="nav" role="tablist">', '  <li><a type="button" href="#test"  class="active" role="tab" data-bs-toggle="tab">Home</a></li>', '  <li><a type="button" href="#test2" role="tab" data-bs-toggle="tab">Home</a></li>', '</ul>'].join('');
      var tabEl = fixtureEl.querySelector('[href="#test2"]');
      spyOn(Event.prototype, 'preventDefault').and.callThrough();
      tabEl.addEventListener('shown.bs.tab', function () {
        expect(tabEl.classList.contains('active')).toEqual(true);
        expect(Event.prototype.preventDefault).toHaveBeenCalled();
        done();
      });
      tabEl.click();
    });
    it('should not fire shown when tab has disabled attribute', function (done) {
      fixtureEl.innerHTML = ['<ul class="nav nav-tabs" role="tablist">', '  <li class="nav-item" role="presentation"><button type="button" data-bs-target="#home" class="nav-link active" role="tab" aria-selected="true">Home</button></li>', '  <li class="nav-item" role="presentation"><button type="button" data-bs-target="#profile" class="nav-link" disabled role="tab">Profile</button></li>', '</ul>', '<div class="tab-content">', '  <div class="tab-pane active" id="home" role="tabpanel"></div>', '  <div class="tab-pane" id="profile" role="tabpanel"></div>', '</div>'].join('');
      var triggerDisabled = fixtureEl.querySelector('button[disabled]');
      triggerDisabled.addEventListener('shown.bs.tab', function () {
        throw new Error('should not trigger shown event');
      });
      triggerDisabled.click();
      setTimeout(function () {
        expect().nothing();
        done();
      }, 30);
    });
    it('should not fire shown when tab has disabled class', function (done) {
      fixtureEl.innerHTML = ['<ul class="nav nav-tabs" role="tablist">', '  <li class="nav-item" role="presentation"><a href="#home" class="nav-link active" role="tab" aria-selected="true">Home</a></li>', '  <li class="nav-item" role="presentation"><a href="#profile" class="nav-link disabled" role="tab">Profile</a></li>', '</ul>', '<div class="tab-content">', '  <div class="tab-pane active" id="home" role="tabpanel"></div>', '  <div class="tab-pane" id="profile" role="tabpanel"></div>', '</div>'].join('');
      var triggerDisabled = fixtureEl.querySelector('a.disabled');
      triggerDisabled.addEventListener('shown.bs.tab', function () {
        throw new Error('should not trigger shown event');
      });
      triggerDisabled.click();
      setTimeout(function () {
        expect().nothing();
        done();
      }, 30);
    });
  });
});
"use strict";

var _toast = _interopRequireDefault(require("../../src/toast"));

var _fixture = require("../helpers/fixture");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/** Test helpers */
describe('Toast', function () {
  var fixtureEl;
  beforeAll(function () {
    fixtureEl = (0, _fixture.getFixture)();
  });
  afterEach(function () {
    (0, _fixture.clearFixture)();
  });
  describe('VERSION', function () {
    it('should return plugin version', function () {
      expect(_toast["default"].VERSION).toEqual(jasmine.any(String));
    });
  });
  describe('DATA_KEY', function () {
    it('should return plugin data key', function () {
      expect(_toast["default"].DATA_KEY).toEqual('bs.toast');
    });
  });
  describe('constructor', function () {
    it('should take care of element either passed as a CSS selector or DOM element', function () {
      fixtureEl.innerHTML = '<div class="toast"></div>';
      var toastEl = fixtureEl.querySelector('.toast');
      var toastBySelector = new _toast["default"]('.toast');
      var toastByElement = new _toast["default"](toastEl);
      expect(toastBySelector._element).toEqual(toastEl);
      expect(toastByElement._element).toEqual(toastEl);
    });
    it('should allow to config in js', function (done) {
      fixtureEl.innerHTML = ['<div class="toast">', '  <div class="toast-body">', '    a simple toast', '  </div>', '</div>'].join('');
      var toastEl = fixtureEl.querySelector('div');
      var toast = new _toast["default"](toastEl, {
        delay: 1
      });
      toastEl.addEventListener('shown.bs.toast', function () {
        expect(toastEl.classList.contains('show')).toEqual(true);
        done();
      });
      toast.show();
    });
    it('should close toast when close element with data-bs-dismiss attribute is set', function (done) {
      fixtureEl.innerHTML = ['<div class="toast" data-bs-delay="1" data-bs-autohide="false" data-bs-animation="false">', '  <button type="button" class="ms-2 mb-1 btn-close" data-bs-dismiss="toast" aria-label="Close"></button>', '</div>'].join('');
      var toastEl = fixtureEl.querySelector('div');
      var toast = new _toast["default"](toastEl);
      toastEl.addEventListener('shown.bs.toast', function () {
        expect(toastEl.classList.contains('show')).toEqual(true);
        var button = toastEl.querySelector('.btn-close');
        button.click();
      });
      toastEl.addEventListener('hidden.bs.toast', function () {
        expect(toastEl.classList.contains('show')).toEqual(false);
        done();
      });
      toast.show();
    });
  });
  describe('Default', function () {
    it('should expose default setting to allow to override them', function () {
      var defaultDelay = 1000;
      _toast["default"].Default.delay = defaultDelay;
      fixtureEl.innerHTML = ['<div class="toast" data-bs-autohide="false" data-bs-animation="false">', '  <button type="button" class="ms-2 mb-1 btn-close" data-bs-dismiss="toast" aria-label="Close"></button>', '</div>'].join('');
      var toastEl = fixtureEl.querySelector('div');
      var toast = new _toast["default"](toastEl);
      expect(toast._config.delay).toEqual(defaultDelay);
    });
  });
  describe('DefaultType', function () {
    it('should expose default setting types for read', function () {
      expect(_toast["default"].DefaultType).toEqual(jasmine.any(Object));
    });
  });
  describe('show', function () {
    it('should auto hide', function (done) {
      fixtureEl.innerHTML = ['<div class="toast" data-bs-delay="1">', '  <div class="toast-body">', '    a simple toast', '  </div>', '</div>'].join('');
      var toastEl = fixtureEl.querySelector('.toast');
      var toast = new _toast["default"](toastEl);
      toastEl.addEventListener('hidden.bs.toast', function () {
        expect(toastEl.classList.contains('show')).toEqual(false);
        done();
      });
      toast.show();
    });
    it('should not add fade class', function (done) {
      fixtureEl.innerHTML = ['<div class="toast" data-bs-delay="1" data-bs-animation="false">', '  <div class="toast-body">', '    a simple toast', '  </div>', '</div>'].join('');
      var toastEl = fixtureEl.querySelector('.toast');
      var toast = new _toast["default"](toastEl);
      toastEl.addEventListener('shown.bs.toast', function () {
        expect(toastEl.classList.contains('fade')).toEqual(false);
        done();
      });
      toast.show();
    });
    it('should not trigger shown if show is prevented', function (done) {
      fixtureEl.innerHTML = ['<div class="toast" data-bs-delay="1" data-bs-animation="false">', '  <div class="toast-body">', '    a simple toast', '  </div>', '</div>'].join('');
      var toastEl = fixtureEl.querySelector('.toast');
      var toast = new _toast["default"](toastEl);

      var assertDone = function assertDone() {
        setTimeout(function () {
          expect(toastEl.classList.contains('show')).toEqual(false);
          done();
        }, 20);
      };

      toastEl.addEventListener('show.bs.toast', function (event) {
        event.preventDefault();
        assertDone();
      });
      toastEl.addEventListener('shown.bs.toast', function () {
        throw new Error('shown event should not be triggered if show is prevented');
      });
      toast.show();
    });
    it('should clear timeout if toast is shown again before it is hidden', function (done) {
      fixtureEl.innerHTML = ['<div class="toast">', '  <div class="toast-body">', '    a simple toast', '  </div>', '</div>'].join('');
      var toastEl = fixtureEl.querySelector('.toast');
      var toast = new _toast["default"](toastEl);
      setTimeout(function () {
        toast._config.autohide = false;
        toastEl.addEventListener('shown.bs.toast', function () {
          expect(toast._clearTimeout).toHaveBeenCalled();
          expect(toast._timeout).toBeNull();
          done();
        });
        toast.show();
      }, toast._config.delay / 2);
      spyOn(toast, '_clearTimeout').and.callThrough();
      toast.show();
    });
    it('should clear timeout if toast is interacted with mouse', function (done) {
      fixtureEl.innerHTML = ['<div class="toast">', '  <div class="toast-body">', '    a simple toast', '  </div>', '</div>'].join('');
      var toastEl = fixtureEl.querySelector('.toast');
      var toast = new _toast["default"](toastEl);
      var spy = spyOn(toast, '_clearTimeout').and.callThrough();
      setTimeout(function () {
        spy.calls.reset();
        toastEl.addEventListener('mouseover', function () {
          expect(toast._clearTimeout).toHaveBeenCalledTimes(1);
          expect(toast._timeout).toBeNull();
          done();
        });
        var mouseOverEvent = (0, _fixture.createEvent)('mouseover');
        toastEl.dispatchEvent(mouseOverEvent);
      }, toast._config.delay / 2);
      toast.show();
    });
    it('should clear timeout if toast is interacted with keyboard', function (done) {
      fixtureEl.innerHTML = ['<button id="outside-focusable">outside focusable</button>', '<div class="toast">', '  <div class="toast-body">', '    a simple toast', '    <button>with a button</button>', '  </div>', '</div>'].join('');
      var toastEl = fixtureEl.querySelector('.toast');
      var toast = new _toast["default"](toastEl);
      var spy = spyOn(toast, '_clearTimeout').and.callThrough();
      setTimeout(function () {
        spy.calls.reset();
        toastEl.addEventListener('focusin', function () {
          expect(toast._clearTimeout).toHaveBeenCalledTimes(1);
          expect(toast._timeout).toBeNull();
          done();
        });
        var insideFocusable = toastEl.querySelector('button');
        insideFocusable.focus();
      }, toast._config.delay / 2);
      toast.show();
    });
    it('should still auto hide after being interacted with mouse and keyboard', function (done) {
      fixtureEl.innerHTML = ['<button id="outside-focusable">outside focusable</button>', '<div class="toast">', '  <div class="toast-body">', '    a simple toast', '    <button>with a button</button>', '  </div>', '</div>'].join('');
      var toastEl = fixtureEl.querySelector('.toast');
      var toast = new _toast["default"](toastEl);
      setTimeout(function () {
        toastEl.addEventListener('mouseover', function () {
          var insideFocusable = toastEl.querySelector('button');
          insideFocusable.focus();
        });
        toastEl.addEventListener('focusin', function () {
          var mouseOutEvent = (0, _fixture.createEvent)('mouseout');
          toastEl.dispatchEvent(mouseOutEvent);
        });
        toastEl.addEventListener('mouseout', function () {
          var outsideFocusable = document.getElementById('outside-focusable');
          outsideFocusable.focus();
        });
        toastEl.addEventListener('focusout', function () {
          expect(toast._timeout).not.toBeNull();
          done();
        });
        var mouseOverEvent = (0, _fixture.createEvent)('mouseover');
        toastEl.dispatchEvent(mouseOverEvent);
      }, toast._config.delay / 2);
      toast.show();
    });
    it('should not auto hide if focus leaves but mouse pointer remains inside', function (done) {
      fixtureEl.innerHTML = ['<button id="outside-focusable">outside focusable</button>', '<div class="toast">', '  <div class="toast-body">', '    a simple toast', '    <button>with a button</button>', '  </div>', '</div>'].join('');
      var toastEl = fixtureEl.querySelector('.toast');
      var toast = new _toast["default"](toastEl);
      setTimeout(function () {
        toastEl.addEventListener('mouseover', function () {
          var insideFocusable = toastEl.querySelector('button');
          insideFocusable.focus();
        });
        toastEl.addEventListener('focusin', function () {
          var outsideFocusable = document.getElementById('outside-focusable');
          outsideFocusable.focus();
        });
        toastEl.addEventListener('focusout', function () {
          expect(toast._timeout).toBeNull();
          done();
        });
        var mouseOverEvent = (0, _fixture.createEvent)('mouseover');
        toastEl.dispatchEvent(mouseOverEvent);
      }, toast._config.delay / 2);
      toast.show();
    });
    it('should not auto hide if mouse pointer leaves but focus remains inside', function (done) {
      fixtureEl.innerHTML = ['<button id="outside-focusable">outside focusable</button>', '<div class="toast">', '  <div class="toast-body">', '    a simple toast', '    <button>with a button</button>', '  </div>', '</div>'].join('');
      var toastEl = fixtureEl.querySelector('.toast');
      var toast = new _toast["default"](toastEl);
      setTimeout(function () {
        toastEl.addEventListener('mouseover', function () {
          var insideFocusable = toastEl.querySelector('button');
          insideFocusable.focus();
        });
        toastEl.addEventListener('focusin', function () {
          var mouseOutEvent = (0, _fixture.createEvent)('mouseout');
          toastEl.dispatchEvent(mouseOutEvent);
        });
        toastEl.addEventListener('mouseout', function () {
          expect(toast._timeout).toBeNull();
          done();
        });
        var mouseOverEvent = (0, _fixture.createEvent)('mouseover');
        toastEl.dispatchEvent(mouseOverEvent);
      }, toast._config.delay / 2);
      toast.show();
    });
  });
  describe('hide', function () {
    it('should allow to hide toast manually', function (done) {
      fixtureEl.innerHTML = ['<div class="toast" data-bs-delay="1" data-bs-autohide="false">', '  <div class="toast-body">', '    a simple toast', '  </div>', '  </div>'].join('');
      var toastEl = fixtureEl.querySelector('.toast');
      var toast = new _toast["default"](toastEl);
      toastEl.addEventListener('shown.bs.toast', function () {
        toast.hide();
      });
      toastEl.addEventListener('hidden.bs.toast', function () {
        expect(toastEl.classList.contains('show')).toEqual(false);
        done();
      });
      toast.show();
    });
    it('should do nothing when we call hide on a non shown toast', function () {
      fixtureEl.innerHTML = '<div></div>';
      var toastEl = fixtureEl.querySelector('div');
      var toast = new _toast["default"](toastEl);
      spyOn(toastEl.classList, 'contains');
      toast.hide();
      expect(toastEl.classList.contains).toHaveBeenCalled();
    });
    it('should not trigger hidden if hide is prevented', function (done) {
      fixtureEl.innerHTML = ['<div class="toast" data-bs-delay="1" data-bs-animation="false">', '  <div class="toast-body">', '    a simple toast', '  </div>', '</div>'].join('');
      var toastEl = fixtureEl.querySelector('.toast');
      var toast = new _toast["default"](toastEl);

      var assertDone = function assertDone() {
        setTimeout(function () {
          expect(toastEl.classList.contains('show')).toEqual(true);
          done();
        }, 20);
      };

      toastEl.addEventListener('shown.bs.toast', function () {
        toast.hide();
      });
      toastEl.addEventListener('hide.bs.toast', function (event) {
        event.preventDefault();
        assertDone();
      });
      toastEl.addEventListener('hidden.bs.toast', function () {
        throw new Error('hidden event should not be triggered if hide is prevented');
      });
      toast.show();
    });
  });
  describe('dispose', function () {
    it('should allow to destroy toast', function () {
      fixtureEl.innerHTML = '<div></div>';
      var toastEl = fixtureEl.querySelector('div');
      var toast = new _toast["default"](toastEl);
      expect(_toast["default"].getInstance(toastEl)).not.toBeNull();
      toast.dispose();
      expect(_toast["default"].getInstance(toastEl)).toBeNull();
    });
    it('should allow to destroy toast and hide it before that', function (done) {
      fixtureEl.innerHTML = ['<div class="toast" data-bs-delay="0" data-bs-autohide="false">', '  <div class="toast-body">', '    a simple toast', '  </div>', '</div>'].join('');
      var toastEl = fixtureEl.querySelector('div');
      var toast = new _toast["default"](toastEl);

      var expected = function expected() {
        expect(toastEl.classList.contains('show')).toEqual(true);
        expect(_toast["default"].getInstance(toastEl)).not.toBeNull();
        toast.dispose();
        expect(_toast["default"].getInstance(toastEl)).toBeNull();
        expect(toastEl.classList.contains('show')).toEqual(false);
        done();
      };

      toastEl.addEventListener('shown.bs.toast', function () {
        setTimeout(expected, 1);
      });
      toast.show();
    });
  });
  describe('jQueryInterface', function () {
    it('should create a toast', function () {
      fixtureEl.innerHTML = '<div></div>';
      var div = fixtureEl.querySelector('div');
      _fixture.jQueryMock.fn.toast = _toast["default"].jQueryInterface;
      _fixture.jQueryMock.elements = [div];

      _fixture.jQueryMock.fn.toast.call(_fixture.jQueryMock);

      expect(_toast["default"].getInstance(div)).not.toBeNull();
    });
    it('should not re create a toast', function () {
      fixtureEl.innerHTML = '<div></div>';
      var div = fixtureEl.querySelector('div');
      var toast = new _toast["default"](div);
      _fixture.jQueryMock.fn.toast = _toast["default"].jQueryInterface;
      _fixture.jQueryMock.elements = [div];

      _fixture.jQueryMock.fn.toast.call(_fixture.jQueryMock);

      expect(_toast["default"].getInstance(div)).toEqual(toast);
    });
    it('should call a toast method', function () {
      fixtureEl.innerHTML = '<div></div>';
      var div = fixtureEl.querySelector('div');
      var toast = new _toast["default"](div);
      spyOn(toast, 'show');
      _fixture.jQueryMock.fn.toast = _toast["default"].jQueryInterface;
      _fixture.jQueryMock.elements = [div];

      _fixture.jQueryMock.fn.toast.call(_fixture.jQueryMock, 'show');

      expect(_toast["default"].getInstance(div)).toEqual(toast);
      expect(toast.show).toHaveBeenCalled();
    });
    it('should throw error on undefined method', function () {
      fixtureEl.innerHTML = '<div></div>';
      var div = fixtureEl.querySelector('div');
      var action = 'undefinedMethod';
      _fixture.jQueryMock.fn.toast = _toast["default"].jQueryInterface;
      _fixture.jQueryMock.elements = [div];
      expect(function () {
        _fixture.jQueryMock.fn.toast.call(_fixture.jQueryMock, action);
      }).toThrowError(TypeError, "No method named \"".concat(action, "\""));
    });
  });
  describe('getInstance', function () {
    it('should return a toast instance', function () {
      fixtureEl.innerHTML = '<div></div>';
      var div = fixtureEl.querySelector('div');
      var toast = new _toast["default"](div);
      expect(_toast["default"].getInstance(div)).toEqual(toast);
      expect(_toast["default"].getInstance(div)).toBeInstanceOf(_toast["default"]);
    });
    it('should return null when there is no toast instance', function () {
      fixtureEl.innerHTML = '<div></div>';
      var div = fixtureEl.querySelector('div');
      expect(_toast["default"].getInstance(div)).toEqual(null);
    });
  });
  describe('getOrCreateInstance', function () {
    it('should return toast instance', function () {
      fixtureEl.innerHTML = '<div></div>';
      var div = fixtureEl.querySelector('div');
      var toast = new _toast["default"](div);
      expect(_toast["default"].getOrCreateInstance(div)).toEqual(toast);
      expect(_toast["default"].getInstance(div)).toEqual(_toast["default"].getOrCreateInstance(div, {}));
      expect(_toast["default"].getOrCreateInstance(div)).toBeInstanceOf(_toast["default"]);
    });
    it('should return new instance when there is no toast instance', function () {
      fixtureEl.innerHTML = '<div></div>';
      var div = fixtureEl.querySelector('div');
      expect(_toast["default"].getInstance(div)).toEqual(null);
      expect(_toast["default"].getOrCreateInstance(div)).toBeInstanceOf(_toast["default"]);
    });
    it('should return new instance when there is no toast instance with given configuration', function () {
      fixtureEl.innerHTML = '<div></div>';
      var div = fixtureEl.querySelector('div');
      expect(_toast["default"].getInstance(div)).toEqual(null);

      var toast = _toast["default"].getOrCreateInstance(div, {
        delay: 1
      });

      expect(toast).toBeInstanceOf(_toast["default"]);
      expect(toast._config.delay).toEqual(1);
    });
    it('should return the instance when exists without given configuration', function () {
      fixtureEl.innerHTML = '<div></div>';
      var div = fixtureEl.querySelector('div');
      var toast = new _toast["default"](div, {
        delay: 1
      });
      expect(_toast["default"].getInstance(div)).toEqual(toast);

      var toast2 = _toast["default"].getOrCreateInstance(div, {
        delay: 2
      });

      expect(toast).toBeInstanceOf(_toast["default"]);
      expect(toast2).toEqual(toast);
      expect(toast2._config.delay).toEqual(1);
    });
  });
});
"use strict";

var _tooltip = _interopRequireDefault(require("../../src/tooltip"));

var _eventHandler = _interopRequireDefault(require("../../src/dom/event-handler"));

var _index = require("../../src/util/index");

var _fixture = require("../helpers/fixture");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

describe('Tooltip', function () {
  var fixtureEl;
  beforeAll(function () {
    fixtureEl = (0, _fixture.getFixture)();
  });
  afterEach(function () {
    (0, _fixture.clearFixture)();
    document.querySelectorAll('.tooltip').forEach(function (tooltipEl) {
      tooltipEl.remove();
    });
  });
  describe('VERSION', function () {
    it('should return plugin version', function () {
      expect(_tooltip["default"].VERSION).toEqual(jasmine.any(String));
    });
  });
  describe('Default', function () {
    it('should return plugin default config', function () {
      expect(_tooltip["default"].Default).toEqual(jasmine.any(Object));
    });
  });
  describe('NAME', function () {
    it('should return plugin name', function () {
      expect(_tooltip["default"].NAME).toEqual(jasmine.any(String));
    });
  });
  describe('DATA_KEY', function () {
    it('should return plugin data key', function () {
      expect(_tooltip["default"].DATA_KEY).toEqual('bs.tooltip');
    });
  });
  describe('Event', function () {
    it('should return plugin events', function () {
      expect(_tooltip["default"].Event).toEqual(jasmine.any(Object));
    });
  });
  describe('EVENT_KEY', function () {
    it('should return plugin event key', function () {
      expect(_tooltip["default"].EVENT_KEY).toEqual('.bs.tooltip');
    });
  });
  describe('DefaultType', function () {
    it('should return plugin default type', function () {
      expect(_tooltip["default"].DefaultType).toEqual(jasmine.any(Object));
    });
  });
  describe('constructor', function () {
    it('should take care of element either passed as a CSS selector or DOM element', function () {
      fixtureEl.innerHTML = '<a href="#" id="tooltipEl" rel="tooltip" title="Nice and short title">';
      var tooltipEl = fixtureEl.querySelector('#tooltipEl');
      var tooltipBySelector = new _tooltip["default"]('#tooltipEl');
      var tooltipByElement = new _tooltip["default"](tooltipEl);
      expect(tooltipBySelector._element).toEqual(tooltipEl);
      expect(tooltipByElement._element).toEqual(tooltipEl);
    });
    it('should not take care of disallowed data attributes', function () {
      fixtureEl.innerHTML = '<a href="#" rel="tooltip" data-bs-sanitize="false" title="Another tooltip">';
      var tooltipEl = fixtureEl.querySelector('a');
      var tooltip = new _tooltip["default"](tooltipEl);
      expect(tooltip._config.sanitize).toEqual(true);
    });
    it('should convert title and content to string if numbers', function () {
      fixtureEl.innerHTML = '<a href="#" rel="tooltip">';
      var tooltipEl = fixtureEl.querySelector('a');
      var tooltip = new _tooltip["default"](tooltipEl, {
        title: 1,
        content: 7
      });
      expect(tooltip._config.title).toEqual('1');
      expect(tooltip._config.content).toEqual('7');
    });
    it('should enable selector delegation', function (done) {
      fixtureEl.innerHTML = '<div></div>';
      var containerEl = fixtureEl.querySelector('div');
      var tooltipContainer = new _tooltip["default"](containerEl, {
        selector: 'a[rel="tooltip"]',
        trigger: 'click'
      });
      containerEl.innerHTML = '<a href="#" rel="tooltip" title="Another tooltip">';
      var tooltipInContainerEl = containerEl.querySelector('a');
      tooltipInContainerEl.addEventListener('shown.bs.tooltip', function () {
        expect(document.querySelector('.tooltip')).not.toBeNull();
        tooltipContainer.dispose();
        done();
      });
      tooltipInContainerEl.click();
    });
    it('should create offset modifier when offset is passed as a function', function (done) {
      fixtureEl.innerHTML = '<a href="#" rel="tooltip" title="Offset from function">';
      var getOffset = jasmine.createSpy('getOffset').and.returnValue([10, 20]);
      var tooltipEl = fixtureEl.querySelector('a');
      var tooltip = new _tooltip["default"](tooltipEl, {
        offset: getOffset,
        popperConfig: {
          onFirstUpdate: function onFirstUpdate(state) {
            expect(getOffset).toHaveBeenCalledWith({
              popper: state.rects.popper,
              reference: state.rects.reference,
              placement: state.placement
            }, tooltipEl);
            done();
          }
        }
      });

      var offset = tooltip._getOffset();

      expect(_typeof(offset)).toEqual('function');
      tooltip.show();
    });
    it('should create offset modifier when offset option is passed in data attribute', function () {
      fixtureEl.innerHTML = '<a href="#" rel="tooltip" data-bs-offset="10,20" title="Another tooltip">';
      var tooltipEl = fixtureEl.querySelector('a');
      var tooltip = new _tooltip["default"](tooltipEl);
      expect(tooltip._getOffset()).toEqual([10, 20]);
    });
    it('should allow to pass config to Popper with `popperConfig`', function () {
      fixtureEl.innerHTML = '<a href="#" rel="tooltip">';
      var tooltipEl = fixtureEl.querySelector('a');
      var tooltip = new _tooltip["default"](tooltipEl, {
        popperConfig: {
          placement: 'left'
        }
      });

      var popperConfig = tooltip._getPopperConfig('top');

      expect(popperConfig.placement).toEqual('left');
    });
    it('should allow to pass config to Popper with `popperConfig` as a function', function () {
      fixtureEl.innerHTML = '<a href="#" rel="tooltip">';
      var tooltipEl = fixtureEl.querySelector('a');
      var getPopperConfig = jasmine.createSpy('getPopperConfig').and.returnValue({
        placement: 'left'
      });
      var tooltip = new _tooltip["default"](tooltipEl, {
        popperConfig: getPopperConfig
      });

      var popperConfig = tooltip._getPopperConfig('top');

      expect(getPopperConfig).toHaveBeenCalled();
      expect(popperConfig.placement).toEqual('left');
    });
  });
  describe('enable', function () {
    it('should enable a tooltip', function (done) {
      fixtureEl.innerHTML = '<a href="#" rel="tooltip" title="Another tooltip">';
      var tooltipEl = fixtureEl.querySelector('a');
      var tooltip = new _tooltip["default"](tooltipEl);
      tooltip.enable();
      tooltipEl.addEventListener('shown.bs.tooltip', function () {
        expect(document.querySelector('.tooltip')).not.toBeNull();
        done();
      });
      tooltip.show();
    });
  });
  describe('disable', function () {
    it('should disable tooltip', function (done) {
      fixtureEl.innerHTML = '<a href="#" rel="tooltip" title="Another tooltip">';
      var tooltipEl = fixtureEl.querySelector('a');
      var tooltip = new _tooltip["default"](tooltipEl);
      tooltip.disable();
      tooltipEl.addEventListener('show.bs.tooltip', function () {
        throw new Error('should not show a disabled tooltip');
      });
      tooltip.show();
      setTimeout(function () {
        expect().nothing();
        done();
      }, 10);
    });
  });
  describe('toggleEnabled', function () {
    it('should toggle enabled', function () {
      fixtureEl.innerHTML = '<a href="#" rel="tooltip" title="Another tooltip">';
      var tooltipEl = fixtureEl.querySelector('a');
      var tooltip = new _tooltip["default"](tooltipEl);
      expect(tooltip._isEnabled).toEqual(true);
      tooltip.toggleEnabled();
      expect(tooltip._isEnabled).toEqual(false);
    });
  });
  describe('toggle', function () {
    it('should do nothing if disabled', function (done) {
      fixtureEl.innerHTML = '<a href="#" rel="tooltip" title="Another tooltip">';
      var tooltipEl = fixtureEl.querySelector('a');
      var tooltip = new _tooltip["default"](tooltipEl);
      tooltip.disable();
      tooltipEl.addEventListener('show.bs.tooltip', function () {
        throw new Error('should not show a disabled tooltip');
      });
      tooltip.toggle();
      setTimeout(function () {
        expect().nothing();
        done();
      }, 10);
    });
    it('should show a tooltip', function (done) {
      fixtureEl.innerHTML = '<a href="#" rel="tooltip" title="Another tooltip">';
      var tooltipEl = fixtureEl.querySelector('a');
      var tooltip = new _tooltip["default"](tooltipEl);
      tooltipEl.addEventListener('shown.bs.tooltip', function () {
        expect(document.querySelector('.tooltip')).not.toBeNull();
        done();
      });
      tooltip.toggle();
    });
    it('should call toggle and show the tooltip when trigger is "click"', function (done) {
      fixtureEl.innerHTML = '<a href="#" rel="tooltip" title="Another tooltip">';
      var tooltipEl = fixtureEl.querySelector('a');
      var tooltip = new _tooltip["default"](tooltipEl, {
        trigger: 'click'
      });
      spyOn(tooltip, 'toggle').and.callThrough();
      tooltipEl.addEventListener('shown.bs.tooltip', function () {
        expect(tooltip.toggle).toHaveBeenCalled();
        done();
      });
      tooltipEl.click();
    });
    it('should hide a tooltip', function (done) {
      fixtureEl.innerHTML = '<a href="#" rel="tooltip" title="Another tooltip">';
      var tooltipEl = fixtureEl.querySelector('a');
      var tooltip = new _tooltip["default"](tooltipEl);
      tooltipEl.addEventListener('shown.bs.tooltip', function () {
        tooltip.toggle();
      });
      tooltipEl.addEventListener('hidden.bs.tooltip', function () {
        expect(document.querySelector('.tooltip')).toBeNull();
        done();
      });
      tooltip.toggle();
    });
    it('should call toggle and hide the tooltip when trigger is "click"', function (done) {
      fixtureEl.innerHTML = '<a href="#" rel="tooltip" title="Another tooltip">';
      var tooltipEl = fixtureEl.querySelector('a');
      var tooltip = new _tooltip["default"](tooltipEl, {
        trigger: 'click'
      });
      spyOn(tooltip, 'toggle').and.callThrough();
      tooltipEl.addEventListener('shown.bs.tooltip', function () {
        tooltipEl.click();
      });
      tooltipEl.addEventListener('hidden.bs.tooltip', function () {
        expect(tooltip.toggle).toHaveBeenCalled();
        done();
      });
      tooltipEl.click();
    });
  });
  describe('dispose', function () {
    it('should destroy a tooltip', function () {
      fixtureEl.innerHTML = '<a href="#" rel="tooltip" title="Another tooltip">';
      var tooltipEl = fixtureEl.querySelector('a');
      var addEventSpy = spyOn(tooltipEl, 'addEventListener').and.callThrough();
      var removeEventSpy = spyOn(tooltipEl, 'removeEventListener').and.callThrough();
      var tooltip = new _tooltip["default"](tooltipEl);
      expect(_tooltip["default"].getInstance(tooltipEl)).toEqual(tooltip);
      var expectedArgs = [['mouseover', jasmine.any(Function), jasmine.any(Boolean)], ['mouseout', jasmine.any(Function), jasmine.any(Boolean)], ['focusin', jasmine.any(Function), jasmine.any(Boolean)], ['focusout', jasmine.any(Function), jasmine.any(Boolean)]];
      expect(addEventSpy.calls.allArgs()).toEqual(expectedArgs);
      tooltip.dispose();
      expect(_tooltip["default"].getInstance(tooltipEl)).toEqual(null);
      expect(removeEventSpy.calls.allArgs()).toEqual(expectedArgs);
    });
    it('should destroy a tooltip after it is shown and hidden', function (done) {
      fixtureEl.innerHTML = '<a href="#" rel="tooltip" title="Another tooltip">';
      var tooltipEl = fixtureEl.querySelector('a');
      var tooltip = new _tooltip["default"](tooltipEl);
      tooltipEl.addEventListener('shown.bs.tooltip', function () {
        tooltip.hide();
      });
      tooltipEl.addEventListener('hidden.bs.tooltip', function () {
        tooltip.dispose();
        expect(tooltip.tip).toEqual(null);
        expect(_tooltip["default"].getInstance(tooltipEl)).toEqual(null);
        done();
      });
      tooltip.show();
    });
    it('should destroy a tooltip and remove it from the dom', function (done) {
      fixtureEl.innerHTML = '<a href="#" rel="tooltip" title="Another tooltip">';
      var tooltipEl = fixtureEl.querySelector('a');
      var tooltip = new _tooltip["default"](tooltipEl);
      tooltipEl.addEventListener('shown.bs.tooltip', function () {
        expect(document.querySelector('.tooltip')).not.toBeNull();
        tooltip.dispose();
        expect(document.querySelector('.tooltip')).toBeNull();
        done();
      });
      tooltip.show();
    });
  });
  describe('show', function () {
    it('should show a tooltip', function (done) {
      fixtureEl.innerHTML = '<a href="#" rel="tooltip" title="Another tooltip">';
      var tooltipEl = fixtureEl.querySelector('a');
      var tooltip = new _tooltip["default"](tooltipEl);
      tooltipEl.addEventListener('shown.bs.tooltip', function () {
        var tooltipShown = document.querySelector('.tooltip');
        expect(tooltipShown).not.toBeNull();
        expect(tooltipEl.getAttribute('aria-describedby')).toEqual(tooltipShown.getAttribute('id'));
        expect(tooltipShown.getAttribute('id')).toContain('tooltip');
        done();
      });
      tooltip.show();
    });
    it('should show a tooltip when hovering a children element', function (done) {
      fixtureEl.innerHTML = '<a href="#" rel="tooltip" title="Another tooltip">' + '<svg xmlns="http://www.w3.org/2000/svg" width="50" height="50" viewBox="0 0 100 100">' + '<rect width="100%" fill="#563d7c"/>' + '<circle cx="50" cy="50" r="30" fill="#fff"/>' + '</svg>' + '</a>';
      var tooltipEl = fixtureEl.querySelector('a');
      var tooltip = new _tooltip["default"](tooltipEl);
      spyOn(tooltip, 'show');
      tooltipEl.querySelector('rect').dispatchEvent((0, _fixture.createEvent)('mouseover', {
        bubbles: true
      }));
      setTimeout(function () {
        expect(tooltip.show).toHaveBeenCalled();
        done();
      }, 0);
    });
    it('should show a tooltip on mobile', function (done) {
      fixtureEl.innerHTML = '<a href="#" rel="tooltip" title="Another tooltip">';
      var tooltipEl = fixtureEl.querySelector('a');
      var tooltip = new _tooltip["default"](tooltipEl);
      document.documentElement.ontouchstart = _index.noop;
      spyOn(_eventHandler["default"], 'on').and.callThrough();
      tooltipEl.addEventListener('shown.bs.tooltip', function () {
        expect(document.querySelector('.tooltip')).not.toBeNull();
        expect(_eventHandler["default"].on).toHaveBeenCalledWith(jasmine.any(Object), 'mouseover', _index.noop);
        document.documentElement.ontouchstart = undefined;
        done();
      });
      tooltip.show();
    });
    it('should show a tooltip relative to placement option', function (done) {
      fixtureEl.innerHTML = '<a href="#" rel="tooltip" title="Another tooltip">';
      var tooltipEl = fixtureEl.querySelector('a');
      var tooltip = new _tooltip["default"](tooltipEl, {
        placement: 'bottom'
      });
      tooltipEl.addEventListener('inserted.bs.tooltip', function () {
        expect(tooltip.getTipElement().classList.contains('bs-tooltip-bottom')).toEqual(true);
      });
      tooltipEl.addEventListener('shown.bs.tooltip', function () {
        var tooltipShown = document.querySelector('.tooltip');
        expect(tooltipShown.classList.contains('bs-tooltip-bottom')).toEqual(true);
        done();
      });
      tooltip.show();
    });
    it('should not error when trying to show a tooltip that has been removed from the dom', function (done) {
      fixtureEl.innerHTML = '<a href="#" rel="tooltip" title="Another tooltip">';
      var tooltipEl = fixtureEl.querySelector('a');
      var tooltip = new _tooltip["default"](tooltipEl);

      var firstCallback = function firstCallback() {
        tooltipEl.removeEventListener('shown.bs.tooltip', firstCallback);
        var tooltipShown = document.querySelector('.tooltip');
        tooltipShown.remove();
        tooltipEl.addEventListener('shown.bs.tooltip', function () {
          tooltipShown = document.querySelector('.tooltip');
          expect(tooltipShown).not.toBeNull();
          done();
        });
        tooltip.show();
      };

      tooltipEl.addEventListener('shown.bs.tooltip', firstCallback);
      tooltip.show();
    });
    it('should show a tooltip with a dom element container', function (done) {
      fixtureEl.innerHTML = '<a href="#" rel="tooltip" title="Another tooltip">';
      var tooltipEl = fixtureEl.querySelector('a');
      var tooltip = new _tooltip["default"](tooltipEl, {
        container: fixtureEl
      });
      tooltipEl.addEventListener('shown.bs.tooltip', function () {
        expect(fixtureEl.querySelector('.tooltip')).not.toBeNull();
        done();
      });
      tooltip.show();
    });
    it('should show a tooltip with a jquery element container', function (done) {
      fixtureEl.innerHTML = '<a href="#" rel="tooltip" title="Another tooltip">';
      var tooltipEl = fixtureEl.querySelector('a');
      var tooltip = new _tooltip["default"](tooltipEl, {
        container: {
          0: fixtureEl,
          jquery: 'jQuery'
        }
      });
      tooltipEl.addEventListener('shown.bs.tooltip', function () {
        expect(fixtureEl.querySelector('.tooltip')).not.toBeNull();
        done();
      });
      tooltip.show();
    });
    it('should show a tooltip with a selector in container', function (done) {
      fixtureEl.innerHTML = '<a href="#" rel="tooltip" title="Another tooltip">';
      var tooltipEl = fixtureEl.querySelector('a');
      var tooltip = new _tooltip["default"](tooltipEl, {
        container: '#fixture'
      });
      tooltipEl.addEventListener('shown.bs.tooltip', function () {
        expect(fixtureEl.querySelector('.tooltip')).not.toBeNull();
        done();
      });
      tooltip.show();
    });
    it('should show a tooltip with placement as a function', function (done) {
      fixtureEl.innerHTML = '<a href="#" rel="tooltip" title="Another tooltip">';
      var spy = jasmine.createSpy('placement').and.returnValue('top');
      var tooltipEl = fixtureEl.querySelector('a');
      var tooltip = new _tooltip["default"](tooltipEl, {
        placement: spy
      });
      tooltipEl.addEventListener('shown.bs.tooltip', function () {
        expect(document.querySelector('.tooltip')).not.toBeNull();
        expect(spy).toHaveBeenCalled();
        done();
      });
      tooltip.show();
    });
    it('should show a tooltip without the animation', function (done) {
      fixtureEl.innerHTML = '<a href="#" rel="tooltip" title="Another tooltip">';
      var tooltipEl = fixtureEl.querySelector('a');
      var tooltip = new _tooltip["default"](tooltipEl, {
        animation: false
      });
      tooltipEl.addEventListener('shown.bs.tooltip', function () {
        var tip = document.querySelector('.tooltip');
        expect(tip).not.toBeNull();
        expect(tip.classList.contains('fade')).toEqual(false);
        done();
      });
      tooltip.show();
    });
    it('should throw an error the element is not visible', function () {
      fixtureEl.innerHTML = '<a href="#" style="display: none" rel="tooltip" title="Another tooltip">';
      var tooltipEl = fixtureEl.querySelector('a');
      var tooltip = new _tooltip["default"](tooltipEl);

      try {
        tooltip.show();
      } catch (error) {
        expect(error.message).toEqual('Please use show on visible elements');
      }
    });
    it('should not show a tooltip if show.bs.tooltip is prevented', function (done) {
      fixtureEl.innerHTML = '<a href="#" rel="tooltip" title="Another tooltip">';
      var tooltipEl = fixtureEl.querySelector('a');
      var tooltip = new _tooltip["default"](tooltipEl);

      var expectedDone = function expectedDone() {
        setTimeout(function () {
          expect(document.querySelector('.tooltip')).toBeNull();
          done();
        }, 10);
      };

      tooltipEl.addEventListener('show.bs.tooltip', function (ev) {
        ev.preventDefault();
        expectedDone();
      });
      tooltipEl.addEventListener('shown.bs.tooltip', function () {
        throw new Error('Tooltip should not be shown');
      });
      tooltip.show();
    });
    it('should show tooltip if leave event hasn\'t occurred before delay expires', function (done) {
      fixtureEl.innerHTML = '<a href="#" rel="tooltip" title="Another tooltip">';
      var tooltipEl = fixtureEl.querySelector('a');
      var tooltip = new _tooltip["default"](tooltipEl, {
        delay: 150
      });
      spyOn(tooltip, 'show');
      setTimeout(function () {
        expect(tooltip.show).not.toHaveBeenCalled();
      }, 100);
      setTimeout(function () {
        expect(tooltip.show).toHaveBeenCalled();
        done();
      }, 200);
      tooltipEl.dispatchEvent((0, _fixture.createEvent)('mouseover'));
    });
    it('should not show tooltip if leave event occurs before delay expires', function (done) {
      fixtureEl.innerHTML = '<a href="#" rel="tooltip" title="Another tooltip">';
      var tooltipEl = fixtureEl.querySelector('a');
      var tooltip = new _tooltip["default"](tooltipEl, {
        delay: 150
      });
      spyOn(tooltip, 'show');
      setTimeout(function () {
        expect(tooltip.show).not.toHaveBeenCalled();
        tooltipEl.dispatchEvent((0, _fixture.createEvent)('mouseover'));
      }, 100);
      setTimeout(function () {
        expect(tooltip.show).toHaveBeenCalled();
        expect(document.querySelectorAll('.tooltip').length).toEqual(0);
        done();
      }, 200);
      tooltipEl.dispatchEvent((0, _fixture.createEvent)('mouseover'));
    });
    it('should not hide tooltip if leave event occurs and enter event occurs within the hide delay', function (done) {
      fixtureEl.innerHTML = '<a href="#" rel="tooltip" title="Another tooltip">';
      var tooltipEl = fixtureEl.querySelector('a');
      var tooltip = new _tooltip["default"](tooltipEl, {
        delay: {
          show: 0,
          hide: 150
        }
      });
      setTimeout(function () {
        expect(tooltip.getTipElement().classList.contains('show')).toEqual(true);
        tooltipEl.dispatchEvent((0, _fixture.createEvent)('mouseout'));
        setTimeout(function () {
          expect(tooltip.getTipElement().classList.contains('show')).toEqual(true);
          tooltipEl.dispatchEvent((0, _fixture.createEvent)('mouseover'));
        }, 100);
        setTimeout(function () {
          expect(tooltip.getTipElement().classList.contains('show')).toEqual(true);
          done();
        }, 200);
      }, 0);
      tooltipEl.dispatchEvent((0, _fixture.createEvent)('mouseover'));
    });
    it('should not hide tooltip if leave event occurs and interaction remains inside trigger', function (done) {
      fixtureEl.innerHTML = ['<a href="#" rel="tooltip" title="Another tooltip">', '<b>Trigger</b>', 'the tooltip', '</a>'];
      var tooltipEl = fixtureEl.querySelector('a');
      var tooltip = new _tooltip["default"](tooltipEl);
      var triggerChild = tooltipEl.querySelector('b');
      spyOn(tooltip, 'hide').and.callThrough();
      tooltipEl.addEventListener('mouseover', function () {
        var moveMouseToChildEvent = (0, _fixture.createEvent)('mouseout');
        Object.defineProperty(moveMouseToChildEvent, 'relatedTarget', {
          value: triggerChild
        });
        tooltipEl.dispatchEvent(moveMouseToChildEvent);
      });
      tooltipEl.addEventListener('mouseout', function () {
        expect(tooltip.hide).not.toHaveBeenCalled();
        done();
      });
      tooltipEl.dispatchEvent((0, _fixture.createEvent)('mouseover'));
    });
    it('should properly maintain tooltip state if leave event occurs and enter event occurs during hide transition', function (done) {
      // Style this tooltip to give it plenty of room for popper to do what it wants
      fixtureEl.innerHTML = '<a href="#" rel="tooltip" title="Another tooltip" data-bs-placement="top" style="position:fixed;left:50%;top:50%;">Trigger</a>';
      var tooltipEl = fixtureEl.querySelector('a');
      var tooltip = new _tooltip["default"](tooltipEl);
      spyOn(window, 'getComputedStyle').and.returnValue({
        transitionDuration: '0.15s',
        transitionDelay: '0s'
      });
      setTimeout(function () {
        expect(tooltip._popper).not.toBeNull();
        expect(tooltip.getTipElement().getAttribute('data-popper-placement')).toBe('top');
        tooltipEl.dispatchEvent((0, _fixture.createEvent)('mouseout'));
        setTimeout(function () {
          expect(tooltip.getTipElement().classList.contains('show')).toEqual(false);
          tooltipEl.dispatchEvent((0, _fixture.createEvent)('mouseover'));
        }, 100);
        setTimeout(function () {
          expect(tooltip._popper).not.toBeNull();
          expect(tooltip.getTipElement().getAttribute('data-popper-placement')).toBe('top');
          done();
        }, 200);
      }, 0);
      tooltipEl.dispatchEvent((0, _fixture.createEvent)('mouseover'));
    });
    it('should only trigger inserted event if a new tooltip element was created', function (done) {
      fixtureEl.innerHTML = '<a href="#" rel="tooltip" title="Another tooltip">';
      var tooltipEl = fixtureEl.querySelector('a');
      var tooltip = new _tooltip["default"](tooltipEl);
      spyOn(window, 'getComputedStyle').and.returnValue({
        transitionDuration: '0.15s',
        transitionDelay: '0s'
      });
      var insertedFunc = jasmine.createSpy();
      tooltipEl.addEventListener('inserted.bs.tooltip', insertedFunc);
      setTimeout(function () {
        expect(insertedFunc).toHaveBeenCalledTimes(1);
        tooltip.hide();
        setTimeout(function () {
          tooltip.show();
        }, 100);
        setTimeout(function () {
          expect(insertedFunc).toHaveBeenCalledTimes(1);
          done();
        }, 200);
      }, 0);
      tooltip.show();
    });
    it('should show a tooltip with custom class provided in data attributes', function (done) {
      fixtureEl.innerHTML = '<a href="#" rel="tooltip" title="Another tooltip" data-bs-custom-class="custom-class">';
      var tooltipEl = fixtureEl.querySelector('a');
      var tooltip = new _tooltip["default"](tooltipEl);
      tooltipEl.addEventListener('shown.bs.tooltip', function () {
        var tip = document.querySelector('.tooltip');
        expect(tip).not.toBeNull();
        expect(tip.classList.contains('custom-class')).toBeTrue();
        done();
      });
      tooltip.show();
    });
    it('should show a tooltip with custom class provided as a string in config', function (done) {
      fixtureEl.innerHTML = '<a href="#" rel="tooltip" title="Another tooltip">';
      var tooltipEl = fixtureEl.querySelector('a');
      var tooltip = new _tooltip["default"](tooltipEl, {
        customClass: 'custom-class custom-class-2'
      });
      tooltipEl.addEventListener('shown.bs.tooltip', function () {
        var tip = document.querySelector('.tooltip');
        expect(tip).not.toBeNull();
        expect(tip.classList.contains('custom-class')).toBeTrue();
        expect(tip.classList.contains('custom-class-2')).toBeTrue();
        done();
      });
      tooltip.show();
    });
    it('should show a tooltip with custom class provided as a function in config', function (done) {
      fixtureEl.innerHTML = '<a href="#" rel="tooltip" title="Another tooltip">';
      var spy = jasmine.createSpy('customClass').and.returnValue('custom-class');
      var tooltipEl = fixtureEl.querySelector('a');
      var tooltip = new _tooltip["default"](tooltipEl, {
        customClass: spy
      });
      tooltipEl.addEventListener('shown.bs.tooltip', function () {
        var tip = document.querySelector('.tooltip');
        expect(tip).not.toBeNull();
        expect(spy).toHaveBeenCalled();
        expect(tip.classList.contains('custom-class')).toBeTrue();
        done();
      });
      tooltip.show();
    });
  });
  describe('hide', function () {
    it('should hide a tooltip', function (done) {
      fixtureEl.innerHTML = '<a href="#" rel="tooltip" title="Another tooltip">';
      var tooltipEl = fixtureEl.querySelector('a');
      var tooltip = new _tooltip["default"](tooltipEl);
      tooltipEl.addEventListener('shown.bs.tooltip', function () {
        return tooltip.hide();
      });
      tooltipEl.addEventListener('hidden.bs.tooltip', function () {
        expect(document.querySelector('.tooltip')).toBeNull();
        expect(tooltipEl.getAttribute('aria-describedby')).toBeNull();
        done();
      });
      tooltip.show();
    });
    it('should hide a tooltip on mobile', function (done) {
      fixtureEl.innerHTML = '<a href="#" rel="tooltip" title="Another tooltip">';
      var tooltipEl = fixtureEl.querySelector('a');
      var tooltip = new _tooltip["default"](tooltipEl);
      tooltipEl.addEventListener('shown.bs.tooltip', function () {
        document.documentElement.ontouchstart = _index.noop;
        spyOn(_eventHandler["default"], 'off');
        tooltip.hide();
      });
      tooltipEl.addEventListener('hidden.bs.tooltip', function () {
        expect(document.querySelector('.tooltip')).toBeNull();
        expect(_eventHandler["default"].off).toHaveBeenCalledWith(jasmine.any(Object), 'mouseover', _index.noop);
        document.documentElement.ontouchstart = undefined;
        done();
      });
      tooltip.show();
    });
    it('should hide a tooltip without animation', function (done) {
      fixtureEl.innerHTML = '<a href="#" rel="tooltip" title="Another tooltip">';
      var tooltipEl = fixtureEl.querySelector('a');
      var tooltip = new _tooltip["default"](tooltipEl, {
        animation: false
      });
      tooltipEl.addEventListener('shown.bs.tooltip', function () {
        return tooltip.hide();
      });
      tooltipEl.addEventListener('hidden.bs.tooltip', function () {
        expect(document.querySelector('.tooltip')).toBeNull();
        expect(tooltipEl.getAttribute('aria-describedby')).toBeNull();
        done();
      });
      tooltip.show();
    });
    it('should not hide a tooltip if hide event is prevented', function (done) {
      fixtureEl.innerHTML = '<a href="#" rel="tooltip" title="Another tooltip">';

      var assertDone = function assertDone() {
        setTimeout(function () {
          expect(document.querySelector('.tooltip')).not.toBeNull();
          done();
        }, 20);
      };

      var tooltipEl = fixtureEl.querySelector('a');
      var tooltip = new _tooltip["default"](tooltipEl, {
        animation: false
      });
      tooltipEl.addEventListener('shown.bs.tooltip', function () {
        return tooltip.hide();
      });
      tooltipEl.addEventListener('hide.bs.tooltip', function (event) {
        event.preventDefault();
        assertDone();
      });
      tooltipEl.addEventListener('hidden.bs.tooltip', function () {
        throw new Error('should not trigger hidden event');
      });
      tooltip.show();
    });
    it('should not throw error running hide if popper hasn\'t been shown', function () {
      fixtureEl.innerHTML = '<div></div>';
      var div = fixtureEl.querySelector('div');
      var tooltip = new _tooltip["default"](div);

      try {
        tooltip.hide();
        expect().nothing();
      } catch (_unused) {
        throw new Error('should not throw error');
      }
    });
  });
  describe('update', function () {
    it('should call popper update', function (done) {
      fixtureEl.innerHTML = '<a href="#" rel="tooltip" title="Another tooltip">';
      var tooltipEl = fixtureEl.querySelector('a');
      var tooltip = new _tooltip["default"](tooltipEl);
      tooltipEl.addEventListener('shown.bs.tooltip', function () {
        spyOn(tooltip._popper, 'update');
        tooltip.update();
        expect(tooltip._popper.update).toHaveBeenCalled();
        done();
      });
      tooltip.show();
    });
    it('should do nothing if the tooltip is not shown', function () {
      fixtureEl.innerHTML = '<a href="#" rel="tooltip" title="Another tooltip">';
      var tooltipEl = fixtureEl.querySelector('a');
      var tooltip = new _tooltip["default"](tooltipEl);
      tooltip.update();
      expect().nothing();
    });
  });
  describe('isWithContent', function () {
    it('should return true if there is content', function () {
      fixtureEl.innerHTML = '<a href="#" rel="tooltip" title="Another tooltip">';
      var tooltipEl = fixtureEl.querySelector('a');
      var tooltip = new _tooltip["default"](tooltipEl);
      expect(tooltip.isWithContent()).toEqual(true);
    });
    it('should return false if there is no content', function () {
      fixtureEl.innerHTML = '<a href="#" rel="tooltip" title="">';
      var tooltipEl = fixtureEl.querySelector('a');
      var tooltip = new _tooltip["default"](tooltipEl);
      expect(tooltip.isWithContent()).toEqual(false);
    });
  });
  describe('getTipElement', function () {
    it('should create the tip element and return it', function () {
      fixtureEl.innerHTML = '<a href="#" rel="tooltip" title="Another tooltip">';
      var tooltipEl = fixtureEl.querySelector('a');
      var tooltip = new _tooltip["default"](tooltipEl);
      spyOn(document, 'createElement').and.callThrough();
      expect(tooltip.getTipElement()).toBeDefined();
      expect(document.createElement).toHaveBeenCalled();
    });
    it('should return the created tip element', function () {
      fixtureEl.innerHTML = '<a href="#" rel="tooltip" title="Another tooltip">';
      var tooltipEl = fixtureEl.querySelector('a');
      var tooltip = new _tooltip["default"](tooltipEl);
      var spy = spyOn(document, 'createElement').and.callThrough();
      expect(tooltip.getTipElement()).toBeDefined();
      expect(spy).toHaveBeenCalled();
      spy.calls.reset();
      expect(tooltip.getTipElement()).toBeDefined();
      expect(spy).not.toHaveBeenCalled();
    });
  });
  describe('setContent', function () {
    it('should set tip content', function () {
      fixtureEl.innerHTML = '<a href="#" rel="tooltip" title="Another tooltip">';
      var tooltipEl = fixtureEl.querySelector('a');
      var tooltip = new _tooltip["default"](tooltipEl);
      var tip = tooltip.getTipElement();
      tooltip.setContent(tip);
      expect(tip.classList.contains('show')).toEqual(false);
      expect(tip.classList.contains('fade')).toEqual(false);
      expect(tip.querySelector('.tooltip-inner').textContent).toEqual('Another tooltip');
    });
  });
  describe('updateAttachment', function () {
    it('should use end class name when right placement specified', function (done) {
      fixtureEl.innerHTML = '<a href="#" rel="tooltip" title="Another tooltip">';
      var tooltipEl = fixtureEl.querySelector('a');
      var tooltip = new _tooltip["default"](tooltipEl, {
        placement: 'right'
      });
      tooltipEl.addEventListener('inserted.bs.tooltip', function () {
        expect(tooltip.getTipElement().classList.contains('bs-tooltip-end')).toEqual(true);
        done();
      });
      tooltip.show();
    });
    it('should use start class name when left placement specified', function (done) {
      fixtureEl.innerHTML = '<a href="#" rel="tooltip" title="Another tooltip">';
      var tooltipEl = fixtureEl.querySelector('a');
      var tooltip = new _tooltip["default"](tooltipEl, {
        placement: 'left'
      });
      tooltipEl.addEventListener('inserted.bs.tooltip', function () {
        expect(tooltip.getTipElement().classList.contains('bs-tooltip-start')).toEqual(true);
        done();
      });
      tooltip.show();
    });
  });
  describe('setElementContent', function () {
    it('should do nothing if the element is null', function () {
      fixtureEl.innerHTML = '<a href="#" rel="tooltip" title="Another tooltip">';
      var tooltipEl = fixtureEl.querySelector('a');
      var tooltip = new _tooltip["default"](tooltipEl);
      tooltip.setElementContent(null, null);
      expect().nothing();
    });
    it('should add the content as a child of the element', function () {
      fixtureEl.innerHTML = ['<a href="#" rel="tooltip" title="Another tooltip">', '<div id="childContent"></div>'].join('');
      var tooltipEl = fixtureEl.querySelector('a');
      var childContent = fixtureEl.querySelector('div');
      var tooltip = new _tooltip["default"](tooltipEl, {
        html: true
      });
      tooltip.setElementContent(tooltip.getTipElement(), childContent);
      expect(childContent.parentNode).toEqual(tooltip.getTipElement());
    });
    it('should do nothing if the content is a child of the element', function () {
      fixtureEl.innerHTML = ['<a href="#" rel="tooltip" title="Another tooltip">', '<div id="childContent"></div>'].join('');
      var tooltipEl = fixtureEl.querySelector('a');
      var childContent = fixtureEl.querySelector('div');
      var tooltip = new _tooltip["default"](tooltipEl, {
        html: true
      });
      tooltip.getTipElement().append(childContent);
      tooltip.setElementContent(tooltip.getTipElement(), childContent);
      expect().nothing();
    });
    it('should add the content as a child of the element for jQuery elements', function () {
      fixtureEl.innerHTML = ['<a href="#" rel="tooltip" title="Another tooltip">', '<div id="childContent"></div>'].join('');
      var tooltipEl = fixtureEl.querySelector('a');
      var childContent = fixtureEl.querySelector('div');
      var tooltip = new _tooltip["default"](tooltipEl, {
        html: true
      });
      tooltip.setElementContent(tooltip.getTipElement(), {
        0: childContent,
        jquery: 'jQuery'
      });
      expect(childContent.parentNode).toEqual(tooltip.getTipElement());
    });
    it('should add the child text content in the element', function () {
      fixtureEl.innerHTML = ['<a href="#" rel="tooltip" title="Another tooltip">', '<div id="childContent">Tooltip</div>'].join('');
      var tooltipEl = fixtureEl.querySelector('a');
      var childContent = fixtureEl.querySelector('div');
      var tooltip = new _tooltip["default"](tooltipEl);
      tooltip.setElementContent(tooltip.getTipElement(), childContent);
      expect(childContent.textContent).toEqual(tooltip.getTipElement().textContent);
    });
    it('should add html without sanitize it', function () {
      fixtureEl.innerHTML = '<a href="#" rel="tooltip" title="Another tooltip">';
      var tooltipEl = fixtureEl.querySelector('a');
      var tooltip = new _tooltip["default"](tooltipEl, {
        sanitize: false,
        html: true
      });
      tooltip.setElementContent(tooltip.getTipElement(), '<div id="childContent">Tooltip</div>');
      expect(tooltip.getTipElement().querySelector('div').id).toEqual('childContent');
    });
    it('should add html sanitized', function () {
      fixtureEl.innerHTML = '<a href="#" rel="tooltip" title="Another tooltip">';
      var tooltipEl = fixtureEl.querySelector('a');
      var tooltip = new _tooltip["default"](tooltipEl, {
        html: true
      });
      tooltip.setElementContent(tooltip.getTipElement(), ['<div id="childContent">', ' <button type="button">test btn</button>', '</div>'].join(''));
      expect(tooltip.getTipElement().querySelector('div').id).toEqual('childContent');
      expect(tooltip.getTipElement().querySelector('button')).toEqual(null);
    });
    it('should add text content', function () {
      fixtureEl.innerHTML = '<a href="#" rel="tooltip" title="Another tooltip">';
      var tooltipEl = fixtureEl.querySelector('a');
      var tooltip = new _tooltip["default"](tooltipEl);
      tooltip.setElementContent(tooltip.getTipElement(), 'test');
      expect(tooltip.getTipElement().textContent).toEqual('test');
    });
  });
  describe('getTitle', function () {
    it('should return the title', function () {
      fixtureEl.innerHTML = '<a href="#" rel="tooltip" title="Another tooltip">';
      var tooltipEl = fixtureEl.querySelector('a');
      var tooltip = new _tooltip["default"](tooltipEl);
      expect(tooltip.getTitle()).toEqual('Another tooltip');
    });
    it('should call title function', function () {
      fixtureEl.innerHTML = '<a href="#" rel="tooltip"></a>';
      var tooltipEl = fixtureEl.querySelector('a');
      var tooltip = new _tooltip["default"](tooltipEl, {
        title: function title() {
          return 'test';
        }
      });
      expect(tooltip.getTitle()).toEqual('test');
    });
  });
  describe('getInstance', function () {
    it('should return tooltip instance', function () {
      fixtureEl.innerHTML = '<div></div>';
      var div = fixtureEl.querySelector('div');
      var alert = new _tooltip["default"](div);
      expect(_tooltip["default"].getInstance(div)).toEqual(alert);
      expect(_tooltip["default"].getInstance(div)).toBeInstanceOf(_tooltip["default"]);
    });
    it('should return null when there is no tooltip instance', function () {
      fixtureEl.innerHTML = '<div></div>';
      var div = fixtureEl.querySelector('div');
      expect(_tooltip["default"].getInstance(div)).toEqual(null);
    });
  });
  describe('aria-label', function () {
    it('should add the aria-label attribute for referencing original title', function (done) {
      fixtureEl.innerHTML = '<a href="#" rel="tooltip" title="Another tooltip"></a>';
      var tooltipEl = fixtureEl.querySelector('a');
      var tooltip = new _tooltip["default"](tooltipEl);
      tooltipEl.addEventListener('shown.bs.tooltip', function () {
        var tooltipShown = document.querySelector('.tooltip');
        expect(tooltipShown).not.toBeNull();
        expect(tooltipEl.getAttribute('aria-label')).toEqual('Another tooltip');
        done();
      });
      tooltip.show();
    });
    it('should not add the aria-label attribute if the attribute already exists', function (done) {
      fixtureEl.innerHTML = '<a href="#" rel="tooltip" aria-label="Different label" title="Another tooltip"></a>';
      var tooltipEl = fixtureEl.querySelector('a');
      var tooltip = new _tooltip["default"](tooltipEl);
      tooltipEl.addEventListener('shown.bs.tooltip', function () {
        var tooltipShown = document.querySelector('.tooltip');
        expect(tooltipShown).not.toBeNull();
        expect(tooltipEl.getAttribute('aria-label')).toEqual('Different label');
        done();
      });
      tooltip.show();
    });
    it('should not add the aria-label attribute if the element has text content', function (done) {
      fixtureEl.innerHTML = '<a href="#" rel="tooltip" title="Another tooltip">text content</a>';
      var tooltipEl = fixtureEl.querySelector('a');
      var tooltip = new _tooltip["default"](tooltipEl);
      tooltipEl.addEventListener('shown.bs.tooltip', function () {
        var tooltipShown = document.querySelector('.tooltip');
        expect(tooltipShown).not.toBeNull();
        expect(tooltipEl.getAttribute('aria-label')).toBeNull();
        done();
      });
      tooltip.show();
    });
  });
  describe('getOrCreateInstance', function () {
    it('should return tooltip instance', function () {
      fixtureEl.innerHTML = '<div></div>';
      var div = fixtureEl.querySelector('div');
      var tooltip = new _tooltip["default"](div);
      expect(_tooltip["default"].getOrCreateInstance(div)).toEqual(tooltip);
      expect(_tooltip["default"].getInstance(div)).toEqual(_tooltip["default"].getOrCreateInstance(div, {}));
      expect(_tooltip["default"].getOrCreateInstance(div)).toBeInstanceOf(_tooltip["default"]);
    });
    it('should return new instance when there is no tooltip instance', function () {
      fixtureEl.innerHTML = '<div></div>';
      var div = fixtureEl.querySelector('div');
      expect(_tooltip["default"].getInstance(div)).toEqual(null);
      expect(_tooltip["default"].getOrCreateInstance(div)).toBeInstanceOf(_tooltip["default"]);
    });
    it('should return new instance when there is no tooltip instance with given configuration', function () {
      fixtureEl.innerHTML = '<div></div>';
      var div = fixtureEl.querySelector('div');
      expect(_tooltip["default"].getInstance(div)).toEqual(null);

      var tooltip = _tooltip["default"].getOrCreateInstance(div, {
        title: function title() {
          return 'test';
        }
      });

      expect(tooltip).toBeInstanceOf(_tooltip["default"]);
      expect(tooltip.getTitle()).toEqual('test');
    });
    it('should return the instance when exists without given configuration', function () {
      fixtureEl.innerHTML = '<div></div>';
      var div = fixtureEl.querySelector('div');
      var tooltip = new _tooltip["default"](div, {
        title: function title() {
          return 'nothing';
        }
      });
      expect(_tooltip["default"].getInstance(div)).toEqual(tooltip);

      var tooltip2 = _tooltip["default"].getOrCreateInstance(div, {
        title: function title() {
          return 'test';
        }
      });

      expect(tooltip).toBeInstanceOf(_tooltip["default"]);
      expect(tooltip2).toEqual(tooltip);
      expect(tooltip2.getTitle()).toEqual('nothing');
    });
  });
  describe('jQueryInterface', function () {
    it('should create a tooltip', function () {
      fixtureEl.innerHTML = '<div></div>';
      var div = fixtureEl.querySelector('div');
      _fixture.jQueryMock.fn.tooltip = _tooltip["default"].jQueryInterface;
      _fixture.jQueryMock.elements = [div];

      _fixture.jQueryMock.fn.tooltip.call(_fixture.jQueryMock);

      expect(_tooltip["default"].getInstance(div)).not.toBeNull();
    });
    it('should not re create a tooltip', function () {
      fixtureEl.innerHTML = '<div></div>';
      var div = fixtureEl.querySelector('div');
      var tooltip = new _tooltip["default"](div);
      _fixture.jQueryMock.fn.tooltip = _tooltip["default"].jQueryInterface;
      _fixture.jQueryMock.elements = [div];

      _fixture.jQueryMock.fn.tooltip.call(_fixture.jQueryMock);

      expect(_tooltip["default"].getInstance(div)).toEqual(tooltip);
    });
    it('should call a tooltip method', function () {
      fixtureEl.innerHTML = '<div></div>';
      var div = fixtureEl.querySelector('div');
      var tooltip = new _tooltip["default"](div);
      spyOn(tooltip, 'show');
      _fixture.jQueryMock.fn.tooltip = _tooltip["default"].jQueryInterface;
      _fixture.jQueryMock.elements = [div];

      _fixture.jQueryMock.fn.tooltip.call(_fixture.jQueryMock, 'show');

      expect(_tooltip["default"].getInstance(div)).toEqual(tooltip);
      expect(tooltip.show).toHaveBeenCalled();
    });
    it('should throw error on undefined method', function () {
      fixtureEl.innerHTML = '<div></div>';
      var div = fixtureEl.querySelector('div');
      var action = 'undefinedMethod';
      _fixture.jQueryMock.fn.tooltip = _tooltip["default"].jQueryInterface;
      _fixture.jQueryMock.elements = [div];
      expect(function () {
        _fixture.jQueryMock.fn.tooltip.call(_fixture.jQueryMock, action);
      }).toThrowError(TypeError, "No method named \"".concat(action, "\""));
    });
  });
});
"use strict";

var _data = _interopRequireDefault(require("../../../src/dom/data"));

var _fixture = require("../../helpers/fixture");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

describe('Data', function () {
  var TEST_KEY = 'bs.test';
  var UNKNOWN_KEY = 'bs.unknown';
  var TEST_DATA = {
    test: 'bsData'
  };
  var fixtureEl;
  var div;
  beforeAll(function () {
    fixtureEl = (0, _fixture.getFixture)();
  });
  beforeEach(function () {
    fixtureEl.innerHTML = '<div></div>';
    div = fixtureEl.querySelector('div');
  });
  afterEach(function () {
    _data["default"].remove(div, TEST_KEY);

    (0, _fixture.clearFixture)();
  });
  it('should return null for unknown elements', function () {
    var data = _objectSpread({}, TEST_DATA);

    _data["default"].set(div, TEST_KEY, data);

    expect(_data["default"].get(null)).toBeNull();
    expect(_data["default"].get(undefined)).toBeNull();
    expect(_data["default"].get(document.createElement('div'), TEST_KEY)).toBeNull();
  });
  it('should return null for unknown keys', function () {
    var data = _objectSpread({}, TEST_DATA);

    _data["default"].set(div, TEST_KEY, data);

    expect(_data["default"].get(div, null)).toBeNull();
    expect(_data["default"].get(div, undefined)).toBeNull();
    expect(_data["default"].get(div, UNKNOWN_KEY)).toBeNull();
  });
  it('should store data for an element with a given key and return it', function () {
    var data = _objectSpread({}, TEST_DATA);

    _data["default"].set(div, TEST_KEY, data);

    expect(_data["default"].get(div, TEST_KEY)).toBe(data);
  });
  it('should overwrite data if something is already stored', function () {
    var data = _objectSpread({}, TEST_DATA);

    var copy = _objectSpread({}, data);

    _data["default"].set(div, TEST_KEY, data);

    _data["default"].set(div, TEST_KEY, copy);

    expect(_data["default"].get(div, TEST_KEY)).not.toBe(data);
    expect(_data["default"].get(div, TEST_KEY)).toBe(copy);
  });
  it('should do nothing when an element have nothing stored', function () {
    _data["default"].remove(div, TEST_KEY);

    expect().nothing();
  });
  it('should remove nothing for an unknown key', function () {
    var data = _objectSpread({}, TEST_DATA);

    _data["default"].set(div, TEST_KEY, data);

    _data["default"].remove(div, UNKNOWN_KEY);

    expect(_data["default"].get(div, TEST_KEY)).toBe(data);
  });
  it('should remove data for a given key', function () {
    var data = _objectSpread({}, TEST_DATA);

    _data["default"].set(div, TEST_KEY, data);

    _data["default"].remove(div, TEST_KEY);

    expect(_data["default"].get(div, TEST_KEY)).toBeNull();
  });
  it('should console.error a message if called with multiple keys', function () {
    /* eslint-disable no-console */
    console.error = jasmine.createSpy('console.error');

    var data = _objectSpread({}, TEST_DATA);

    var copy = _objectSpread({}, data);

    _data["default"].set(div, TEST_KEY, data);

    _data["default"].set(div, UNKNOWN_KEY, copy);

    expect(console.error).toHaveBeenCalled();
    expect(_data["default"].get(div, UNKNOWN_KEY)).toBe(null);
  });
});
"use strict";

var _eventHandler = _interopRequireDefault(require("../../../src/dom/event-handler"));

var _fixture = require("../../helpers/fixture");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/** Test helpers */
describe('EventHandler', function () {
  var fixtureEl;
  beforeAll(function () {
    fixtureEl = (0, _fixture.getFixture)();
  });
  afterEach(function () {
    (0, _fixture.clearFixture)();
  });
  describe('on', function () {
    it('should not add event listener if the event is not a string', function () {
      fixtureEl.innerHTML = '<div></div>';
      var div = fixtureEl.querySelector('div');

      _eventHandler["default"].on(div, null, function () {});

      _eventHandler["default"].on(null, 'click', function () {});

      expect().nothing();
    });
    it('should add event listener', function (done) {
      fixtureEl.innerHTML = '<div></div>';
      var div = fixtureEl.querySelector('div');

      _eventHandler["default"].on(div, 'click', function () {
        expect().nothing();
        done();
      });

      div.click();
    });
    it('should add namespaced event listener', function (done) {
      fixtureEl.innerHTML = '<div></div>';
      var div = fixtureEl.querySelector('div');

      _eventHandler["default"].on(div, 'bs.namespace', function () {
        expect().nothing();
        done();
      });

      _eventHandler["default"].trigger(div, 'bs.namespace');
    });
    it('should add native namespaced event listener', function (done) {
      fixtureEl.innerHTML = '<div></div>';
      var div = fixtureEl.querySelector('div');

      _eventHandler["default"].on(div, 'click.namespace', function () {
        expect().nothing();
        done();
      });

      _eventHandler["default"].trigger(div, 'click');
    });
    it('should handle event delegation', function (done) {
      _eventHandler["default"].on(document, 'click', '.test', function () {
        expect().nothing();
        done();
      });

      fixtureEl.innerHTML = '<div class="test"></div>';
      var div = fixtureEl.querySelector('div');
      div.click();
    });
    it('should handle mouseenter/mouseleave like the native counterpart', function (done) {
      fixtureEl.innerHTML = ['<div class="outer">', '<div class="inner">', '<div class="nested">', '<div class="deep"></div>', '</div>', '</div>', '<div class="sibling"></div>', '</div>'];
      var outer = fixtureEl.querySelector('.outer');
      var inner = fixtureEl.querySelector('.inner');
      var nested = fixtureEl.querySelector('.nested');
      var deep = fixtureEl.querySelector('.deep');
      var sibling = fixtureEl.querySelector('.sibling');
      var enterSpy = jasmine.createSpy('mouseenter');
      var leaveSpy = jasmine.createSpy('mouseleave');
      var delegateEnterSpy = jasmine.createSpy('mouseenter');
      var delegateLeaveSpy = jasmine.createSpy('mouseleave');

      _eventHandler["default"].on(inner, 'mouseenter', enterSpy);

      _eventHandler["default"].on(inner, 'mouseleave', leaveSpy);

      _eventHandler["default"].on(outer, 'mouseenter', '.inner', delegateEnterSpy);

      _eventHandler["default"].on(outer, 'mouseleave', '.inner', delegateLeaveSpy);

      _eventHandler["default"].on(sibling, 'mouseenter', function () {
        expect(enterSpy.calls.count()).toBe(2);
        expect(leaveSpy.calls.count()).toBe(2);
        expect(delegateEnterSpy.calls.count()).toBe(2);
        expect(delegateLeaveSpy.calls.count()).toBe(2);
        done();
      });

      var moveMouse = function moveMouse(from, to) {
        from.dispatchEvent(new MouseEvent('mouseout', {
          bubbles: true,
          relatedTarget: to
        }));
        to.dispatchEvent(new MouseEvent('mouseover', {
          bubbles: true,
          relatedTarget: from
        }));
      }; // from outer to deep and back to outer (nested)


      moveMouse(outer, inner);
      moveMouse(inner, nested);
      moveMouse(nested, deep);
      moveMouse(deep, nested);
      moveMouse(nested, inner);
      moveMouse(inner, outer);
      setTimeout(function () {
        expect(enterSpy.calls.count()).toBe(1);
        expect(leaveSpy.calls.count()).toBe(1);
        expect(delegateEnterSpy.calls.count()).toBe(1);
        expect(delegateLeaveSpy.calls.count()).toBe(1); // from outer to inner to sibling (adjacent)

        moveMouse(outer, inner);
        moveMouse(inner, sibling);
      }, 20);
    });
  });
  describe('one', function () {
    it('should call listener just once', function (done) {
      fixtureEl.innerHTML = '<div></div>';
      var called = 0;
      var div = fixtureEl.querySelector('div');
      var obj = {
        oneListener: function oneListener() {
          called++;
        }
      };

      _eventHandler["default"].one(div, 'bootstrap', obj.oneListener);

      _eventHandler["default"].trigger(div, 'bootstrap');

      _eventHandler["default"].trigger(div, 'bootstrap');

      setTimeout(function () {
        expect(called).toEqual(1);
        done();
      }, 20);
    });
    it('should call delegated listener just once', function (done) {
      fixtureEl.innerHTML = '<div></div>';
      var called = 0;
      var div = fixtureEl.querySelector('div');
      var obj = {
        oneListener: function oneListener() {
          called++;
        }
      };

      _eventHandler["default"].one(fixtureEl, 'bootstrap', 'div', obj.oneListener);

      _eventHandler["default"].trigger(div, 'bootstrap');

      _eventHandler["default"].trigger(div, 'bootstrap');

      setTimeout(function () {
        expect(called).toEqual(1);
        done();
      }, 20);
    });
  });
  describe('off', function () {
    it('should not remove a listener', function () {
      fixtureEl.innerHTML = '<div></div>';
      var div = fixtureEl.querySelector('div');

      _eventHandler["default"].off(div, null, function () {});

      _eventHandler["default"].off(null, 'click', function () {});

      expect().nothing();
    });
    it('should remove a listener', function (done) {
      fixtureEl.innerHTML = '<div></div>';
      var div = fixtureEl.querySelector('div');
      var called = 0;

      var handler = function handler() {
        called++;
      };

      _eventHandler["default"].on(div, 'foobar', handler);

      _eventHandler["default"].trigger(div, 'foobar');

      _eventHandler["default"].off(div, 'foobar', handler);

      _eventHandler["default"].trigger(div, 'foobar');

      setTimeout(function () {
        expect(called).toEqual(1);
        done();
      }, 20);
    });
    it('should remove all the events', function (done) {
      fixtureEl.innerHTML = '<div></div>';
      var div = fixtureEl.querySelector('div');
      var called = 0;

      _eventHandler["default"].on(div, 'foobar', function () {
        called++;
      });

      _eventHandler["default"].on(div, 'foobar', function () {
        called++;
      });

      _eventHandler["default"].trigger(div, 'foobar');

      _eventHandler["default"].off(div, 'foobar');

      _eventHandler["default"].trigger(div, 'foobar');

      setTimeout(function () {
        expect(called).toEqual(2);
        done();
      }, 20);
    });
    it('should remove all the namespaced listeners if namespace is passed', function (done) {
      fixtureEl.innerHTML = '<div></div>';
      var div = fixtureEl.querySelector('div');
      var called = 0;

      _eventHandler["default"].on(div, 'foobar.namespace', function () {
        called++;
      });

      _eventHandler["default"].on(div, 'foofoo.namespace', function () {
        called++;
      });

      _eventHandler["default"].trigger(div, 'foobar.namespace');

      _eventHandler["default"].trigger(div, 'foofoo.namespace');

      _eventHandler["default"].off(div, '.namespace');

      _eventHandler["default"].trigger(div, 'foobar.namespace');

      _eventHandler["default"].trigger(div, 'foofoo.namespace');

      setTimeout(function () {
        expect(called).toEqual(2);
        done();
      }, 20);
    });
    it('should remove the namespaced listeners', function (done) {
      fixtureEl.innerHTML = '<div></div>';
      var div = fixtureEl.querySelector('div');
      var calledCallback1 = 0;
      var calledCallback2 = 0;

      _eventHandler["default"].on(div, 'foobar.namespace', function () {
        calledCallback1++;
      });

      _eventHandler["default"].on(div, 'foofoo.namespace', function () {
        calledCallback2++;
      });

      _eventHandler["default"].trigger(div, 'foobar.namespace');

      _eventHandler["default"].off(div, 'foobar.namespace');

      _eventHandler["default"].trigger(div, 'foobar.namespace');

      _eventHandler["default"].trigger(div, 'foofoo.namespace');

      setTimeout(function () {
        expect(calledCallback1).toEqual(1);
        expect(calledCallback2).toEqual(1);
        done();
      }, 20);
    });
    it('should remove the all the namespaced listeners for native events', function (done) {
      fixtureEl.innerHTML = '<div></div>';
      var div = fixtureEl.querySelector('div');
      var called = 0;

      _eventHandler["default"].on(div, 'click.namespace', function () {
        called++;
      });

      _eventHandler["default"].on(div, 'click.namespace2', function () {
        called++;
      });

      _eventHandler["default"].trigger(div, 'click');

      _eventHandler["default"].off(div, 'click');

      _eventHandler["default"].trigger(div, 'click');

      setTimeout(function () {
        expect(called).toEqual(2);
        done();
      }, 20);
    });
    it('should remove the specified namespaced listeners for native events', function (done) {
      fixtureEl.innerHTML = '<div></div>';
      var div = fixtureEl.querySelector('div');
      var called1 = 0;
      var called2 = 0;

      _eventHandler["default"].on(div, 'click.namespace', function () {
        called1++;
      });

      _eventHandler["default"].on(div, 'click.namespace2', function () {
        called2++;
      });

      _eventHandler["default"].trigger(div, 'click');

      _eventHandler["default"].off(div, 'click.namespace');

      _eventHandler["default"].trigger(div, 'click');

      setTimeout(function () {
        expect(called1).toEqual(1);
        expect(called2).toEqual(2);
        done();
      }, 20);
    });
    it('should remove a listener registered by .one', function (done) {
      fixtureEl.innerHTML = '<div></div>';
      var div = fixtureEl.querySelector('div');

      var handler = function handler() {
        throw new Error('called');
      };

      _eventHandler["default"].one(div, 'foobar', handler);

      _eventHandler["default"].off(div, 'foobar', handler);

      _eventHandler["default"].trigger(div, 'foobar');

      setTimeout(function () {
        expect().nothing();
        done();
      }, 20);
    });
    it('should remove the correct delegated event listener', function () {
      var element = document.createElement('div');
      var subelement = document.createElement('span');
      element.append(subelement);
      var anchor = document.createElement('a');
      element.append(anchor);
      var i = 0;

      var handler = function handler() {
        i++;
      };

      _eventHandler["default"].on(element, 'click', 'a', handler);

      _eventHandler["default"].on(element, 'click', 'span', handler);

      fixtureEl.append(element);

      _eventHandler["default"].trigger(anchor, 'click');

      _eventHandler["default"].trigger(subelement, 'click'); // first listeners called


      expect(i).toEqual(2);

      _eventHandler["default"].off(element, 'click', 'span', handler);

      _eventHandler["default"].trigger(subelement, 'click'); // removed listener not called


      expect(i).toEqual(2);

      _eventHandler["default"].trigger(anchor, 'click'); // not removed listener called


      expect(i).toEqual(3);

      _eventHandler["default"].on(element, 'click', 'span', handler);

      _eventHandler["default"].trigger(anchor, 'click');

      _eventHandler["default"].trigger(subelement, 'click'); // listener re-registered


      expect(i).toEqual(5);

      _eventHandler["default"].off(element, 'click', 'span');

      _eventHandler["default"].trigger(subelement, 'click'); // listener removed again


      expect(i).toEqual(5);
    });
  });
});
"use strict";

var _manipulator = _interopRequireDefault(require("../../../src/dom/manipulator"));

var _fixture = require("../../helpers/fixture");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/** Test helpers */
describe('Manipulator', function () {
  var fixtureEl;
  beforeAll(function () {
    fixtureEl = (0, _fixture.getFixture)();
  });
  afterEach(function () {
    (0, _fixture.clearFixture)();
  });
  describe('setDataAttribute', function () {
    it('should set data attribute prefixed with bs', function () {
      fixtureEl.innerHTML = '<div></div>';
      var div = fixtureEl.querySelector('div');

      _manipulator["default"].setDataAttribute(div, 'key', 'value');

      expect(div.getAttribute('data-bs-key')).toEqual('value');
    });
    it('should set data attribute in kebab case', function () {
      fixtureEl.innerHTML = '<div></div>';
      var div = fixtureEl.querySelector('div');

      _manipulator["default"].setDataAttribute(div, 'testKey', 'value');

      expect(div.getAttribute('data-bs-test-key')).toEqual('value');
    });
  });
  describe('removeDataAttribute', function () {
    it('should only remove bs-prefixed data attribute', function () {
      fixtureEl.innerHTML = '<div data-bs-key="value" data-key-bs="postfixed" data-key="value"></div>';
      var div = fixtureEl.querySelector('div');

      _manipulator["default"].removeDataAttribute(div, 'key');

      expect(div.getAttribute('data-bs-key')).toBeNull();
      expect(div.getAttribute('data-key-bs')).toEqual('postfixed');
      expect(div.getAttribute('data-key')).toEqual('value');
    });
    it('should remove data attribute in kebab case', function () {
      fixtureEl.innerHTML = '<div data-bs-test-key="value"></div>';
      var div = fixtureEl.querySelector('div');

      _manipulator["default"].removeDataAttribute(div, 'testKey');

      expect(div.getAttribute('data-bs-test-key')).toBeNull();
    });
  });
  describe('getDataAttributes', function () {
    it('should return an empty object for null', function () {
      expect(_manipulator["default"].getDataAttributes(null)).toEqual({});
      expect().nothing();
    });
    it('should get only bs-prefixed data attributes without bs namespace', function () {
      fixtureEl.innerHTML = '<div data-bs-toggle="tabs" data-bs-target="#element" data-another="value" data-target-bs="#element" data-in-bs-out="in-between"></div>';
      var div = fixtureEl.querySelector('div');
      expect(_manipulator["default"].getDataAttributes(div)).toEqual({
        toggle: 'tabs',
        target: '#element'
      });
    });
  });
  describe('getDataAttribute', function () {
    it('should only get bs-prefixed data attribute', function () {
      fixtureEl.innerHTML = '<div data-bs-key="value" data-test-bs="postFixed" data-toggle="tab"></div>';
      var div = fixtureEl.querySelector('div');
      expect(_manipulator["default"].getDataAttribute(div, 'key')).toEqual('value');
      expect(_manipulator["default"].getDataAttribute(div, 'test')).toBeNull();
      expect(_manipulator["default"].getDataAttribute(div, 'toggle')).toBeNull();
    });
    it('should get data attribute in kebab case', function () {
      fixtureEl.innerHTML = '<div data-bs-test-key="value" ></div>';
      var div = fixtureEl.querySelector('div');
      expect(_manipulator["default"].getDataAttribute(div, 'testKey')).toEqual('value');
    });
    it('should normalize data', function () {
      fixtureEl.innerHTML = '<div data-bs-test="false" ></div>';
      var div = fixtureEl.querySelector('div');
      expect(_manipulator["default"].getDataAttribute(div, 'test')).toEqual(false);
      div.setAttribute('data-bs-test', 'true');
      expect(_manipulator["default"].getDataAttribute(div, 'test')).toEqual(true);
      div.setAttribute('data-bs-test', '1');
      expect(_manipulator["default"].getDataAttribute(div, 'test')).toEqual(1);
    });
  });
  describe('offset', function () {
    it('should return an object with two properties top and left, both numbers', function () {
      fixtureEl.innerHTML = '<div></div>';
      var div = fixtureEl.querySelector('div');

      var offset = _manipulator["default"].offset(div);

      expect(offset).toBeDefined();
      expect(offset.top).toEqual(jasmine.any(Number));
      expect(offset.left).toEqual(jasmine.any(Number));
    });
    it('should return offset relative to attached element\'s offset', function () {
      var top = 500;
      var left = 1000;
      fixtureEl.innerHTML = "<div style=\"position:absolute;top:".concat(top, "px;left:").concat(left, "px\"></div>");
      var div = fixtureEl.querySelector('div');

      var offset = _manipulator["default"].offset(div);

      var fixtureOffset = _manipulator["default"].offset(fixtureEl);

      expect(offset).toEqual({
        top: fixtureOffset.top + top,
        left: fixtureOffset.left + left
      });
    });
    it('should not change offset when viewport is scrolled', function (done) {
      var top = 500;
      var left = 1000;
      var scrollY = 200;
      var scrollX = 400;
      fixtureEl.innerHTML = "<div style=\"position:absolute;top:".concat(top, "px;left:").concat(left, "px\"></div>");
      var div = fixtureEl.querySelector('div');

      var offset = _manipulator["default"].offset(div); // append an element that forces scrollbars on the window so we can scroll


      var _fixtureEl$ownerDocum = fixtureEl.ownerDocument,
          win = _fixtureEl$ownerDocum.defaultView,
          body = _fixtureEl$ownerDocum.body;
      var forceScrollBars = document.createElement('div');
      forceScrollBars.style.cssText = 'position:absolute;top:5000px;left:5000px;width:1px;height:1px';
      body.append(forceScrollBars);

      var scrollHandler = function scrollHandler() {
        expect(window.pageYOffset).toBe(scrollY);
        expect(window.pageXOffset).toBe(scrollX);

        var newOffset = _manipulator["default"].offset(div);

        expect(newOffset).toEqual({
          top: offset.top,
          left: offset.left
        });
        win.removeEventListener('scroll', scrollHandler);
        forceScrollBars.remove();
        win.scrollTo(0, 0);
        done();
      };

      win.addEventListener('scroll', scrollHandler);
      win.scrollTo(scrollX, scrollY);
    });
  });
  describe('position', function () {
    it('should return an object with two properties top and left, both numbers', function () {
      fixtureEl.innerHTML = '<div></div>';
      var div = fixtureEl.querySelector('div');

      var position = _manipulator["default"].position(div);

      expect(position).toBeDefined();
      expect(position.top).toEqual(jasmine.any(Number));
      expect(position.left).toEqual(jasmine.any(Number));
    });
  });
});
"use strict";

var _selectorEngine = _interopRequireDefault(require("../../../src/dom/selector-engine"));

var _fixture = require("../../helpers/fixture");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

describe('SelectorEngine', function () {
  var fixtureEl;
  beforeAll(function () {
    fixtureEl = (0, _fixture.getFixture)();
  });
  afterEach(function () {
    (0, _fixture.clearFixture)();
  });
  describe('find', function () {
    it('should find elements', function () {
      fixtureEl.innerHTML = '<div></div>';
      var div = fixtureEl.querySelector('div');
      expect(_selectorEngine["default"].find('div', fixtureEl)).toEqual([div]);
    });
    it('should find elements globaly', function () {
      fixtureEl.innerHTML = '<div id="test"></div>';
      var div = fixtureEl.querySelector('#test');
      expect(_selectorEngine["default"].find('#test')).toEqual([div]);
    });
    it('should handle :scope selectors', function () {
      fixtureEl.innerHTML = "<ul>\n        <li></li>\n        <li>\n          <a href=\"#\" class=\"active\">link</a>\n        </li>\n        <li></li>\n      </ul>";
      var listEl = fixtureEl.querySelector('ul');
      var aActive = fixtureEl.querySelector('.active');
      expect(_selectorEngine["default"].find(':scope > li > .active', listEl)).toEqual([aActive]);
    });
  });
  describe('findOne', function () {
    it('should return one element', function () {
      fixtureEl.innerHTML = '<div id="test"></div>';
      var div = fixtureEl.querySelector('#test');
      expect(_selectorEngine["default"].findOne('#test')).toEqual(div);
    });
  });
  describe('children', function () {
    it('should find children', function () {
      var _ref;

      fixtureEl.innerHTML = "<ul>\n        <li></li>\n        <li></li>\n        <li></li>\n      </ul>";
      var list = fixtureEl.querySelector('ul');

      var liList = (_ref = []).concat.apply(_ref, _toConsumableArray(fixtureEl.querySelectorAll('li')));

      var result = _selectorEngine["default"].children(list, 'li');

      expect(result).toEqual(liList);
    });
  });
  describe('parents', function () {
    it('should return parents', function () {
      expect(_selectorEngine["default"].parents(fixtureEl, 'body').length).toEqual(1);
    });
  });
  describe('prev', function () {
    it('should return previous element', function () {
      fixtureEl.innerHTML = '<div class="test"></div><button class="btn"></button>';
      var btn = fixtureEl.querySelector('.btn');
      var divTest = fixtureEl.querySelector('.test');
      expect(_selectorEngine["default"].prev(btn, '.test')).toEqual([divTest]);
    });
    it('should return previous element with an extra element between', function () {
      fixtureEl.innerHTML = ['<div class="test"></div>', '<span></span>', '<button class="btn"></button>'].join('');
      var btn = fixtureEl.querySelector('.btn');
      var divTest = fixtureEl.querySelector('.test');
      expect(_selectorEngine["default"].prev(btn, '.test')).toEqual([divTest]);
    });
    it('should return previous element with comments or text nodes between', function () {
      fixtureEl.innerHTML = ['<div class="test"></div>', '<div class="test"></div>', '<!-- Comment-->', 'Text', '<button class="btn"></button>'].join('');
      var btn = fixtureEl.querySelector('.btn');
      var divTest = fixtureEl.querySelectorAll('.test')[1];
      expect(_selectorEngine["default"].prev(btn, '.test')).toEqual([divTest]);
    });
  });
  describe('next', function () {
    it('should return next element', function () {
      fixtureEl.innerHTML = '<div class="test"></div><button class="btn"></button>';
      var btn = fixtureEl.querySelector('.btn');
      var divTest = fixtureEl.querySelector('.test');
      expect(_selectorEngine["default"].next(divTest, '.btn')).toEqual([btn]);
    });
    it('should return next element with an extra element between', function () {
      fixtureEl.innerHTML = ['<div class="test"></div>', '<span></span>', '<button class="btn"></button>'].join('');
      var btn = fixtureEl.querySelector('.btn');
      var divTest = fixtureEl.querySelector('.test');
      expect(_selectorEngine["default"].next(divTest, '.btn')).toEqual([btn]);
    });
    it('should return next element with comments or text nodes between', function () {
      fixtureEl.innerHTML = ['<div class="test"></div>', '<!-- Comment-->', 'Text', '<button class="btn"></button>', '<button class="btn"></button>'].join('');
      var btn = fixtureEl.querySelector('.btn');
      var divTest = fixtureEl.querySelector('.test');
      expect(_selectorEngine["default"].next(divTest, '.btn')).toEqual([btn]);
    });
  });
  describe('focusableChildren', function () {
    it('should return only elements with specific tag names', function () {
      fixtureEl.innerHTML = ['<div>lorem</div>', '<span>lorem</span>', '<a>lorem</a>', '<button>lorem</button>', '<input />', '<textarea></textarea>', '<select></select>', '<details>lorem</details>'].join('');
      var expectedElements = [fixtureEl.querySelector('a'), fixtureEl.querySelector('button'), fixtureEl.querySelector('input'), fixtureEl.querySelector('textarea'), fixtureEl.querySelector('select'), fixtureEl.querySelector('details')];
      expect(_selectorEngine["default"].focusableChildren(fixtureEl)).toEqual(expectedElements);
    });
    it('should return any element with non negative tab index', function () {
      fixtureEl.innerHTML = ['<div tabindex>lorem</div>', '<div tabindex="0">lorem</div>', '<div tabindex="10">lorem</div>'].join('');
      var expectedElements = [fixtureEl.querySelector('[tabindex]'), fixtureEl.querySelector('[tabindex="0"]'), fixtureEl.querySelector('[tabindex="10"]')];
      expect(_selectorEngine["default"].focusableChildren(fixtureEl)).toEqual(expectedElements);
    });
    it('should return not return elements with negative tab index', function () {
      fixtureEl.innerHTML = ['<button tabindex="-1">lorem</button>'].join('');
      var expectedElements = [];
      expect(_selectorEngine["default"].focusableChildren(fixtureEl)).toEqual(expectedElements);
    });
    it('should return contenteditable elements', function () {
      fixtureEl.innerHTML = ['<div contenteditable="true">lorem</div>'].join('');
      var expectedElements = [fixtureEl.querySelector('[contenteditable="true"]')];
      expect(_selectorEngine["default"].focusableChildren(fixtureEl)).toEqual(expectedElements);
    });
    it('should not return disabled elements', function () {
      fixtureEl.innerHTML = ['<button disabled="true">lorem</button>'].join('');
      var expectedElements = [];
      expect(_selectorEngine["default"].focusableChildren(fixtureEl)).toEqual(expectedElements);
    });
    it('should not return invisible elements', function () {
      fixtureEl.innerHTML = ['<button style="display:none;">lorem</button>'].join('');
      var expectedElements = [];
      expect(_selectorEngine["default"].focusableChildren(fixtureEl)).toEqual(expectedElements);
    });
  });
});
"use strict";

var _backdrop = _interopRequireDefault(require("../../../src/util/backdrop"));

var _index = require("../../../src/util/index");

var _fixture = require("../../helpers/fixture");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var CLASS_BACKDROP = '.modal-backdrop';
var CLASS_NAME_FADE = 'fade';
var CLASS_NAME_SHOW = 'show';
describe('Backdrop', function () {
  var fixtureEl;
  beforeAll(function () {
    fixtureEl = (0, _fixture.getFixture)();
  });
  afterEach(function () {
    (0, _fixture.clearFixture)();
    var list = document.querySelectorAll(CLASS_BACKDROP);
    list.forEach(function (el) {
      el.remove();
    });
  });
  describe('show', function () {
    it('if it is "shown", should append the backdrop html once, on show, and contain "show" class', function (done) {
      var instance = new _backdrop["default"]({
        isVisible: true,
        isAnimated: false
      });

      var getElements = function getElements() {
        return document.querySelectorAll(CLASS_BACKDROP);
      };

      expect(getElements().length).toEqual(0);
      instance.show();
      instance.show(function () {
        expect(getElements().length).toEqual(1);
        getElements().forEach(function (el) {
          expect(el.classList.contains(CLASS_NAME_SHOW)).toEqual(true);
        });
        done();
      });
    });
    it('if it is not "shown", should not append the backdrop html', function (done) {
      var instance = new _backdrop["default"]({
        isVisible: false,
        isAnimated: true
      });

      var getElements = function getElements() {
        return document.querySelectorAll(CLASS_BACKDROP);
      };

      expect(getElements().length).toEqual(0);
      instance.show(function () {
        expect(getElements().length).toEqual(0);
        done();
      });
    });
    it('if it is "shown" and "animated", should append the backdrop html once, and contain "fade" class', function (done) {
      var instance = new _backdrop["default"]({
        isVisible: true,
        isAnimated: true
      });

      var getElements = function getElements() {
        return document.querySelectorAll(CLASS_BACKDROP);
      };

      expect(getElements().length).toEqual(0);
      instance.show(function () {
        expect(getElements().length).toEqual(1);
        getElements().forEach(function (el) {
          expect(el.classList.contains(CLASS_NAME_FADE)).toEqual(true);
        });
        done();
      });
    });
  });
  describe('hide', function () {
    it('should remove the backdrop html', function (done) {
      var instance = new _backdrop["default"]({
        isVisible: true,
        isAnimated: true
      });

      var getElements = function getElements() {
        return document.body.querySelectorAll(CLASS_BACKDROP);
      };

      expect(getElements().length).toEqual(0);
      instance.show(function () {
        expect(getElements().length).toEqual(1);
        instance.hide(function () {
          expect(getElements().length).toEqual(0);
          done();
        });
      });
    });
    it('should remove "show" class', function (done) {
      var instance = new _backdrop["default"]({
        isVisible: true,
        isAnimated: true
      });

      var elem = instance._getElement();

      instance.show();
      instance.hide(function () {
        expect(elem.classList.contains(CLASS_NAME_SHOW)).toEqual(false);
        done();
      });
    });
    it('if it is not "shown", should not try to remove Node on remove method', function (done) {
      var instance = new _backdrop["default"]({
        isVisible: false,
        isAnimated: true
      });

      var getElements = function getElements() {
        return document.querySelectorAll(CLASS_BACKDROP);
      };

      var spy = spyOn(instance, 'dispose').and.callThrough();
      expect(getElements().length).toEqual(0);
      expect(instance._isAppended).toEqual(false);
      instance.show(function () {
        instance.hide(function () {
          expect(getElements().length).toEqual(0);
          expect(spy).not.toHaveBeenCalled();
          expect(instance._isAppended).toEqual(false);
          done();
        });
      });
    });
    it('should not error if the backdrop no longer has a parent', function (done) {
      fixtureEl.innerHTML = '<div id="wrapper"></div>';
      var wrapper = fixtureEl.querySelector('#wrapper');
      var instance = new _backdrop["default"]({
        isVisible: true,
        isAnimated: true,
        rootElement: wrapper
      });

      var getElements = function getElements() {
        return document.querySelectorAll(CLASS_BACKDROP);
      };

      instance.show(function () {
        wrapper.remove();
        instance.hide(function () {
          expect(getElements().length).toEqual(0);
          done();
        });
      });
    });
  });
  describe('click callback', function () {
    it('it should execute callback on click', function (done) {
      var spy = jasmine.createSpy('spy');
      var instance = new _backdrop["default"]({
        isVisible: true,
        isAnimated: false,
        clickCallback: function clickCallback() {
          return spy();
        }
      });

      var endTest = function endTest() {
        setTimeout(function () {
          expect(spy).toHaveBeenCalled();
          done();
        }, 10);
      };

      instance.show(function () {
        var clickEvent = document.createEvent('MouseEvents');
        clickEvent.initEvent('mousedown', true, true);
        document.querySelector(CLASS_BACKDROP).dispatchEvent(clickEvent);
        endTest();
      });
    });
  });
  describe('animation callbacks', function () {
    it('if it is animated, should show and hide backdrop after counting transition duration', function (done) {
      var instance = new _backdrop["default"]({
        isVisible: true,
        isAnimated: true
      });
      var spy2 = jasmine.createSpy('spy2');

      var execDone = function execDone() {
        setTimeout(function () {
          expect(spy2).toHaveBeenCalledTimes(2);
          done();
        }, 10);
      };

      instance.show(spy2);
      instance.hide(function () {
        spy2();
        execDone();
      });
      expect(spy2).not.toHaveBeenCalled();
    });
    it('if it is not animated, should show and hide backdrop without delay', function (done) {
      var spy = jasmine.createSpy('spy', _index.getTransitionDurationFromElement);
      var instance = new _backdrop["default"]({
        isVisible: true,
        isAnimated: false
      });
      var spy2 = jasmine.createSpy('spy2');
      instance.show(spy2);
      instance.hide(spy2);
      setTimeout(function () {
        expect(spy2).toHaveBeenCalled();
        expect(spy).not.toHaveBeenCalled();
        done();
      }, 10);
    });
    it('if it is not "shown", should not call delay callbacks', function (done) {
      var instance = new _backdrop["default"]({
        isVisible: false,
        isAnimated: true
      });
      var spy = jasmine.createSpy('spy', _index.getTransitionDurationFromElement);
      instance.show();
      instance.hide(function () {
        expect(spy).not.toHaveBeenCalled();
        done();
      });
    });
  });
  describe('Config', function () {
    describe('rootElement initialization', function () {
      it('Should be appended on "document.body" by default', function (done) {
        var instance = new _backdrop["default"]({
          isVisible: true
        });

        var getElement = function getElement() {
          return document.querySelector(CLASS_BACKDROP);
        };

        instance.show(function () {
          expect(getElement().parentElement).toEqual(document.body);
          done();
        });
      });
      it('Should find the rootElement if passed as a string', function (done) {
        var instance = new _backdrop["default"]({
          isVisible: true,
          rootElement: 'body'
        });

        var getElement = function getElement() {
          return document.querySelector(CLASS_BACKDROP);
        };

        instance.show(function () {
          expect(getElement().parentElement).toEqual(document.body);
          done();
        });
      });
      it('Should appended on any element given by the proper config', function (done) {
        fixtureEl.innerHTML = ['<div id="wrapper">', '</div>'].join('');
        var wrapper = fixtureEl.querySelector('#wrapper');
        var instance = new _backdrop["default"]({
          isVisible: true,
          rootElement: wrapper
        });

        var getElement = function getElement() {
          return document.querySelector(CLASS_BACKDROP);
        };

        instance.show(function () {
          expect(getElement().parentElement).toEqual(wrapper);
          done();
        });
      });
    });
    describe('ClassName', function () {
      it('Should be able to have different classNames than default', function (done) {
        var instance = new _backdrop["default"]({
          isVisible: true,
          className: 'foo'
        });

        var getElement = function getElement() {
          return document.querySelector('.foo');
        };

        instance.show(function () {
          expect(getElement()).toEqual(instance._getElement());
          instance.dispose();
          done();
        });
      });
    });
  });
});
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var _fixture = require("../../helpers/fixture");

var _componentFunctions = require("../../../src/util/component-functions");

var _baseComponent = _interopRequireDefault(require("../../../src/base-component"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var DummyClass2 = /*#__PURE__*/function (_BaseComponent) {
  _inherits(DummyClass2, _BaseComponent);

  var _super = _createSuper(DummyClass2);

  function DummyClass2() {
    _classCallCheck(this, DummyClass2);

    return _super.apply(this, arguments);
  }

  _createClass(DummyClass2, [{
    key: "hide",
    value: function hide() {
      return true;
    }
  }, {
    key: "testMethod",
    value: function testMethod() {
      return true;
    }
  }], [{
    key: "NAME",
    get: function get() {
      return 'test';
    }
  }]);

  return DummyClass2;
}(_baseComponent["default"]);

describe('Plugin functions', function () {
  var fixtureEl;
  beforeAll(function () {
    fixtureEl = (0, _fixture.getFixture)();
  });
  afterEach(function () {
    (0, _fixture.clearFixture)();
  });
  describe('data-bs-dismiss functionality', function () {
    it('should get Plugin and execute the given method, when a click occurred on data-bs-dismiss="PluginName"', function () {
      fixtureEl.innerHTML = ['<div id="foo" class="test">', '      <button type="button" data-bs-dismiss="test" data-bs-target="#foo"></button>', '</div>'].join('');
      spyOn(DummyClass2, 'getOrCreateInstance').and.callThrough();
      spyOn(DummyClass2.prototype, 'testMethod');
      var componentWrapper = fixtureEl.querySelector('#foo');
      var btnClose = fixtureEl.querySelector('[data-bs-dismiss="test"]');
      var event = (0, _fixture.createEvent)('click');
      (0, _componentFunctions.enableDismissTrigger)(DummyClass2, 'testMethod');
      btnClose.dispatchEvent(event);
      expect(DummyClass2.getOrCreateInstance).toHaveBeenCalledWith(componentWrapper);
      expect(DummyClass2.prototype.testMethod).toHaveBeenCalled();
    });
    it('if data-bs-dismiss="PluginName" hasn\'t got "data-bs-target", "getOrCreateInstance" has to be initialized by closest "plugin.Name" class', function () {
      fixtureEl.innerHTML = ['<div id="foo" class="test">', '   <button type="button" data-bs-dismiss="test"></button>', '</div>'].join('');
      spyOn(DummyClass2, 'getOrCreateInstance').and.callThrough();
      spyOn(DummyClass2.prototype, 'hide');
      var componentWrapper = fixtureEl.querySelector('#foo');
      var btnClose = fixtureEl.querySelector('[data-bs-dismiss="test"]');
      var event = (0, _fixture.createEvent)('click');
      (0, _componentFunctions.enableDismissTrigger)(DummyClass2);
      btnClose.dispatchEvent(event);
      expect(DummyClass2.getOrCreateInstance).toHaveBeenCalledWith(componentWrapper);
      expect(DummyClass2.prototype.hide).toHaveBeenCalled();
    });
    it('if data-bs-dismiss="PluginName" is disabled, must not trigger function', function () {
      fixtureEl.innerHTML = ['<div id="foo" class="test">', '   <button type="button" disabled data-bs-dismiss="test"></button>', '</div>'].join('');
      spyOn(DummyClass2, 'getOrCreateInstance').and.callThrough();
      var btnClose = fixtureEl.querySelector('[data-bs-dismiss="test"]');
      var event = (0, _fixture.createEvent)('click');
      (0, _componentFunctions.enableDismissTrigger)(DummyClass2);
      btnClose.dispatchEvent(event);
      expect(DummyClass2.getOrCreateInstance).not.toHaveBeenCalled();
    });
    it('should prevent default when the trigger is <a> or <area>', function () {
      fixtureEl.innerHTML = ['<div id="foo" class="test">', '      <a type="button" data-bs-dismiss="test"></a>', '</div>'].join('');
      var btnClose = fixtureEl.querySelector('[data-bs-dismiss="test"]');
      var event = (0, _fixture.createEvent)('click');
      (0, _componentFunctions.enableDismissTrigger)(DummyClass2);
      spyOn(Event.prototype, 'preventDefault').and.callThrough();
      btnClose.dispatchEvent(event);
      expect(Event.prototype.preventDefault).toHaveBeenCalled();
    });
  });
});
"use strict";

var _focustrap = _interopRequireDefault(require("../../../src/util/focustrap"));

var _eventHandler = _interopRequireDefault(require("../../../src/dom/event-handler"));

var _selectorEngine = _interopRequireDefault(require("../../../src/dom/selector-engine"));

var _fixture = require("../../helpers/fixture");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

describe('FocusTrap', function () {
  var fixtureEl;
  beforeAll(function () {
    fixtureEl = (0, _fixture.getFixture)();
  });
  afterEach(function () {
    (0, _fixture.clearFixture)();
  });
  describe('activate', function () {
    it('should autofocus itself by default', function () {
      fixtureEl.innerHTML = '<div id="focustrap" tabindex="-1"></div>';
      var trapElement = fixtureEl.querySelector('div');
      spyOn(trapElement, 'focus');
      var focustrap = new _focustrap["default"]({
        trapElement: trapElement
      });
      focustrap.activate();
      expect(trapElement.focus).toHaveBeenCalled();
    });
    it('if configured not to autofocus, should not autofocus itself', function () {
      fixtureEl.innerHTML = '<div id="focustrap" tabindex="-1"></div>';
      var trapElement = fixtureEl.querySelector('div');
      spyOn(trapElement, 'focus');
      var focustrap = new _focustrap["default"]({
        trapElement: trapElement,
        autofocus: false
      });
      focustrap.activate();
      expect(trapElement.focus).not.toHaveBeenCalled();
    });
    it('should force focus inside focus trap if it can', function (done) {
      fixtureEl.innerHTML = ['<a href="#" id="outside">outside</a>', '<div id="focustrap" tabindex="-1">', '   <a href="#" id="inside">inside</a>', '</div>'].join('');
      var trapElement = fixtureEl.querySelector('div');
      var focustrap = new _focustrap["default"]({
        trapElement: trapElement
      });
      focustrap.activate();
      var inside = document.getElementById('inside');

      var focusInListener = function focusInListener() {
        expect(inside.focus).toHaveBeenCalled();
        document.removeEventListener('focusin', focusInListener);
        done();
      };

      spyOn(inside, 'focus');
      spyOn(_selectorEngine["default"], 'focusableChildren').and.callFake(function () {
        return [inside];
      });
      document.addEventListener('focusin', focusInListener);
      var focusInEvent = (0, _fixture.createEvent)('focusin', {
        bubbles: true
      });
      Object.defineProperty(focusInEvent, 'target', {
        value: document.getElementById('outside')
      });
      document.dispatchEvent(focusInEvent);
    });
    it('should wrap focus around forward on tab', function (done) {
      fixtureEl.innerHTML = ['<a href="#" id="outside">outside</a>', '<div id="focustrap" tabindex="-1">', '   <a href="#" id="first">first</a>', '   <a href="#" id="inside">inside</a>', '   <a href="#" id="last">last</a>', '</div>'].join('');
      var trapElement = fixtureEl.querySelector('div');
      var focustrap = new _focustrap["default"]({
        trapElement: trapElement
      });
      focustrap.activate();
      var first = document.getElementById('first');
      var inside = document.getElementById('inside');
      var last = document.getElementById('last');
      var outside = document.getElementById('outside');
      spyOn(_selectorEngine["default"], 'focusableChildren').and.callFake(function () {
        return [first, inside, last];
      });
      spyOn(first, 'focus').and.callThrough();

      var focusInListener = function focusInListener() {
        expect(first.focus).toHaveBeenCalled();
        first.removeEventListener('focusin', focusInListener);
        done();
      };

      first.addEventListener('focusin', focusInListener);
      var keydown = (0, _fixture.createEvent)('keydown');
      keydown.key = 'Tab';
      document.dispatchEvent(keydown);
      outside.focus();
    });
    it('should wrap focus around backwards on shift-tab', function (done) {
      fixtureEl.innerHTML = ['<a href="#" id="outside">outside</a>', '<div id="focustrap" tabindex="-1">', '   <a href="#" id="first">first</a>', '   <a href="#" id="inside">inside</a>', '   <a href="#" id="last">last</a>', '</div>'].join('');
      var trapElement = fixtureEl.querySelector('div');
      var focustrap = new _focustrap["default"]({
        trapElement: trapElement
      });
      focustrap.activate();
      var first = document.getElementById('first');
      var inside = document.getElementById('inside');
      var last = document.getElementById('last');
      var outside = document.getElementById('outside');
      spyOn(_selectorEngine["default"], 'focusableChildren').and.callFake(function () {
        return [first, inside, last];
      });
      spyOn(last, 'focus').and.callThrough();

      var focusInListener = function focusInListener() {
        expect(last.focus).toHaveBeenCalled();
        last.removeEventListener('focusin', focusInListener);
        done();
      };

      last.addEventListener('focusin', focusInListener);
      var keydown = (0, _fixture.createEvent)('keydown');
      keydown.key = 'Tab';
      keydown.shiftKey = true;
      document.dispatchEvent(keydown);
      outside.focus();
    });
    it('should force focus on itself if there is no focusable content', function (done) {
      fixtureEl.innerHTML = ['<a href="#" id="outside">outside</a>', '<div id="focustrap" tabindex="-1"></div>'].join('');
      var trapElement = fixtureEl.querySelector('div');
      var focustrap = new _focustrap["default"]({
        trapElement: trapElement
      });
      focustrap.activate();

      var focusInListener = function focusInListener() {
        expect(focustrap._config.trapElement.focus).toHaveBeenCalled();
        document.removeEventListener('focusin', focusInListener);
        done();
      };

      spyOn(focustrap._config.trapElement, 'focus');
      document.addEventListener('focusin', focusInListener);
      var focusInEvent = (0, _fixture.createEvent)('focusin', {
        bubbles: true
      });
      Object.defineProperty(focusInEvent, 'target', {
        value: document.getElementById('outside')
      });
      document.dispatchEvent(focusInEvent);
    });
  });
  describe('deactivate', function () {
    it('should flag itself as no longer active', function () {
      var focustrap = new _focustrap["default"]({
        trapElement: fixtureEl
      });
      focustrap.activate();
      expect(focustrap._isActive).toBe(true);
      focustrap.deactivate();
      expect(focustrap._isActive).toBe(false);
    });
    it('should remove all event listeners', function () {
      var focustrap = new _focustrap["default"]({
        trapElement: fixtureEl
      });
      focustrap.activate();
      spyOn(_eventHandler["default"], 'off');
      focustrap.deactivate();
      expect(_eventHandler["default"].off).toHaveBeenCalled();
    });
    it('doesn\'t try removing event listeners unless it needs to (in case it hasn\'t been activated)', function () {
      var focustrap = new _focustrap["default"]({
        trapElement: fixtureEl
      });
      spyOn(_eventHandler["default"], 'off');
      focustrap.deactivate();
      expect(_eventHandler["default"].off).not.toHaveBeenCalled();
    });
  });
});
"use strict";

var Util = _interopRequireWildcard(require("../../../src/util/index"));

var _fixture = require("../../helpers/fixture");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

describe('Util', function () {
  var fixtureEl;
  beforeAll(function () {
    fixtureEl = (0, _fixture.getFixture)();
  });
  afterEach(function () {
    (0, _fixture.clearFixture)();
  });
  describe('getUID', function () {
    it('should generate uid', function () {
      var uid = Util.getUID('bs');
      var uid2 = Util.getUID('bs');
      expect(uid).not.toEqual(uid2);
    });
  });
  describe('getSelectorFromElement', function () {
    it('should get selector from data-bs-target', function () {
      fixtureEl.innerHTML = ['<div id="test" data-bs-target=".target"></div>', '<div class="target"></div>'].join('');
      var testEl = fixtureEl.querySelector('#test');
      expect(Util.getSelectorFromElement(testEl)).toEqual('.target');
    });
    it('should get selector from href if no data-bs-target set', function () {
      fixtureEl.innerHTML = ['<a id="test" href=".target"></a>', '<div class="target"></div>'].join('');
      var testEl = fixtureEl.querySelector('#test');
      expect(Util.getSelectorFromElement(testEl)).toEqual('.target');
    });
    it('should get selector from href if data-bs-target equal to #', function () {
      fixtureEl.innerHTML = ['<a id="test" data-bs-target="#" href=".target"></a>', '<div class="target"></div>'].join('');
      var testEl = fixtureEl.querySelector('#test');
      expect(Util.getSelectorFromElement(testEl)).toEqual('.target');
    });
    it('should return null if a selector from a href is a url without an anchor', function () {
      fixtureEl.innerHTML = ['<a id="test" data-bs-target="#" href="foo/bar.html"></a>', '<div class="target"></div>'].join('');
      var testEl = fixtureEl.querySelector('#test');
      expect(Util.getSelectorFromElement(testEl)).toBeNull();
    });
    it('should return the anchor if a selector from a href is a url', function () {
      fixtureEl.innerHTML = ['<a id="test" data-bs-target="#" href="foo/bar.html#target"></a>', '<div id="target"></div>'].join('');
      var testEl = fixtureEl.querySelector('#test');
      expect(Util.getSelectorFromElement(testEl)).toEqual('#target');
    });
    it('should return null if selector not found', function () {
      fixtureEl.innerHTML = '<a id="test" href=".target"></a>';
      var testEl = fixtureEl.querySelector('#test');
      expect(Util.getSelectorFromElement(testEl)).toBeNull();
    });
    it('should return null if no selector', function () {
      fixtureEl.innerHTML = '<div></div>';
      var testEl = fixtureEl.querySelector('div');
      expect(Util.getSelectorFromElement(testEl)).toBeNull();
    });
  });
  describe('getElementFromSelector', function () {
    it('should get element from data-bs-target', function () {
      fixtureEl.innerHTML = ['<div id="test" data-bs-target=".target"></div>', '<div class="target"></div>'].join('');
      var testEl = fixtureEl.querySelector('#test');
      expect(Util.getElementFromSelector(testEl)).toEqual(fixtureEl.querySelector('.target'));
    });
    it('should get element from href if no data-bs-target set', function () {
      fixtureEl.innerHTML = ['<a id="test" href=".target"></a>', '<div class="target"></div>'].join('');
      var testEl = fixtureEl.querySelector('#test');
      expect(Util.getElementFromSelector(testEl)).toEqual(fixtureEl.querySelector('.target'));
    });
    it('should return null if element not found', function () {
      fixtureEl.innerHTML = '<a id="test" href=".target"></a>';
      var testEl = fixtureEl.querySelector('#test');
      expect(Util.getElementFromSelector(testEl)).toBeNull();
    });
    it('should return null if no selector', function () {
      fixtureEl.innerHTML = '<div></div>';
      var testEl = fixtureEl.querySelector('div');
      expect(Util.getElementFromSelector(testEl)).toBeNull();
    });
  });
  describe('getTransitionDurationFromElement', function () {
    it('should get transition from element', function () {
      fixtureEl.innerHTML = '<div style="transition: all 300ms ease-out;"></div>';
      expect(Util.getTransitionDurationFromElement(fixtureEl.querySelector('div'))).toEqual(300);
    });
    it('should return 0 if the element is undefined or null', function () {
      expect(Util.getTransitionDurationFromElement(null)).toEqual(0);
      expect(Util.getTransitionDurationFromElement(undefined)).toEqual(0);
    });
    it('should return 0 if the element do not possess transition', function () {
      fixtureEl.innerHTML = '<div></div>';
      expect(Util.getTransitionDurationFromElement(fixtureEl.querySelector('div'))).toEqual(0);
    });
  });
  describe('triggerTransitionEnd', function () {
    it('should trigger transitionend event', function (done) {
      fixtureEl.innerHTML = '<div></div>';
      var el = fixtureEl.querySelector('div');
      var spy = spyOn(el, 'dispatchEvent').and.callThrough();
      el.addEventListener('transitionend', function () {
        expect(spy).toHaveBeenCalled();
        done();
      });
      Util.triggerTransitionEnd(el);
    });
  });
  describe('isElement', function () {
    it('should detect if the parameter is an element or not and return Boolean', function () {
      fixtureEl.innerHTML = ['<div id="foo" class="test"></div>', '<div id="bar" class="test"></div>'].join('');
      var el = fixtureEl.querySelector('#foo');
      expect(Util.isElement(el)).toEqual(true);
      expect(Util.isElement({})).toEqual(false);
      expect(Util.isElement(fixtureEl.querySelectorAll('.test'))).toEqual(false);
    });
    it('should detect jQuery element', function () {
      fixtureEl.innerHTML = '<div></div>';
      var el = fixtureEl.querySelector('div');
      var fakejQuery = {
        0: el,
        jquery: 'foo'
      };
      expect(Util.isElement(fakejQuery)).toEqual(true);
    });
  });
  describe('getElement', function () {
    it('should try to parse element', function () {
      fixtureEl.innerHTML = ['<div id="foo" class="test"></div>', '<div id="bar" class="test"></div>'].join('');
      var el = fixtureEl.querySelector('div');
      expect(Util.getElement(el)).toEqual(el);
      expect(Util.getElement('#foo')).toEqual(el);
      expect(Util.getElement('#fail')).toBeNull();
      expect(Util.getElement({})).toBeNull();
      expect(Util.getElement([])).toBeNull();
      expect(Util.getElement()).toBeNull();
      expect(Util.getElement(null)).toBeNull();
      expect(Util.getElement(fixtureEl.querySelectorAll('.test'))).toBeNull();
      var fakejQueryObject = {
        0: el,
        jquery: 'foo'
      };
      expect(Util.getElement(fakejQueryObject)).toEqual(el);
    });
  });
  describe('typeCheckConfig', function () {
    var namePlugin = 'collapse';
    it('should check type of the config object', function () {
      var defaultType = {
        toggle: 'boolean',
        parent: '(string|element)'
      };
      var config = {
        toggle: true,
        parent: 777
      };
      expect(function () {
        Util.typeCheckConfig(namePlugin, config, defaultType);
      }).toThrowError(TypeError, 'COLLAPSE: Option "parent" provided type "number" but expected type "(string|element)".');
    });
    it('should return null stringified when null is passed', function () {
      var defaultType = {
        toggle: 'boolean',
        parent: '(null|element)'
      };
      var config = {
        toggle: true,
        parent: null
      };
      Util.typeCheckConfig(namePlugin, config, defaultType);
      expect().nothing();
    });
    it('should return undefined stringified when undefined is passed', function () {
      var defaultType = {
        toggle: 'boolean',
        parent: '(undefined|element)'
      };
      var config = {
        toggle: true,
        parent: undefined
      };
      Util.typeCheckConfig(namePlugin, config, defaultType);
      expect().nothing();
    });
  });
  describe('isVisible', function () {
    it('should return false if the element is not defined', function () {
      expect(Util.isVisible(null)).toEqual(false);
      expect(Util.isVisible(undefined)).toEqual(false);
    });
    it('should return false if the element provided is not a dom element', function () {
      expect(Util.isVisible({})).toEqual(false);
    });
    it('should return false if the element is not visible with display none', function () {
      fixtureEl.innerHTML = '<div style="display: none;"></div>';
      var div = fixtureEl.querySelector('div');
      expect(Util.isVisible(div)).toEqual(false);
    });
    it('should return false if the element is not visible with visibility hidden', function () {
      fixtureEl.innerHTML = '<div style="visibility: hidden;"></div>';
      var div = fixtureEl.querySelector('div');
      expect(Util.isVisible(div)).toEqual(false);
    });
    it('should return false if an ancestor element is display none', function () {
      fixtureEl.innerHTML = ['<div style="display: none;">', '  <div>', '    <div>', '      <div class="content"></div>', '    </div>', '  </div>', '</div>'].join('');
      var div = fixtureEl.querySelector('.content');
      expect(Util.isVisible(div)).toEqual(false);
    });
    it('should return false if an ancestor element is visibility hidden', function () {
      fixtureEl.innerHTML = ['<div style="visibility: hidden;">', '  <div>', '    <div>', '      <div class="content"></div>', '    </div>', '  </div>', '</div>'].join('');
      var div = fixtureEl.querySelector('.content');
      expect(Util.isVisible(div)).toEqual(false);
    });
    it('should return true if an ancestor element is visibility hidden, but reverted', function () {
      fixtureEl.innerHTML = ['<div style="visibility: hidden;">', '  <div style="visibility: visible;">', '    <div>', '      <div class="content"></div>', '    </div>', '  </div>', '</div>'].join('');
      var div = fixtureEl.querySelector('.content');
      expect(Util.isVisible(div)).toEqual(true);
    });
    it('should return true if the element is visible', function () {
      fixtureEl.innerHTML = ['<div>', '  <div id="element"></div>', '</div>'].join('');
      var div = fixtureEl.querySelector('#element');
      expect(Util.isVisible(div)).toEqual(true);
    });
    it('should return false if the element is hidden, but not via display or visibility', function () {
      fixtureEl.innerHTML = ['<details>', '  <div id="element"></div>', '</details>'].join('');
      var div = fixtureEl.querySelector('#element');
      expect(Util.isVisible(div)).toEqual(false);
    });
  });
  describe('isDisabled', function () {
    it('should return true if the element is not defined', function () {
      expect(Util.isDisabled(null)).toEqual(true);
      expect(Util.isDisabled(undefined)).toEqual(true);
      expect(Util.isDisabled()).toEqual(true);
    });
    it('should return true if the element provided is not a dom element', function () {
      expect(Util.isDisabled({})).toEqual(true);
      expect(Util.isDisabled('test')).toEqual(true);
    });
    it('should return true if the element has disabled attribute', function () {
      fixtureEl.innerHTML = ['<div>', '  <div id="element" disabled="disabled"></div>', '  <div id="element1" disabled="true"></div>', '  <div id="element2" disabled></div>', '</div>'].join('');
      var div = fixtureEl.querySelector('#element');
      var div1 = fixtureEl.querySelector('#element1');
      var div2 = fixtureEl.querySelector('#element2');
      expect(Util.isDisabled(div)).toEqual(true);
      expect(Util.isDisabled(div1)).toEqual(true);
      expect(Util.isDisabled(div2)).toEqual(true);
    });
    it('should return false if the element has disabled attribute with "false" value, or doesn\'t have attribute', function () {
      fixtureEl.innerHTML = ['<div>', '  <div id="element" disabled="false"></div>', '  <div id="element1" ></div>', '</div>'].join('');
      var div = fixtureEl.querySelector('#element');
      var div1 = fixtureEl.querySelector('#element1');
      expect(Util.isDisabled(div)).toEqual(false);
      expect(Util.isDisabled(div1)).toEqual(false);
    });
    it('should return false if the element is not disabled ', function () {
      fixtureEl.innerHTML = ['<div>', '  <button id="button"></button>', '  <select id="select"></select>', '  <select id="input"></select>', '</div>'].join('');

      var el = function el(selector) {
        return fixtureEl.querySelector(selector);
      };

      expect(Util.isDisabled(el('#button'))).toEqual(false);
      expect(Util.isDisabled(el('#select'))).toEqual(false);
      expect(Util.isDisabled(el('#input'))).toEqual(false);
    });
    it('should return true if the element has disabled attribute', function () {
      fixtureEl.innerHTML = ['<div>', '  <input id="input" disabled="disabled"/>', '  <input id="input1" disabled="disabled"/>', '  <button id="button" disabled="true"></button>', '  <button id="button1" disabled="disabled"></button>', '  <button id="button2" disabled></button>', '  <select id="select" disabled></select>', '  <select id="input" disabled></select>', '</div>'].join('');

      var el = function el(selector) {
        return fixtureEl.querySelector(selector);
      };

      expect(Util.isDisabled(el('#input'))).toEqual(true);
      expect(Util.isDisabled(el('#input1'))).toEqual(true);
      expect(Util.isDisabled(el('#button'))).toEqual(true);
      expect(Util.isDisabled(el('#button1'))).toEqual(true);
      expect(Util.isDisabled(el('#button2'))).toEqual(true);
      expect(Util.isDisabled(el('#input'))).toEqual(true);
    });
    it('should return true if the element has class "disabled"', function () {
      fixtureEl.innerHTML = ['<div>', '  <div id="element" class="disabled"></div>', '</div>'].join('');
      var div = fixtureEl.querySelector('#element');
      expect(Util.isDisabled(div)).toEqual(true);
    });
    it('should return true if the element has class "disabled" but disabled attribute is false', function () {
      fixtureEl.innerHTML = ['<div>', '  <input id="input" class="disabled" disabled="false"/>', '</div>'].join('');
      var div = fixtureEl.querySelector('#input');
      expect(Util.isDisabled(div)).toEqual(true);
    });
  });
  describe('findShadowRoot', function () {
    it('should return null if shadow dom is not available', function () {
      // Only for newer browsers
      if (!document.documentElement.attachShadow) {
        expect().nothing();
        return;
      }

      fixtureEl.innerHTML = '<div></div>';
      var div = fixtureEl.querySelector('div');
      spyOn(document.documentElement, 'attachShadow').and.returnValue(null);
      expect(Util.findShadowRoot(div)).toEqual(null);
    });
    it('should return null when we do not find a shadow root', function () {
      // Only for newer browsers
      if (!document.documentElement.attachShadow) {
        expect().nothing();
        return;
      }

      spyOn(document, 'getRootNode').and.returnValue(undefined);
      expect(Util.findShadowRoot(document)).toEqual(null);
    });
    it('should return the shadow root when found', function () {
      // Only for newer browsers
      if (!document.documentElement.attachShadow) {
        expect().nothing();
        return;
      }

      fixtureEl.innerHTML = '<div></div>';
      var div = fixtureEl.querySelector('div');
      var shadowRoot = div.attachShadow({
        mode: 'open'
      });
      expect(Util.findShadowRoot(shadowRoot)).toEqual(shadowRoot);
      shadowRoot.innerHTML = '<button>Shadow Button</button>';
      expect(Util.findShadowRoot(shadowRoot.firstChild)).toEqual(shadowRoot);
    });
  });
  describe('noop', function () {
    it('should be a function', function () {
      expect(_typeof(Util.noop)).toEqual('function');
    });
  });
  describe('reflow', function () {
    it('should return element offset height to force the reflow', function () {
      fixtureEl.innerHTML = '<div></div>';
      var div = fixtureEl.querySelector('div');
      var spy = spyOnProperty(div, 'offsetHeight');
      Util.reflow(div);
      expect(spy).toHaveBeenCalled();
    });
  });
  describe('getjQuery', function () {
    var fakejQuery = {
      trigger: function trigger() {}
    };
    beforeEach(function () {
      Object.defineProperty(window, 'jQuery', {
        value: fakejQuery,
        writable: true
      });
    });
    afterEach(function () {
      window.jQuery = undefined;
    });
    it('should return jQuery object when present', function () {
      expect(Util.getjQuery()).toEqual(fakejQuery);
    });
    it('should not return jQuery object when present if data-bs-no-jquery', function () {
      document.body.setAttribute('data-bs-no-jquery', '');
      expect(window.jQuery).toEqual(fakejQuery);
      expect(Util.getjQuery()).toEqual(null);
      document.body.removeAttribute('data-bs-no-jquery');
    });
    it('should not return jQuery if not present', function () {
      window.jQuery = undefined;
      expect(Util.getjQuery()).toEqual(null);
    });
  });
  describe('onDOMContentLoaded', function () {
    it('should execute callbacks when DOMContentLoaded is fired and should not add more than one listener', function () {
      var spy = jasmine.createSpy();
      var spy2 = jasmine.createSpy();
      spyOn(document, 'addEventListener').and.callThrough();
      spyOnProperty(document, 'readyState').and.returnValue('loading');
      Util.onDOMContentLoaded(spy);
      Util.onDOMContentLoaded(spy2);
      document.dispatchEvent(new Event('DOMContentLoaded', {
        bubbles: true,
        cancelable: true
      }));
      expect(spy).toHaveBeenCalled();
      expect(spy2).toHaveBeenCalled();
      expect(document.addEventListener).toHaveBeenCalledTimes(1);
    });
    it('should execute callback if readyState is not "loading"', function () {
      var spy = jasmine.createSpy();
      Util.onDOMContentLoaded(spy);
      expect(spy).toHaveBeenCalled();
    });
  });
  describe('defineJQueryPlugin', function () {
    var fakejQuery = {
      fn: {}
    };
    beforeEach(function () {
      Object.defineProperty(window, 'jQuery', {
        value: fakejQuery,
        writable: true
      });
    });
    afterEach(function () {
      window.jQuery = undefined;
    });
    it('should define a plugin on the jQuery instance', function () {
      var pluginMock = function pluginMock() {};

      pluginMock.NAME = 'test';

      pluginMock.jQueryInterface = function () {};

      Util.defineJQueryPlugin(pluginMock);
      expect(fakejQuery.fn.test).toBe(pluginMock.jQueryInterface);
      expect(fakejQuery.fn.test.Constructor).toBe(pluginMock);
      expect(_typeof(fakejQuery.fn.test.noConflict)).toEqual('function');
    });
  });
  describe('execute', function () {
    it('should execute if arg is function', function () {
      var spy = jasmine.createSpy('spy');
      Util.execute(spy);
      expect(spy).toHaveBeenCalled();
    });
  });
  describe('executeAfterTransition', function () {
    it('should immediately execute a function when waitForTransition parameter is false', function () {
      var el = document.createElement('div');
      var callbackSpy = jasmine.createSpy('callback spy');
      var eventListenerSpy = spyOn(el, 'addEventListener');
      Util.executeAfterTransition(callbackSpy, el, false);
      expect(callbackSpy).toHaveBeenCalled();
      expect(eventListenerSpy).not.toHaveBeenCalled();
    });
    it('should execute a function when a transitionend event is dispatched', function () {
      var el = document.createElement('div');
      var callbackSpy = jasmine.createSpy('callback spy');
      spyOn(window, 'getComputedStyle').and.returnValue({
        transitionDuration: '0.05s',
        transitionDelay: '0s'
      });
      Util.executeAfterTransition(callbackSpy, el);
      el.dispatchEvent(new TransitionEvent('transitionend'));
      expect(callbackSpy).toHaveBeenCalled();
    });
    it('should execute a function after a computed CSS transition duration and there was no transitionend event dispatched', function (done) {
      var el = document.createElement('div');
      var callbackSpy = jasmine.createSpy('callback spy');
      spyOn(window, 'getComputedStyle').and.returnValue({
        transitionDuration: '0.05s',
        transitionDelay: '0s'
      });
      Util.executeAfterTransition(callbackSpy, el);
      setTimeout(function () {
        expect(callbackSpy).toHaveBeenCalled();
        done();
      }, 70);
    });
    it('should not execute a function a second time after a computed CSS transition duration and if a transitionend event has already been dispatched', function (done) {
      var el = document.createElement('div');
      var callbackSpy = jasmine.createSpy('callback spy');
      spyOn(window, 'getComputedStyle').and.returnValue({
        transitionDuration: '0.05s',
        transitionDelay: '0s'
      });
      Util.executeAfterTransition(callbackSpy, el);
      setTimeout(function () {
        el.dispatchEvent(new TransitionEvent('transitionend'));
      }, 50);
      setTimeout(function () {
        expect(callbackSpy).toHaveBeenCalledTimes(1);
        done();
      }, 70);
    });
    it('should not trigger a transitionend event if another transitionend event had already happened', function (done) {
      var el = document.createElement('div');
      spyOn(window, 'getComputedStyle').and.returnValue({
        transitionDuration: '0.05s',
        transitionDelay: '0s'
      });
      Util.executeAfterTransition(function () {}, el); // simulate a event dispatched by the browser

      el.dispatchEvent(new TransitionEvent('transitionend'));
      var dispatchSpy = spyOn(el, 'dispatchEvent').and.callThrough();
      setTimeout(function () {
        // setTimeout should not have triggered another transitionend event.
        expect(dispatchSpy).not.toHaveBeenCalled();
        done();
      }, 70);
    });
    it('should ignore transitionend events from nested elements', function (done) {
      fixtureEl.innerHTML = ['<div class="outer">', '  <div class="nested"></div>', '</div>'].join('');
      var outer = fixtureEl.querySelector('.outer');
      var nested = fixtureEl.querySelector('.nested');
      var callbackSpy = jasmine.createSpy('callback spy');
      spyOn(window, 'getComputedStyle').and.returnValue({
        transitionDuration: '0.05s',
        transitionDelay: '0s'
      });
      Util.executeAfterTransition(callbackSpy, outer);
      nested.dispatchEvent(new TransitionEvent('transitionend', {
        bubbles: true
      }));
      setTimeout(function () {
        expect(callbackSpy).not.toHaveBeenCalled();
      }, 20);
      setTimeout(function () {
        expect(callbackSpy).toHaveBeenCalled();
        done();
      }, 70);
    });
  });
  describe('getNextActiveElement', function () {
    it('should return first element if active not exists or not given and shouldGetNext is either true, or false with cycling being disabled', function () {
      var array = ['a', 'b', 'c', 'd'];
      expect(Util.getNextActiveElement(array, '', true, true)).toEqual('a');
      expect(Util.getNextActiveElement(array, 'g', true, true)).toEqual('a');
      expect(Util.getNextActiveElement(array, '', true, false)).toEqual('a');
      expect(Util.getNextActiveElement(array, 'g', true, false)).toEqual('a');
      expect(Util.getNextActiveElement(array, '', false, false)).toEqual('a');
      expect(Util.getNextActiveElement(array, 'g', false, false)).toEqual('a');
    });
    it('should return last element if active not exists or not given and shouldGetNext is false but cycling is enabled', function () {
      var array = ['a', 'b', 'c', 'd'];
      expect(Util.getNextActiveElement(array, '', false, true)).toEqual('d');
      expect(Util.getNextActiveElement(array, 'g', false, true)).toEqual('d');
    });
    it('should return next element or same if is last', function () {
      var array = ['a', 'b', 'c', 'd'];
      expect(Util.getNextActiveElement(array, 'a', true, true)).toEqual('b');
      expect(Util.getNextActiveElement(array, 'b', true, true)).toEqual('c');
      expect(Util.getNextActiveElement(array, 'd', true, false)).toEqual('d');
    });
    it('should return next element or first, if is last and "isCycleAllowed = true"', function () {
      var array = ['a', 'b', 'c', 'd'];
      expect(Util.getNextActiveElement(array, 'c', true, true)).toEqual('d');
      expect(Util.getNextActiveElement(array, 'd', true, true)).toEqual('a');
    });
    it('should return previous element or same if is first', function () {
      var array = ['a', 'b', 'c', 'd'];
      expect(Util.getNextActiveElement(array, 'b', false, true)).toEqual('a');
      expect(Util.getNextActiveElement(array, 'd', false, true)).toEqual('c');
      expect(Util.getNextActiveElement(array, 'a', false, false)).toEqual('a');
    });
    it('should return next element or first, if is last and "isCycleAllowed = true"', function () {
      var array = ['a', 'b', 'c', 'd'];
      expect(Util.getNextActiveElement(array, 'd', false, true)).toEqual('c');
      expect(Util.getNextActiveElement(array, 'a', false, true)).toEqual('d');
    });
  });
});
"use strict";

var _sanitizer = require("../../../src/util/sanitizer");

describe('Sanitizer', function () {
  describe('sanitizeHtml', function () {
    it('should return the same on empty string', function () {
      var empty = '';
      var result = (0, _sanitizer.sanitizeHtml)(empty, _sanitizer.DefaultAllowlist, null);
      expect(result).toEqual(empty);
    });
    it('should sanitize template by removing tags with XSS', function () {
      var template = ['<div>', '  <a href="javascript:alert(7)">Click me</a>', '  <span>Some content</span>', '</div>'].join('');
      var result = (0, _sanitizer.sanitizeHtml)(template, _sanitizer.DefaultAllowlist, null);
      expect(result).not.toContain('href="javascript:alert(7)');
    });
    it('should allow aria attributes and safe attributes', function () {
      var template = ['<div aria-pressed="true">', '  <span class="test">Some content</span>', '</div>'].join('');
      var result = (0, _sanitizer.sanitizeHtml)(template, _sanitizer.DefaultAllowlist, null);
      expect(result).toContain('aria-pressed');
      expect(result).toContain('class="test"');
    });
    it('should remove tags not in allowlist', function () {
      var template = ['<div>', '  <script>alert(7)</script>', '</div>'].join('');
      var result = (0, _sanitizer.sanitizeHtml)(template, _sanitizer.DefaultAllowlist, null);
      expect(result).not.toContain('<script>');
    });
    it('should not use native api to sanitize if a custom function passed', function () {
      var template = ['<div>', '  <span>Some content</span>', '</div>'].join('');

      function mySanitize(htmlUnsafe) {
        return htmlUnsafe;
      }

      spyOn(DOMParser.prototype, 'parseFromString');
      var result = (0, _sanitizer.sanitizeHtml)(template, _sanitizer.DefaultAllowlist, mySanitize);
      expect(result).toEqual(template);
      expect(DOMParser.prototype.parseFromString).not.toHaveBeenCalled();
    });
    it('should allow multiple sanitation passes of the same template', function () {
      var template = '<img src="test.jpg">';
      var firstResult = (0, _sanitizer.sanitizeHtml)(template, _sanitizer.DefaultAllowlist, null);
      var secondResult = (0, _sanitizer.sanitizeHtml)(template, _sanitizer.DefaultAllowlist, null);
      expect(firstResult).toContain('src');
      expect(secondResult).toContain('src');
    });
  });
});
"use strict";

var _fixture = require("../../helpers/fixture");

var _manipulator = _interopRequireDefault(require("../../../src/dom/manipulator"));

var _scrollbar = _interopRequireDefault(require("../../../src/util/scrollbar"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

describe('ScrollBar', function () {
  var fixtureEl;
  var doc = document.documentElement;

  var parseInt = function parseInt(arg) {
    return Number.parseInt(arg, 10);
  };

  var getPaddingX = function getPaddingX(el) {
    return parseInt(window.getComputedStyle(el).paddingRight);
  };

  var getMarginX = function getMarginX(el) {
    return parseInt(window.getComputedStyle(el).marginRight);
  };

  var getOverFlow = function getOverFlow(el) {
    return el.style.overflow;
  };

  var getPaddingAttr = function getPaddingAttr(el) {
    return _manipulator["default"].getDataAttribute(el, 'padding-right');
  };

  var getMarginAttr = function getMarginAttr(el) {
    return _manipulator["default"].getDataAttribute(el, 'margin-right');
  };

  var getOverFlowAttr = function getOverFlowAttr(el) {
    return _manipulator["default"].getDataAttribute(el, 'overflow');
  };

  var windowCalculations = function windowCalculations() {
    return {
      htmlClient: document.documentElement.clientWidth,
      htmlOffset: document.documentElement.offsetWidth,
      docClient: document.body.clientWidth,
      htmlBound: document.documentElement.getBoundingClientRect().width,
      bodyBound: document.body.getBoundingClientRect().width,
      window: window.innerWidth,
      width: Math.abs(window.innerWidth - document.documentElement.clientWidth)
    };
  };

  var isScrollBarHidden = function isScrollBarHidden() {
    // IOS devices, Android devices and Browsers on Mac, hide scrollbar by default and appear it, only while scrolling. So the tests for scrollbar would fail
    var calc = windowCalculations();
    return calc.htmlClient === calc.htmlOffset && calc.htmlClient === calc.window;
  };

  beforeAll(function () {
    fixtureEl = (0, _fixture.getFixture)(); // custom fixture to avoid extreme style values

    fixtureEl.removeAttribute('style');
  });
  afterAll(function () {
    fixtureEl.remove();
  });
  afterEach(function () {
    (0, _fixture.clearFixture)();
    (0, _fixture.clearBodyAndDocument)();
  });
  beforeEach(function () {
    (0, _fixture.clearBodyAndDocument)();
  });
  describe('isBodyOverflowing', function () {
    it('should return true if body is overflowing', function () {
      document.documentElement.style.overflowY = 'scroll';
      document.body.style.overflowY = 'scroll';
      fixtureEl.innerHTML = ['<div style="height: 110vh; width: 100%"></div>'].join('');
      var result = new _scrollbar["default"]().isOverflowing();

      if (isScrollBarHidden()) {
        expect(result).toEqual(false);
      } else {
        expect(result).toEqual(true);
      }
    });
    it('should return false if body is not overflowing', function () {
      doc.style.overflowY = 'hidden';
      document.body.style.overflowY = 'hidden';
      fixtureEl.innerHTML = ['<div style="height: 110vh; width: 100%"></div>'].join('');
      var scrollBar = new _scrollbar["default"]();
      var result = scrollBar.isOverflowing();
      expect(result).toEqual(false);
    });
  });
  describe('getWidth', function () {
    it('should return an integer greater than zero, if body is overflowing', function () {
      doc.style.overflowY = 'scroll';
      document.body.style.overflowY = 'scroll';
      fixtureEl.innerHTML = ['<div style="height: 110vh; width: 100%"></div>'].join('');
      var result = new _scrollbar["default"]().getWidth();

      if (isScrollBarHidden()) {
        expect(result).toBe(0);
      } else {
        expect(result).toBeGreaterThan(1);
      }
    });
    it('should return 0 if body is not overflowing', function () {
      document.documentElement.style.overflowY = 'hidden';
      document.body.style.overflowY = 'hidden';
      fixtureEl.innerHTML = ['<div style="height: 110vh; width: 100%"></div>'].join('');
      var result = new _scrollbar["default"]().getWidth();
      expect(result).toEqual(0);
    });
  });
  describe('hide - reset', function () {
    it('should adjust the inline padding of fixed elements which are full-width', function (done) {
      fixtureEl.innerHTML = ['<div style="height: 110vh; width: 100%">' + '<div class="fixed-top" id="fixed1" style="padding-right: 0px; width: 100vw"></div>', '<div class="fixed-top" id="fixed2" style="padding-right: 5px; width: 100vw"></div>', '</div>'].join('');
      doc.style.overflowY = 'scroll';
      var fixedEl = fixtureEl.querySelector('#fixed1');
      var fixedEl2 = fixtureEl.querySelector('#fixed2');
      var originalPadding = getPaddingX(fixedEl);
      var originalPadding2 = getPaddingX(fixedEl2);
      var scrollBar = new _scrollbar["default"]();
      var expectedPadding = originalPadding + scrollBar.getWidth();
      var expectedPadding2 = originalPadding2 + scrollBar.getWidth();
      scrollBar.hide();
      var currentPadding = getPaddingX(fixedEl);
      var currentPadding2 = getPaddingX(fixedEl2);
      expect(getPaddingAttr(fixedEl)).toEqual("".concat(originalPadding, "px"), 'original fixed element padding should be stored in data-bs-padding-right');
      expect(getPaddingAttr(fixedEl2)).toEqual("".concat(originalPadding2, "px"), 'original fixed element padding should be stored in data-bs-padding-right');
      expect(currentPadding).toEqual(expectedPadding, 'fixed element padding should be adjusted while opening');
      expect(currentPadding2).toEqual(expectedPadding2, 'fixed element padding should be adjusted while opening');
      scrollBar.reset();
      currentPadding = getPaddingX(fixedEl);
      currentPadding2 = getPaddingX(fixedEl2);
      expect(getPaddingAttr(fixedEl)).toEqual(null, 'data-bs-padding-right should be cleared after closing');
      expect(getPaddingAttr(fixedEl2)).toEqual(null, 'data-bs-padding-right should be cleared after closing');
      expect(currentPadding).toEqual(originalPadding, 'fixed element padding should be reset after closing');
      expect(currentPadding2).toEqual(originalPadding2, 'fixed element padding should be reset after closing');
      done();
    });
    it('should adjust the inline margin and padding of sticky elements', function (done) {
      fixtureEl.innerHTML = ['<div style="height: 110vh">' + '<div class="sticky-top" style="margin-right: 10px; padding-right: 20px; width: 100vw; height: 10px"></div>', '</div>'].join('');
      doc.style.overflowY = 'scroll';
      var stickyTopEl = fixtureEl.querySelector('.sticky-top');
      var originalMargin = getMarginX(stickyTopEl);
      var originalPadding = getPaddingX(stickyTopEl);
      var scrollBar = new _scrollbar["default"]();
      var expectedMargin = originalMargin - scrollBar.getWidth();
      var expectedPadding = originalPadding + scrollBar.getWidth();
      scrollBar.hide();
      expect(getMarginAttr(stickyTopEl)).toEqual("".concat(originalMargin, "px"), 'original sticky element margin should be stored in data-bs-margin-right');
      expect(getMarginX(stickyTopEl)).toEqual(expectedMargin, 'sticky element margin should be adjusted while opening');
      expect(getPaddingAttr(stickyTopEl)).toEqual("".concat(originalPadding, "px"), 'original sticky element margin should be stored in data-bs-margin-right');
      expect(getPaddingX(stickyTopEl)).toEqual(expectedPadding, 'sticky element margin should be adjusted while opening');
      scrollBar.reset();
      expect(getMarginAttr(stickyTopEl)).toEqual(null, 'data-bs-margin-right should be cleared after closing');
      expect(getMarginX(stickyTopEl)).toEqual(originalMargin, 'sticky element margin should be reset after closing');
      expect(getPaddingAttr(stickyTopEl)).toEqual(null, 'data-bs-margin-right should be cleared after closing');
      expect(getPaddingX(stickyTopEl)).toEqual(originalPadding, 'sticky element margin should be reset after closing');
      done();
    });
    it('should not adjust the inline margin and padding of sticky and fixed elements when element do not have full width', function () {
      fixtureEl.innerHTML = ['<div class="sticky-top" style="margin-right: 0px; padding-right: 0px; width: 50vw"></div>'].join('');
      var stickyTopEl = fixtureEl.querySelector('.sticky-top');
      var originalMargin = getMarginX(stickyTopEl);
      var originalPadding = getPaddingX(stickyTopEl);
      var scrollBar = new _scrollbar["default"]();
      scrollBar.hide();
      var currentMargin = getMarginX(stickyTopEl);
      var currentPadding = getPaddingX(stickyTopEl);
      expect(currentMargin).toEqual(originalMargin, 'sticky element\'s margin should not be adjusted while opening');
      expect(currentPadding).toEqual(originalPadding, 'sticky element\'s padding should not be adjusted while opening');
      scrollBar.reset();
    });
    it('should not put data-attribute if element doesn\'t have the proper style property, should just remove style property if element didn\'t had one', function () {
      fixtureEl.innerHTML = ['<div style="height: 110vh; width: 100%">' + '<div class="sticky-top" id="sticky" style="width: 100vw"></div>', '</div>'].join('');
      document.body.style.overflowY = 'scroll';
      var scrollBar = new _scrollbar["default"]();

      var hasPaddingAttr = function hasPaddingAttr(el) {
        return el.hasAttribute('data-bs-padding-right');
      };

      var hasMarginAttr = function hasMarginAttr(el) {
        return el.hasAttribute('data-bs-margin-right');
      };

      var stickyEl = fixtureEl.querySelector('#sticky');
      var originalPadding = getPaddingX(stickyEl);
      var originalMargin = getMarginX(stickyEl);
      var scrollBarWidth = scrollBar.getWidth();
      scrollBar.hide();
      expect(getPaddingX(stickyEl)).toEqual(scrollBarWidth + originalPadding);
      var expectedMargin = scrollBarWidth + originalMargin;
      expect(getMarginX(stickyEl)).toEqual(expectedMargin === 0 ? expectedMargin : -expectedMargin);
      expect(hasMarginAttr(stickyEl)).toBeFalse(); // We do not have to keep css margin

      expect(hasPaddingAttr(stickyEl)).toBeFalse(); // We do not have to keep css padding

      scrollBar.reset();
      expect(getPaddingX(stickyEl)).toEqual(originalPadding);
      expect(getPaddingX(stickyEl)).toEqual(originalPadding);
    });
    describe('Body Handling', function () {
      it('should ignore other inline styles when trying to restore body defaults ', function () {
        document.body.style.color = 'red';
        var scrollBar = new _scrollbar["default"]();
        var scrollBarWidth = scrollBar.getWidth();
        scrollBar.hide();
        expect(getPaddingX(document.body)).toEqual(scrollBarWidth, 'body does not have inline padding set');
        expect(document.body.style.color).toEqual('red', 'body still has other inline styles set');
        scrollBar.reset();
      });
      it('should hide scrollbar and reset it to its initial value', function () {
        var styleSheetPadding = '7px';
        fixtureEl.innerHTML = ['<style>', '  body {', "       padding-right: ".concat(styleSheetPadding, " }"), '  }', '</style>'].join('');
        var el = document.body;
        var inlineStylePadding = '10px';
        el.style.paddingRight = inlineStylePadding;
        var originalPadding = getPaddingX(el);
        expect(originalPadding).toEqual(parseInt(inlineStylePadding)); // Respect only the inline style as it has prevails this of css

        var originalOverFlow = 'auto';
        el.style.overflow = originalOverFlow;
        var scrollBar = new _scrollbar["default"]();
        var scrollBarWidth = scrollBar.getWidth();
        scrollBar.hide();
        var currentPadding = getPaddingX(el);
        expect(currentPadding).toEqual(scrollBarWidth + originalPadding);
        expect(currentPadding).toEqual(scrollBarWidth + parseInt(inlineStylePadding));
        expect(getPaddingAttr(el)).toEqual(inlineStylePadding);
        expect(getOverFlow(el)).toEqual('hidden');
        expect(getOverFlowAttr(el)).toEqual(originalOverFlow);
        scrollBar.reset();
        var currentPadding1 = getPaddingX(el);
        expect(currentPadding1).toEqual(originalPadding);
        expect(getPaddingAttr(el)).toEqual(null);
        expect(getOverFlow(el)).toEqual(originalOverFlow);
        expect(getOverFlowAttr(el)).toEqual(null);
      });
      it('should hide scrollbar and reset it to its initial value - respecting css rules', function () {
        var styleSheetPadding = '7px';
        fixtureEl.innerHTML = ['<style>', '  body {', "       padding-right: ".concat(styleSheetPadding, " }"), '  }', '</style>'].join('');
        var el = document.body;
        var originalPadding = getPaddingX(el);
        var originalOverFlow = 'scroll';
        el.style.overflow = originalOverFlow;
        var scrollBar = new _scrollbar["default"]();
        var scrollBarWidth = scrollBar.getWidth();
        scrollBar.hide();
        var currentPadding = getPaddingX(el);
        expect(currentPadding).toEqual(scrollBarWidth + originalPadding);
        expect(currentPadding).toEqual(scrollBarWidth + parseInt(styleSheetPadding));
        expect(getPaddingAttr(el)).toBeNull(); // We do not have to keep css padding

        expect(getOverFlow(el)).toEqual('hidden');
        expect(getOverFlowAttr(el)).toEqual(originalOverFlow);
        scrollBar.reset();
        var currentPadding1 = getPaddingX(el);
        expect(currentPadding1).toEqual(originalPadding);
        expect(getPaddingAttr(el)).toEqual(null);
        expect(getOverFlow(el)).toEqual(originalOverFlow);
        expect(getOverFlowAttr(el)).toEqual(null);
      });
      it('should not adjust the inline body padding when it does not overflow', function () {
        var originalPadding = getPaddingX(document.body);
        var scrollBar = new _scrollbar["default"](); // Hide scrollbars to prevent the body overflowing

        doc.style.overflowY = 'hidden';
        doc.style.paddingRight = '0px';
        scrollBar.hide();
        var currentPadding = getPaddingX(document.body);
        expect(currentPadding).toEqual(originalPadding, 'body padding should not be adjusted');
        scrollBar.reset();
      });
      it('should not adjust the inline body padding when it does not overflow, even on a scaled display', function () {
        var originalPadding = getPaddingX(document.body);
        var scrollBar = new _scrollbar["default"](); // Remove body margins as would be done by Bootstrap css

        document.body.style.margin = '0'; // Hide scrollbars to prevent the body overflowing

        doc.style.overflowY = 'hidden'; // Simulate a discrepancy between exact, i.e. floating point body width, and rounded body width
        // as it can occur when zooming or scaling the display to something else than 100%

        doc.style.paddingRight = '.48px';
        scrollBar.hide();
        var currentPadding = getPaddingX(document.body);
        expect(currentPadding).toEqual(originalPadding, 'body padding should not be adjusted');
        scrollBar.reset();
      });
    });
  });
});
//# sourceMappingURL=all.js.map
